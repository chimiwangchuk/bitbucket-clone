"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.observe = observe;
exports.unobserve = unobserve;
exports.destroy = destroy;
var INSTANCE_MAP = new Map();
var OBSERVER_MAP = new Map();

/**
 * Monitor element, and trigger callback when element becomes visible
 * @param element {HTMLElement}
 * @param callback {Function} Called with inView
 * @param options {Object} InterSection observer options
 * @param options.threshold {Number} Number between 0 and 1, indicating how much of the element should be visible before triggering
 * @param options.root {HTMLElement} It should have a unique id or data-intersection-id in order for the Observer to reused.
 * @param options.rootMargin {String} The CSS margin to apply to the root element.
 * @param rootId {String} Unique identifier for the root element, to enable reusing the IntersectionObserver
 */
function observe(element, callback) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    threshold: 0
  };
  var rootId = arguments[3];
  var root = options.root,
      rootMargin = options.rootMargin;

  var threshold = options.threshold || 0;
  if (!element || !callback) return;
  var observerId = rootMargin ? threshold.toString() + "_" + rootMargin : "" + threshold.toString();

  if (root) {
    observerId = rootId ? rootId + "_" + observerId : null;
  }

  var observerInstance = observerId ? OBSERVER_MAP.get(observerId) : null;
  if (!observerInstance) {
    observerInstance = new IntersectionObserver(onChange, options);
    if (observerId) OBSERVER_MAP.set(observerId, observerInstance);
  }

  var instance = {
    callback: callback,
    visible: false,
    options: options,
    observerId: observerId,
    observer: !observerId ? observerInstance : undefined
  };

  INSTANCE_MAP.set(element, instance);

  observerInstance.observe(element);

  return instance;
}

/**
 * Stop observing an element. If an element is removed from the DOM or otherwise destroyed,
 * make sure to call this method.
 * @param element {HTMLElement}
 */
function unobserve(element) {
  if (!element) return;
  var instance = INSTANCE_MAP.get(element);

  if (instance) {
    var _observerId = instance.observerId,
        _observer = instance.observer;

    var observerInstance = _observerId ? OBSERVER_MAP.get(_observerId) : _observer;

    if (observerInstance) {
      // $FlowFixMe - the interface in bom.js is wrong. Spec should accept the element.
      observerInstance.unobserve(element);
    }

    // Check if we are still observing any elements with the same threshold.
    var itemsLeft = false;
    if (_observerId) {
      INSTANCE_MAP.forEach(function (item, key) {
        if (item && item.observerId === _observerId && key !== element) {
          itemsLeft = true;
        }
      });
    }

    if (observerInstance && !itemsLeft) {
      // No more elements to observe for threshold, disconnect observer
      observerInstance.disconnect();
      OBSERVER_MAP.delete(_observerId);
    }

    // Remove reference to element
    INSTANCE_MAP.delete(element);
  }
}

/**
 * Destroy all IntersectionObservers currently connected
 **/
function destroy() {
  OBSERVER_MAP.forEach(function (observer) {
    observer.disconnect();
  });

  OBSERVER_MAP.clear();
  INSTANCE_MAP.clear();
}

function onChange(changes) {
  changes.forEach(function (intersection) {
    var isIntersecting = intersection.isIntersecting,
        intersectionRatio = intersection.intersectionRatio,
        target = intersection.target;

    var instance = INSTANCE_MAP.get(target);

    // Firefox can report a negative intersectionRatio when scrolling. Ignore this, and
    if (instance && intersectionRatio >= 0) {
      var _options = instance.options;

      var _inView = false;

      if (Array.isArray(_options.threshold)) {
        // If threshold is an array, check if any of them intersects. This just triggers the onChange event multiple times.
        _inView = _options.threshold.some(function (threshold) {
          return instance.visible ? intersectionRatio > threshold : intersectionRatio >= threshold;
        });
      } else if (_options.threshold !== undefined) {
        // Trigger on 0 ratio only when not visible. This is fallback for browsers without isIntersecting support
        _inView = instance.visible ? intersectionRatio > _options.threshold : intersectionRatio >= _options.threshold;
      }

      if (isIntersecting !== undefined) {
        // If isIntersecting is defined, ensure that the element is actually intersecting.
        // Otherwise it reports a threshold of 0
        _inView = _inView && isIntersecting;
      }

      if (instance.callback) {
        instance.callback(_inView);
      }
    }
  });
}

exports.default = {
  observe: observe,
  unobserve: unobserve,
  destroy: destroy
};
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Context } from '../context';
import { StoreRegistry, bindAction, bindActions, defaultRegistry } from '../store';
import shallowEqual from '../utils/shallow-equal';

var noop = function noop() {
  return function () {};
};

var Container =
/*#__PURE__*/
function (_Component) {
  _inherits(Container, _Component);

  _createClass(Container, null, [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      var scope = nextProps.scope;
      var hasScopeChanged = scope !== prevState.scope;
      var nextState = null;

      if (hasScopeChanged) {
        var actions = prevState.bindContainerActions(scope);
        nextState = {
          scope: scope,
          scopedActions: actions
        };
      } // We trigger the action here so subscribers get new values ASAP


      prevState.triggerContainerAction(nextProps);
      return nextState;
    }
  }]);

  function Container(props, context) {
    var _this;

    _classCallCheck(this, Container);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Container).call(this, props, context));

    _defineProperty(_assertThisInitialized(_this), "bindContainerActions", function (scope) {
      var _this$constructor = _this.constructor,
          storeType = _this$constructor.storeType,
          hooks = _this$constructor.hooks;
      var api = _this.state.api; // we explicitly pass scope as it might be changed

      var _api$getStore = api.getStore(storeType, scope),
          storeState = _api$getStore.storeState;

      var actions = bindActions(storeType.actions, storeState, _this.getContainerProps);
      _this.onInit = bindAction(storeState, hooks.onInit, 'onInit', _this.getContainerProps, actions);
      _this.onUpdate = bindAction(storeState, hooks.onUpdate, 'onUpdate', _this.getContainerProps, actions); // make sure we also reset actionProps

      _this.actionProps = null;
      return actions;
    });

    _defineProperty(_assertThisInitialized(_this), "triggerContainerAction", function (nextProps) {
      // eslint-disable-next-line no-unused-vars
      var children = nextProps.children,
          scope = nextProps.scope,
          isGlobal = nextProps.isGlobal,
          restProps = _objectWithoutProperties(nextProps, ["children", "scope", "isGlobal"]);

      if (shallowEqual(_this.actionProps, restProps)) return; // store restProps on instance so we can diff and use fresh props
      // in actions even before react sets them in this.props

      _this.actionProps = restProps;

      if (_this.onInit) {
        _this.onInit();

        _this.onInit = null;
      } else {
        _this.onUpdate();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "getContainerProps", function () {
      return _this.actionProps;
    });

    _this.registry = new StoreRegistry('__local__');

    var _this$context = _this.context,
        _this$context$globalR = _this$context.globalRegistry,
        globalRegistry = _this$context$globalR === void 0 ? defaultRegistry : _this$context$globalR,
        _this$context$getStor = _this$context.getStore,
        _getStore = _this$context$getStor === void 0 ? defaultRegistry.getStore : _this$context$getStor;

    _this.state = {
      api: {
        globalRegistry: globalRegistry,
        getStore: function getStore(Store, scope) {
          return _this.getScopedStore(Store, scope) || _getStore(Store);
        }
      },
      // stored to make them available in getDerivedStateFromProps
      // as js context there is null https://github.com/facebook/react/issues/12612
      bindContainerActions: _this.bindContainerActions,
      triggerContainerAction: _this.triggerContainerAction,
      scope: props.scope
    };
    _this.state.scopedActions = _this.bindContainerActions(props.scope);
    return _this;
  }

  _createClass(Container, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (this.props.scope !== prevProps.scope) {
        // Trigger a forced update on all subscribers
        // as render might have been blocked
        this.triggerScopeChange(prevProps.scope); // Check if instance has still subscribers, if not delete

        this.deleteScopedStore(prevProps.scope);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.deleteScopedStore();
    }
  }, {
    key: "getRegistry",
    value: function getRegistry() {
      var isLocal = !this.props.scope && !this.props.isGlobal;
      return isLocal ? this.registry : this.state.api.globalRegistry;
    }
  }, {
    key: "getScopedStore",
    value: function getScopedStore(Store) {
      var scopeId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props.scope;
      var storeType = this.constructor.storeType;

      if (Store !== storeType) {
        return null;
      }

      var _this$getRegistry$get = this.getRegistry().getStore(Store, scopeId),
          storeState = _this$getRegistry$get.storeState; // instead of returning global bound actions
      // we return the ones with the countainer props binding


      return {
        storeState: storeState,
        actions: this.state.scopedActions
      };
    }
  }, {
    key: "triggerScopeChange",
    value: function triggerScopeChange(prevScopeId) {
      var storeType = this.constructor.storeType;

      var _this$getScopedStore = this.getScopedStore(storeType, prevScopeId),
          storeState = _this$getScopedStore.storeState; // When called, subscribers that have already re-rendered with the new
      // scope are no longer subscribed to the old one, so we "force update"
      // the remaining.
      // This is sub-optimal as if there are other containers with the same
      // old scope id we will re-render those too, but better than using context
      // as that will re-render all children even if pure/memo


      storeState.listeners().forEach(function (updateFn) {
        return updateFn(undefined, true);
      });
    }
  }, {
    key: "deleteScopedStore",
    value: function deleteScopedStore() {
      var scopeId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props.scope;
      var storeType = this.constructor.storeType;

      var _this$getScopedStore2 = this.getScopedStore(storeType, scopeId),
          storeState = _this$getScopedStore2.storeState;

      if (!storeState.listeners().length) {
        this.getRegistry().deleteStore(storeType, scopeId);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var children = this.props.children;
      return React.createElement(Context.Provider, {
        value: this.state.api
      }, children);
    }
  }]);

  return Container;
}(Component);

_defineProperty(Container, "propTypes", {
  children: PropTypes.node,
  scope: PropTypes.string,
  isGlobal: PropTypes.bool
});

_defineProperty(Container, "storeType", null);

_defineProperty(Container, "hooks", null);

_defineProperty(Container, "contextType", Context);

export { Container as default };
export function createContainer(Store) {
  var _class, _temp;

  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$onInit = _ref.onInit,
      onInit = _ref$onInit === void 0 ? noop : _ref$onInit,
      _ref$onUpdate = _ref.onUpdate,
      onUpdate = _ref$onUpdate === void 0 ? noop : _ref$onUpdate,
      _ref$displayName = _ref.displayName,
      displayName = _ref$displayName === void 0 ? '' : _ref$displayName;

  return _temp = _class =
  /*#__PURE__*/
  function (_Container) {
    _inherits(_class, _Container);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, _getPrototypeOf(_class).apply(this, arguments));
    }

    return _class;
  }(Container), _defineProperty(_class, "storeType", Store), _defineProperty(_class, "displayName", displayName || "Container(".concat(Store.key[0], ")")), _defineProperty(_class, "hooks", {
    onInit: onInit,
    onUpdate: onUpdate
  }), _temp;
}
import { __assign } from "tslib";
import Queue from '@segment/localstorage-retry';
import Scheduler from './Scheduler';
var DEFAULT_FLUSH_BATCH_SIZE = 7;
// These must all be 1. If they are 0, they will not be truthy and in built defaults will be used.
var QUEUE_RETRY_OPTION_OVERRIDES = {
    minRetryDelay: 1,
    maxRetryDelay: 1,
    backoffFactor: 1,
    backoffJitter: 0,
};
/**
 * Create a queue, backed by localstorage, in which items are processed by the queue in batches
 *
 * @param {Object} options queue options,
 * @param {Function} batchProcessFunc the function to process a batch of items from the queue
 */
var BatchableQueue = /** @class */ (function () {
    function BatchableQueue(retryQueuePrefix, retryQueueOptions, batchProcessFunc) {
        var _this = this;
        this.start = function () {
            _this.queue.start();
        };
        this._flush = function (done) {
            if (_this.currentBatch.length !== 0) {
                var batchedQueuedObjects_1 = _this.currentBatch.splice(0, _this.flushBatchSize);
                var batchedItems = batchedQueuedObjects_1.map(function (queuedItem) { return queuedItem.item; });
                _this.batchProcessFunc(batchedItems, function (error, response) {
                    batchedQueuedObjects_1.forEach(function (item) { return item.done(error, response); });
                    done(error);
                    if (_this.currentBatch.length > 0) {
                        _this._schedule();
                    }
                });
            }
            else {
                done();
            }
        };
        this._schedule = function () {
            _this.scheduler.schedule({
                immediate: _this.currentBatch.length >= _this.flushBatchSize,
            });
        };
        this._processSingleElement = function (item, done) {
            _this.currentBatch.push({
                item: item,
                done: done,
            });
            if (_this.currentBatch.length > _this.maxQueueSize) {
                _this.currentBatch.splice(0, _this.currentBatch.length - _this.maxQueueSize);
            }
            _this._schedule();
        };
        this.addItem = function (item) { return _this.queue.addItem(item); };
        this.stop = function () {
            _this.scheduler.stop();
            _this.queue.stop();
        };
        this.on = function (eventName, callback) { return _this.queue.on(eventName, callback); };
        this.maxQueueSize = retryQueueOptions.maxItems || 500;
        this.queue = new Queue(retryQueuePrefix, __assign(__assign({}, retryQueueOptions), QUEUE_RETRY_OPTION_OVERRIDES), this._processSingleElement);
        this.flushBatchSize = retryQueueOptions.batchFlushSize || DEFAULT_FLUSH_BATCH_SIZE;
        this.batchProcessFunc = batchProcessFunc;
        this.currentBatch = [];
        this.scheduler = new Scheduler(__assign(__assign({}, retryQueueOptions), { waitInterval: retryQueueOptions.flushWaitMs }), this._flush);
    }
    return BatchableQueue;
}());
export default BatchableQueue;

import { __assign } from "tslib";
import Analytics from '@segment/analytics.js-core/lib/analytics';
import SegmentIO from './analytics.js-integration-segmentio';
import BeforeSendIntegration from './beforeSendIntegration';
import UIViewedEvent from './uiViewedEvent';
import ApdexEvent from './apdexEvent';
import PageVisibility from './pageVisibility';
import TabTracking from './tabTracking';
import SessionTracking from './sessionTracking';
import TaskSessionStore from './taskSessionStore';
import OriginTracing from './originTracing';
import { envType, eventType, originType, platformType, tenantType, isType, objectValues, } from './analyticsWebTypes';
import { buildScreenEvent, buildActionName, buildActionEvent, buildContext, } from './eventBuilder';
import { validateScreenEvent, validateTrackEvent, validateUIEvent, validateOperationalEvent, validateIdentifyEvent, validatePlatform, validateContainers, } from './eventValidation';
import { defaultHistoryReplaceFn } from './urlUtils';
import wrapCallback from './wrapCallback';
import createGetter from './createGetter';
import SafeSessionStorage from './storage/SafeSessionStorage';
var PROD_HOST = 'as.atlassian.com/api/v1';
var STARGATE_PROD_HOST = 'api-private.atlassian.com/gasv3/api/v1';
var STAGING_HOST = 'as.staging.atl-paas.net/api/v1';
var STARGATE_STAGING_HOST = 'api-private.stg.atlassian.com/gasv3/api/v1';
var ALLOWED_TENANTED_HOSTS = [
    'atlassian.net',
    'jira.com',
    'jira-dev.com',
    'admin.atlassian.com',
    'admin.stg.atlassian.com',
];
var TENANTED_HOST_PATH = '/gateway/api/gasv3/api/v1';
var LAST_SCREEN_EVENT_STORAGE_KEY = 'last.screen.event';
var AnalyticsWebClient = /** @class */ (function () {
    function AnalyticsWebClient(productInfo, settings) {
        var _this = this;
        if (productInfo === void 0) { productInfo = {}; }
        if (settings === void 0) { settings = {}; }
        this._useStargate = function (useStargate) {
            if (useStargate == null) {
                return true;
            }
            return useStargate;
        };
        this._selectHost = function (_a) {
            var useStargate = _a.useStargate, env = _a.env;
            if (!useStargate) {
                return (env === envType.PROD ? PROD_HOST : STAGING_HOST);
            }
            if (_this._isTenantedHost()) {
                return window.location.host + TENANTED_HOST_PATH;
            }
            return (env === envType.PROD ? STARGATE_PROD_HOST : STARGATE_STAGING_HOST);
        };
        this._isTenantedHost = function () { return ALLOWED_TENANTED_HOSTS
            .filter(function (host) { return _this._endsWith(window.location.host, host); }).length > 0; };
        this._endsWith = function (str, suffix) { return str.indexOf(suffix, str.length - suffix.length) !== -1; };
        this._changeInternalUserId = function (userId) {
            // Segment library workaround to change userId without triggering an identify call.
            if (_this._analytics.user().id() !== userId) {
                _this._analytics.user().id(userId);
            }
        };
        this._createSubproductGetter = function (subproduct) { return createGetter(subproduct, 'Cannot get subproduct from the callback. Proceeding without it.'); };
        this._createEmbeddedProductGetter = function (embeddedProduct) { return createGetter(embeddedProduct, 'Cannot get embeddedProduct from the callback. Proceeding without it.'); };
        this._getLastScreenEvent = function () {
            try {
                return JSON.parse(_this._safeSessionStorage.getItem(LAST_SCREEN_EVENT_STORAGE_KEY));
            }
            catch (err) {
                _this._safeSessionStorage.removeItem(LAST_SCREEN_EVENT_STORAGE_KEY);
                return null;
            }
        };
        this._setLastScreenEvent = function (event) {
            _this._safeSessionStorage.setItem(LAST_SCREEN_EVENT_STORAGE_KEY, JSON.stringify({
                name: event.name,
                attributes: event.attributes,
            }));
        };
        this.setEmbeddedProduct = function (embeddedProduct) {
            _this._productInfo.embeddedProduct = _this._createEmbeddedProductGetter(embeddedProduct);
            _this.resetUIViewedTimers();
        };
        this.clearEmbeddedProduct = function () {
            _this._productInfo.embeddedProduct = _this._createEmbeddedProductGetter(null);
        };
        this.setSubproduct = function (subproduct) {
            _this._productInfo.subproduct = _this._createSubproductGetter(subproduct);
            _this.resetUIViewedTimers();
        };
        /**
         * Calling this function in the intialisation of the client in product
         * captures specified 'origin tracing' URL params and fires a single origin landed event
         * <p>
         * This function expects a mapping between the keys for any URL parameters
         *  that should be captured and removed for origin tracing
         * Multiple parameters may be captured simultaneously if multiple key: handler function pairs are provided
         * Each handler function should return an object with two items
         * a) 'originTracingAttributes' - an object that will be added to the 'origin landed' event's attributes under 'originTracing
         * b) 'taskSessionId' (optional) - an Id string that will be added to the tasksessions for any event that fires from the tab, with the key
         *    matching the URL parameter, for the purpose of attributing subsequent analytics event to the origin land.
         * </p>
         * The general use case for this feature is for allowing attributation of user behaviour to a out of product or cross product link,
         * e.g. from a share or email
         *
         * An example calling this function using an external decoding library, with taskSessionId specified to persist
         * analyticsWebClient.setOriginTracingHandlers({
              atlOrigin: encodedOrigin => {
                  const { id, product } = OriginTracing.fromEncoded(encodedOrigin);
                  return { originTracingAttributes: {'id': id, 'product': product}, taskSessionId: id };
              },
          });
         *
         * @param  {Object} originParamHandlerMapping a dictionary of mappings between origin url param keys and handler functions
         * @this {AnalyticsWebClient}
         */
        this.setOriginTracingHandlers = function (originParamHandlerMapping) {
            var capturedOriginTraces = _this.originTracing.handleOriginParameters(originParamHandlerMapping, _this._historyReplaceFn);
            Object.keys(capturedOriginTraces).forEach(function (x) {
                if (typeof capturedOriginTraces[x].taskSessionId !== 'undefined') {
                    _this.task.createTaskSessionWithProvidedId(x, capturedOriginTraces[x].taskSessionId);
                }
            });
            var originAttributes = {};
            Object.keys(capturedOriginTraces).forEach(function (x) {
                if (capturedOriginTraces[x].originTracingAttributes) {
                    originAttributes[x] = capturedOriginTraces[x].originTracingAttributes;
                }
                else {
                    // eslint-disable-next-line no-console
                    console.warn("Handling method for origin parameter " + x + " has not returned any attributes");
                }
            });
            if (Object.keys(capturedOriginTraces).length > 0) {
                _this.sendOperationalEvent({
                    action: 'landed',
                    actionSubject: 'origin',
                    source: 'webClient',
                    attributes: { originTracesLanded: originAttributes },
                }, function () { });
            }
        };
        this.setTenantInfo = function (tenantIdType, tenantId) {
            if (!tenantIdType) {
                throw new Error('Missing tenantIdType');
            }
            if (tenantIdType !== tenantType.NONE && !tenantId) {
                throw new Error('Missing tenantId');
            }
            if (!isType(tenantType, tenantIdType)) {
                throw new Error("Invalid tenantIdType '" + tenantIdType + "', " +
                    ("must be an tenantType: [" + objectValues(tenantType) + "]"));
            }
            _this._tenantInfo = {
                tenantIdType: tenantIdType,
                tenantId: tenantId,
            };
        };
        this.clearTenantInfo = function () {
            _this._tenantInfo = {};
        };
        this.setOrgInfo = function (orgId) {
            if (!orgId) {
                throw new Error('Missing orgId');
            }
            _this._orgInfo = {
                orgId: orgId,
            };
        };
        this.clearOrgInfo = function () {
            _this._orgInfo = {};
        };
        this.setUserInfo = function (userIdType, userId) {
            validateIdentifyEvent(userIdType, userId);
            _this._userInfo = {
                userIdType: userIdType,
                userId: userId,
            };
            _this._changeInternalUserId(userId);
        };
        this.clearUserInfo = function () {
            _this._userInfo = {};
            _this._changeInternalUserId(null);
        };
        this.sendIdentifyEvent = function (userIdType, userId, callback) {
            validateIdentifyEvent(userIdType, userId);
            _this._userInfo = {
                userIdType: userIdType,
                userId: userId,
            };
            _this._analytics.identify(userId, { userIdType: userIdType }, _this._context, callback);
        };
        /**
         * @deprecated
         * please use {@link sendScreenEvent instead)
         */
        this.sendPageEvent = function (name, callback) {
            _this.sendScreenEvent(name, callback);
        };
        /**
         * send screen event
         * @param event The event / For retrocompatibility event name is still supported here.
         * @param callback
         * @param attributes. Deprecated, will get ignored if using an event object as first param.
         */
        this.sendScreenEvent = function (event, callback, attributes) {
            var screenName;
            var screenAttributes;
            var screenContainers;
            var screenTags;
            if (typeof event === 'object') {
                /* This is for retrocompatibility */
                screenName = event.name;
                screenAttributes = event.attributes;
                screenContainers = event.containers;
                screenTags = event.tags;
            }
            else {
                screenName = event;
                screenAttributes = attributes;
            }
            validateScreenEvent(screenName);
            validateContainers(screenContainers);
            var builtEvent = buildScreenEvent(_this._productInfo, _this._tenantInfo, _this._userInfo, screenAttributes, event.nonPrivacySafeAttributes, screenTags, _this._tabTracking.getCurrentTabId(), _this._sessionTracking.getCurrentSessionId(), _this.task.getAllTaskSessions(), _this._orgInfo, screenContainers);
            _this._setLastScreenEvent(__assign({ name: screenName }, builtEvent));
            _this._analytics.page(screenName, builtEvent, _this._context, wrapCallback(callback, builtEvent));
        };
        this.sendTrackEvent = function (event, callback) {
            validateTrackEvent(event);
            var builtEvent = buildActionEvent(_this._productInfo, _this._tenantInfo, _this._userInfo, event, eventType.TRACK, _this._tabTracking.getCurrentTabId(), _this._sessionTracking.getCurrentSessionId(), _this.task.getAllTaskSessions(), _this._orgInfo);
            _this._analytics.track(buildActionName(event), builtEvent, _this._context, wrapCallback(callback, builtEvent));
        };
        this.sendUIEvent = function (event, callback) {
            validateUIEvent(event);
            var builtEvent = buildActionEvent(_this._productInfo, _this._tenantInfo, _this._userInfo, event, eventType.UI, _this._tabTracking.getCurrentTabId(), _this._sessionTracking.getCurrentSessionId(), _this.task.getAllTaskSessions(), _this._orgInfo);
            _this._analytics.track(buildActionName(event), builtEvent, _this._context, wrapCallback(callback, builtEvent));
        };
        this.sendOperationalEvent = function (event, callback) {
            validateOperationalEvent(event);
            var builtEvent = buildActionEvent(_this._productInfo, _this._tenantInfo, _this._userInfo, event, eventType.OPERATIONAL, _this._tabTracking.getCurrentTabId(), _this._sessionTracking.getCurrentSessionId(), _this.task.getAllTaskSessions(), _this._orgInfo);
            _this._analytics.track(buildActionName(event), builtEvent, _this._context, wrapCallback(callback, builtEvent));
        };
        this.startUIViewedEvent = function (callback) {
            _this.stopUIViewedEvent();
            _this._uiViewedEvent = new UIViewedEvent(_this._productInfo, function () { return ({
                embeddedProduct: _this._productInfo.embeddedProduct(),
                subproduct: _this._productInfo.subproduct(),
                tenantIdType: _this._tenantInfo.tenantIdType,
                tenantId: _this._tenantInfo.tenantId,
                userId: _this._userInfo.userId,
                lastScreenEvent: _this._getLastScreenEvent(),
            }); }, function (event) { return _this.sendUIEvent(event, callback); });
            _this._uiViewedEvent.start();
        };
        this.stopUIViewedEvent = function () {
            if (_this._uiViewedEvent) {
                _this._uiViewedEvent.stop();
                _this._uiViewedEvent = null;
            }
        };
        this.resetUIViewedTimers = function () {
            if (_this._uiViewedEvent) {
                _this._uiViewedEvent.resetTimers();
            }
        };
        this.startApdexEvent = function (apdexEvent) {
            _this._apdexEvent.start(apdexEvent);
        };
        this.getApdexStart = function (apdexEvent) { return _this._apdexEvent.getStart(apdexEvent); };
        this.stopApdexEvent = function (apdexEvent, callback) {
            _this._apdexEvent.stop(apdexEvent, callback);
        };
        this.onEvent = function (analyticsId, analyticsData) {
            if (!analyticsData) {
                throw new Error('Missing analyticsData');
            }
            if (!analyticsData.eventType) {
                throw new Error('Missing analyticsData.eventType');
            }
            if (!isType(eventType, analyticsData.eventType)) {
                throw new Error("Invalid analyticsData.eventType '" + analyticsData.eventType + "', " +
                    ("must be an eventType: [" + objectValues(eventType) + "]"));
            }
            if (analyticsData.eventType === eventType.TRACK) {
                _this.sendTrackEvent(analyticsData);
            }
            else if (analyticsData.eventType === eventType.UI) {
                _this.sendUIEvent(analyticsData);
            }
            else if (analyticsData.eventType === eventType.OPERATIONAL) {
                _this.sendOperationalEvent(analyticsData);
            }
        };
        if (!productInfo) {
            throw new Error('Missing productInfo');
        }
        if (!productInfo.env) {
            throw new Error('Missing productInfo.env');
        }
        if (!productInfo.product) {
            throw new Error('Missing productInfo.product');
        }
        if (!isType(envType, productInfo.env)) {
            throw new Error("Invalid productInfo.env '" + productInfo.env + "', " +
                ("must be an envType: [" + objectValues(envType) + "]"));
        }
        if (!productInfo.origin) {
            productInfo.origin = originType.WEB;
        }
        else if (!isType(originType, productInfo.origin)) {
            throw new Error("Invalid productInfo.origin '" + productInfo.origin + "', " +
                ("must be an originType: [" + objectValues(originType) + "]"));
        }
        if (!productInfo.platform) {
            productInfo.platform =
                productInfo.origin === originType.WEB ? platformType.WEB : platformType.DESKTOP;
        }
        else {
            validatePlatform(productInfo);
        }
        productInfo.embeddedProduct = this._createEmbeddedProductGetter(productInfo.embeddedProduct);
        productInfo.subproduct = this._createSubproductGetter(productInfo.subproduct);
        this._productInfo = __assign({}, productInfo);
        this._tenantInfo = {};
        this._orgInfo = {};
        this._userInfo = {};
        this._context = buildContext(this._productInfo);
        this._safeSessionStorage = new SafeSessionStorage();
        var analytics = new Analytics();
        var useStargate = this._useStargate(settings.useStargate);
        var maxRetryAttempts = settings.maxRetryAttempts || 4;
        var minRetryDelay = settings.minRetryDelay || 1000;
        analytics.use(BeforeSendIntegration);
        analytics.use(SegmentIO);
        analytics.init({
            BeforeSend: {},
            'Segment.io': {
                apiKey: settings.apiKey || '',
                apiHost: settings.apiHost || this._selectHost({ useStargate: useStargate, env: productInfo.env }),
                retryQueue: true,
                retryQueuePrefix: "awc-" + productInfo.env,
                addBundledMetadata: true,
                unbundledIntegrations: ['Amplitude'],
                retryQueueOptions: {
                    maxRetryDelay: 60000,
                    minRetryDelay: minRetryDelay,
                    backoffFactor: 2,
                    maxAttempts: maxRetryAttempts,
                    maxItems: 100,
                },
            },
        }, {
            user: {
                // Stop the userId from persisting even after the user has logged out
                persist: false,
                // Stop the userId from being loaded from cookies set by other Segment clients
                cookie: {},
                // Stop the userId from being loaded from localStorage set by other Segment clients
                localStorage: {},
                localStorageFallbackDisabled: true,
            },
        });
        this._analytics = analytics;
        this._pageVisibility = new PageVisibility();
        this._tabTracking = new TabTracking();
        this._sessionTracking = new SessionTracking({
            sessionExpiryTime: settings.sessionExpiryTime,
        });
        this.task = new TaskSessionStore();
        this.originTracing = new OriginTracing();
        // Init Apdex
        this._apdexEvent = new ApdexEvent(this.sendOperationalEvent, this._pageVisibility);
        this._historyReplaceFn = typeof settings.historyReplaceFn === 'function'
            ? settings.historyReplaceFn
            : defaultHistoryReplaceFn;
    }
    return AnalyticsWebClient;
}());
export default AnalyticsWebClient;

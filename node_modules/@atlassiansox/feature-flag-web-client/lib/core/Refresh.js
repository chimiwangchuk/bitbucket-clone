"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var fast_json_stable_stringify_1 = tslib_1.__importDefault(require("fast-json-stable-stringify"));
var types_1 = require("./types");
var fetcher_1 = tslib_1.__importDefault(require("../fetcher"));
var types_2 = require("../fetcher/types");
var MetadataManager_1 = tslib_1.__importDefault(require("./MetadataManager"));
var errors_1 = require("../fetcher/errors");
var util_1 = require("./util");
exports.SCHEDULER_OPTIONS_DEFAULT = {
    minWaitInterval: 300000,
    maxWaitInterval: 1200000,
    backOffFactor: 2,
    backOffJitter: 0.1,
    interval: 300000,
    maxInstantRetryTimes: 0,
};
exports.NO_CACHE_RETRY_OPTIONS_DEFAULT = tslib_1.__assign(tslib_1.__assign({}, exports.SCHEDULER_OPTIONS_DEFAULT), { minWaitInterval: 500, interval: 500, maxInstantRetryTimes: 1 });
var Refresh = /** @class */ (function () {
    function Refresh(apiKey, env, user, onFeatureFlagUpdate, pollingConfig, version, lastUpdateTimestamp, onError, noCachePollingConfig) {
        if (lastUpdateTimestamp === void 0) { lastUpdateTimestamp = 0; }
        if (onError === void 0) { onError = function () { }; }
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        this.failureCount = 0;
        this.user = user;
        this.onFeatureFlagUpdate = onFeatureFlagUpdate;
        this.version = version;
        this.lastUpdateTimestamp = lastUpdateTimestamp;
        this.pollingConfig = {
            minWaitInterval: ((_a = pollingConfig) === null || _a === void 0 ? void 0 : _a.minWaitInterval) || exports.SCHEDULER_OPTIONS_DEFAULT.minWaitInterval,
            maxWaitInterval: ((_b = pollingConfig) === null || _b === void 0 ? void 0 : _b.maxWaitInterval) || exports.SCHEDULER_OPTIONS_DEFAULT.maxWaitInterval,
            backOffFactor: ((_c = pollingConfig) === null || _c === void 0 ? void 0 : _c.backOffFactor) || exports.SCHEDULER_OPTIONS_DEFAULT.backOffFactor,
            backOffJitter: ((_d = pollingConfig) === null || _d === void 0 ? void 0 : _d.backOffJitter) !== undefined
                ? pollingConfig.backOffJitter
                : exports.SCHEDULER_OPTIONS_DEFAULT.backOffJitter,
            interval: ((_e = pollingConfig) === null || _e === void 0 ? void 0 : _e.interval) || exports.SCHEDULER_OPTIONS_DEFAULT.interval,
            maxInstantRetryTimes: 0,
        };
        this.noCachePollingConfig = {
            minWaitInterval: ((_f = noCachePollingConfig) === null || _f === void 0 ? void 0 : _f.minWaitInterval) || exports.NO_CACHE_RETRY_OPTIONS_DEFAULT.minWaitInterval,
            maxWaitInterval: ((_g = noCachePollingConfig) === null || _g === void 0 ? void 0 : _g.maxWaitInterval) || exports.NO_CACHE_RETRY_OPTIONS_DEFAULT.maxWaitInterval,
            backOffFactor: ((_h = noCachePollingConfig) === null || _h === void 0 ? void 0 : _h.backOffFactor) || exports.NO_CACHE_RETRY_OPTIONS_DEFAULT.backOffFactor,
            backOffJitter: ((_j = noCachePollingConfig) === null || _j === void 0 ? void 0 : _j.backOffJitter) !== undefined
                ? noCachePollingConfig.backOffJitter
                : exports.NO_CACHE_RETRY_OPTIONS_DEFAULT.backOffJitter,
            interval: ((_k = noCachePollingConfig) === null || _k === void 0 ? void 0 : _k.interval) || exports.NO_CACHE_RETRY_OPTIONS_DEFAULT.interval,
            maxInstantRetryTimes: ((_l = noCachePollingConfig) === null || _l === void 0 ? void 0 : _l.maxInstantRetryTimes) !== undefined
                ? noCachePollingConfig.maxInstantRetryTimes
                : exports.NO_CACHE_RETRY_OPTIONS_DEFAULT.maxInstantRetryTimes,
        };
        this.onError = onError;
        this.fetcher = new fetcher_1.default(apiKey, env);
        this.metadataManager = new MetadataManager_1.default(this.pollingConfig);
        this.status = types_1.RefreshStatus.INITIALISED;
        this.updateMetadataOnInitialisation();
    }
    // start refresh by fetchAndReschedule
    Refresh.prototype.start = function () {
        this.stop();
        this.fetchAndReschedule();
    };
    // cancel pending schedule
    Refresh.prototype.stop = function () {
        if (this.timerId) {
            window.clearTimeout(this.timerId);
            this.timerId = undefined;
        }
    };
    // update user, with optional version and timestamp
    Refresh.prototype.updateUserContext = function (user, version, lastUpdateTimestamp) {
        if (lastUpdateTimestamp === void 0) { lastUpdateTimestamp = 0; }
        this.user = user;
        this.version = version;
        this.lastUpdateTimestamp = lastUpdateTimestamp;
        this.failureCount = 0;
        this.updateMetadataOnUserChange();
    };
    // update version and timestamp
    Refresh.prototype.setVersionAndTimestamp = function (version, lastUpdateTimestamp) {
        this.version = version;
        this.lastUpdateTimestamp = lastUpdateTimestamp;
    };
    Refresh.prototype.getStatus = function () {
        return this.status;
    };
    // schedule a fetchAndReschedule
    Refresh.prototype.schedule = function () {
        var _this = this;
        this.timerId = window.setTimeout(function () {
            _this.fetchAndReschedule();
        }, this.calculateInterval());
    };
    // conditional fetch ffs via fetcher, and schedule another fetchAndReschedule unless we have 400/401 from ffs
    Refresh.prototype.fetchAndReschedule = function () {
        var _this = this;
        var fetchedUser = fast_json_stable_stringify_1.default(this.user);
        if (this.isFetchRequired()) {
            this.fetcher
                .fetchFeatureFlags(this.user, this.metadataManager.get(), this.version)
                .then(function (resp) {
                if (fetchedUser === fast_json_stable_stringify_1.default(_this.user)) {
                    _this.failureCount = 0;
                    _this.onFeatureFlagUpdate(util_1.flagResponseToFlagUpdate(resp));
                    _this.schedule();
                    _this.status = types_1.RefreshStatus.SUCCESS;
                }
                _this.updateMetadataOnRequestComplete();
            })
                .catch(function (err) {
                if (err instanceof errors_1.ResponseError && (err.status === 400 || err.status === 401)) {
                    // no retry needed
                    var message = "Feature flag service returned " + err.status + ", \"" + err.body + "\". This request will not be retried until the user data has been changed.";
                    console.error(message);
                    _this.onError();
                }
                else {
                    _this.failureCount += 1;
                    // Being called after the second attempt as a user with no cache will
                    // retry instantly if the first request fails.
                    if (_this.failureCount > 1) {
                        _this.onError();
                    }
                    _this.schedule();
                }
                _this.status = types_1.RefreshStatus.ERROR;
                _this.updateMetadataOnRequestComplete();
            });
        }
        else {
            this.schedule();
            this.status = types_1.RefreshStatus.SUCCESS;
        }
    };
    Refresh.prototype.isFetchRequired = function () {
        return Date.now() - this.getPollingConfig().interval >= this.lastUpdateTimestamp;
    };
    Refresh.prototype.updateMetadataOnUserChange = function () {
        // if fetch required, it will be a INITIALIZATION fetch, otherwise it's going to be a delay POLLING fetch
        this.metadataManager.updateClientCauseReason(this.isFetchRequired() ? types_2.ClientCauseReason.INITIALIZATION : types_2.ClientCauseReason.POLLING);
        // always set user state to SWITCHED user for next fetch
        this.metadataManager.updateClientUserState(types_2.ClientUserState.SWITCHED);
    };
    Refresh.prototype.updateMetadataOnInitialisation = function () {
        // if fetch required, it will be a INITIALIZATION fetch, otherwise it's going to be a delay POLLING fetch
        this.metadataManager.updateClientCauseReason(this.isFetchRequired() ? types_2.ClientCauseReason.INITIALIZATION : types_2.ClientCauseReason.POLLING);
        // no cache (lastUpdateTimestamp === 0) means we fetch for NEW user, if we have cache we fetch for SAME user
        this.metadataManager.updateClientUserState(this.lastUpdateTimestamp === 0 ? types_2.ClientUserState.NEW : types_2.ClientUserState.SAME);
    };
    Refresh.prototype.updateMetadataOnRequestComplete = function () {
        if (this.failureCount) {
            // when current fetch failed, next fetch will be a RETRY
            // the calling user has not changed
            this.metadataManager.updateClientCauseReason(types_2.ClientCauseReason.RETRY);
        }
        else {
            // when current fetch success, next fetch will be a POLLING
            // and the calling user will be SAME user
            this.metadataManager.updateClientCauseReason(types_2.ClientCauseReason.POLLING);
            this.metadataManager.updateClientUserState(types_2.ClientUserState.SAME);
        }
    };
    // calculate wait interval based on failure count
    Refresh.prototype.calculateInterval = function () {
        var _a = this.getPollingConfig(), interval = _a.interval, minWaitInterval = _a.minWaitInterval, maxWaitInterval = _a.maxWaitInterval, backOffFactor = _a.backOffFactor, backOffJitter = _a.backOffJitter, maxInstantRetryTimes = _a.maxInstantRetryTimes;
        if (maxInstantRetryTimes !== undefined && maxInstantRetryTimes !== 0 && maxInstantRetryTimes >= this.failureCount) {
            return 0;
        }
        if (this.failureCount === 0) {
            return interval;
        }
        var ms = minWaitInterval * Math.pow(backOffFactor, (this.failureCount - 1));
        if (backOffJitter) {
            var rand = Math.random();
            var deviation = Math.floor(rand * backOffJitter * ms);
            if (Math.floor(rand * 10) < 5) {
                ms -= deviation;
            }
            else {
                ms += deviation;
            }
        }
        return Number(Math.min(ms, maxWaitInterval));
    };
    Refresh.prototype.getPollingConfig = function () {
        if (this.version === undefined && this.lastUpdateTimestamp === 0) {
            return this.noCachePollingConfig;
        }
        return this.pollingConfig;
    };
    return Refresh;
}());
exports.default = Refresh;

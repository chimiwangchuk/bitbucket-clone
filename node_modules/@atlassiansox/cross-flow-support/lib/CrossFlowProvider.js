import * as tslib_1 from "tslib";
import React, { Suspense, useCallback, useMemo, useState, useRef, } from 'react';
import { BaseCrossFlowApiProvider } from '@atlassiansox/cross-flow-api-internals';
import { analyticsWrapper } from './analytics-helpers/analyticsHelpers';
import { transformEvent } from './analytics-helpers/analyticsTransformers';
import { ErrorBoundary } from './errorBoundary';
import { enrichWithPackageDetails } from './enrichWithPackageDetails';
import { OPERATIONAL_EVENT_TYPE, source, uiInitialized, crossFlowActionSubject, openInvoked, } from './constants';
var IntegrationView = React.lazy(function () {
    return import(
    /* webpackChunkName: "@atlassiansox/cross-flow-support-deferred" */
    /* webpackPrefetch: true */
    './view');
});
/**
 * Generic Cross Flow API provider.
 *
 * Initializes Cross Flow support in product.
 * Renders Cross Flow overlay when requested via context API.
 */
export var createCrossFlowProvider = function (IntegrationViewComponent) { return function (props) {
    var children = props.children, analyticsClient = props.analyticsClient, originProduct = props.originProduct, baseProviderProps = tslib_1.__rest(props, ["children", "analyticsClient", "originProduct"]);
    var onCloseResolver = useRef();
    var _a = tslib_1.__read(useState(false), 2), firstHandshakeReceived = _a[0], setFirstHandshakeReceived = _a[1];
    var fireEvent = useMemo(function () { return analyticsWrapper(analyticsClient); }, [analyticsClient]);
    var onAnalyticsEvent = useCallback(function (payload) {
        var gasV3Event = transformEvent(payload);
        if (gasV3Event) {
            fireEvent(enrichWithPackageDetails(gasV3Event));
        }
    }, [fireEvent]);
    var onHandShake = useCallback(function (appName) {
        if (!firstHandshakeReceived) {
            onAnalyticsEvent({
                payload: {
                    eventType: OPERATIONAL_EVENT_TYPE,
                    action: uiInitialized,
                    actionSubject: crossFlowActionSubject,
                    appName: appName,
                },
                context: [{ source: source }],
            });
            setFirstHandshakeReceived(true);
        }
    }, [firstHandshakeReceived, onAnalyticsEvent]);
    var _b = tslib_1.__read(useState(), 2), requestOptions = _b[0], setRequestOptions = _b[1];
    var onOpen = useCallback(function (options) {
        /**
         * Reset first handshake state to ensure 1:1 value of open invoked and handshake received
         * Caveat that if open api is invoked while cross flow support UI is already mounted there will be mismatch of openInvoked events to uiInitialized events
         */
        setFirstHandshakeReceived(false);
        setRequestOptions(options);
        onAnalyticsEvent({
            payload: {
                eventType: OPERATIONAL_EVENT_TYPE,
                action: openInvoked,
                actionSubject: crossFlowActionSubject,
            },
            context: [{ source: source }],
        });
        return new Promise(function (resolve) {
            onCloseResolver.current = resolve;
        });
    }, [onAnalyticsEvent]);
    var onClose = useCallback(function () {
        setFirstHandshakeReceived(false);
        setRequestOptions(undefined);
        onCloseResolver.current && onCloseResolver.current();
    }, []);
    return (React.createElement(BaseCrossFlowApiProvider, { onOpen: onOpen },
        children,
        requestOptions && (React.createElement(ErrorBoundary, { onAnalyticsEvent: onAnalyticsEvent },
            React.createElement(Suspense, { fallback: null },
                React.createElement(IntegrationViewComponent, tslib_1.__assign({}, baseProviderProps, { onAnalyticsEvent: onAnalyticsEvent, sourceContext: requestOptions.sourceContext, sourceComponent: requestOptions.sourceComponent, targetProduct: requestOptions.targetProduct, onClose: onClose, originProduct: originProduct, onHandShake: onHandShake })))))));
}; };
export var CrossFlowProvider = createCrossFlowProvider(IntegrationView);
//# sourceMappingURL=CrossFlowProvider.js.map
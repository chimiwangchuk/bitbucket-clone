import { FlagAction } from '../FlagCreationOptions';
import ValidationUtil from '../../../definitions/validation/ValidationUtil';
/**
 * This class validates an instance of FlagProvider. This is intended to be used by consumers of this library in
 * their tests to validate their implementations. Knowing products have incorporated this into their test suite will
 * allow breaking changes to be introduced in the library.
 */
var FlagProviderValidator = /** @class */ (function () {
    function FlagProviderValidator() {
    }
    FlagProviderValidator.validate = function (flagProvider) {
        ValidationUtil.checkFunctionExists('flagProvider', flagProvider, 'create');
        ValidationUtil.checkFunctionExists('flagProvider', flagProvider, 'isFlagOpen');
        FlagProviderValidator.validateFlagCreationAndDeletions(flagProvider, 'manual');
        FlagProviderValidator.validateFlagCreationAndDeletions(flagProvider, 'auto');
        FlagProviderValidator.validateFlagCreationAndDeletions(flagProvider, 'never');
    };
    FlagProviderValidator.validateFlagCreationAndDeletions = function (flagProvider, closeFlagOption) {
        var flagActions = [];
        FlagProviderValidator.validateFlagCreationAndDeletion(flagProvider, closeFlagOption, flagActions, false);
        var flagAction = new FlagAction();
        flagAction.actionKey = 'some-action';
        flagAction.actionText = 'Some Action';
        flagAction.executeAction = function () { console.log('Action clicked'); };
        flagActions.push(flagAction);
        FlagProviderValidator.validateFlagCreationAndDeletion(flagProvider, closeFlagOption, flagActions, false);
        var flagActionMissingExecuteAction = new FlagAction();
        flagActionMissingExecuteAction.actionKey = 'some-action';
        flagActionMissingExecuteAction.actionText = 'Some Action';
        flagActions[0] = flagActionMissingExecuteAction;
        FlagProviderValidator.validateFlagCreationAndDeletion(flagProvider, closeFlagOption, flagActions, true);
    };
    FlagProviderValidator.validateFlagCreationAndDeletion = function (flagProvider, closeFlagOption, flagActions, expectValidationError) {
        var flagIdsToFlags = new Map();
        var flagId = 'flag-' + (new Date()).getMilliseconds();
        var flagOptions = {
            id: flagId,
            title: 'My Flag',
            body: 'My flag content',
            type: 'success',
            close: closeFlagOption,
            onClose: function (flagId) {
                flagIdsToFlags.delete(flagId);
            },
            actions: flagActions
        };
        try {
            var flag = flagProvider.create(flagOptions);
            if (expectValidationError) {
                throw new Error('Expected a validation error, but did not get one.');
            }
            flagIdsToFlags.set(flag.id, flag);
            ValidationUtil.checkExists('flag', flag);
            ValidationUtil.checkFunctionExists('flag', flag, 'close');
            if (closeFlagOption !== 'auto') {
                var flagOpen = flagProvider.isFlagOpen(flag.id);
                if (!flagOpen) {
                    throw new Error("Expected flag to exist.");
                }
            }
            flag.close();
            if (flagIdsToFlags.size) {
                throw new Error('It looks like the provider did not synchronously call back the onClose method.');
            }
        }
        catch (exception) {
            if (expectValidationError) {
                // OK
            }
            else {
                throw new Error('Did not expect a validation error, but got one.');
            }
        }
    };
    return FlagProviderValidator;
}());
export { FlagProviderValidator };
//# sourceMappingURL=FlagProviderValidator.js.map
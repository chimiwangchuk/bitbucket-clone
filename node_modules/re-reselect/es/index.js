import { createSelector } from 'reselect';

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var FlatCacheObject = function () {
  function FlatCacheObject() {
    classCallCheck(this, FlatCacheObject);

    this._cache = {};
  }

  FlatCacheObject.prototype.set = function set$$1(key, selectorFn) {
    this._cache[key] = selectorFn;
  };

  FlatCacheObject.prototype.get = function get$$1(key) {
    return this._cache[key];
  };

  FlatCacheObject.prototype.remove = function remove(key) {
    delete this._cache[key];
  };

  FlatCacheObject.prototype.clear = function clear() {
    this._cache = {};
  };

  return FlatCacheObject;
}();

var FifoCacheObject = function () {
  function FifoCacheObject() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        cacheSize = _ref.cacheSize;

    classCallCheck(this, FifoCacheObject);

    if (cacheSize === undefined) {
      throw new Error('Missing the required property `cacheSize`.');
    }
    if (!Number.isInteger(cacheSize) || cacheSize <= 0) {
      throw new Error('The `cacheSize` property must be a positive integer value.');
    }
    this._cache = {};
    this._cacheOrdering = [];
    this._cacheSize = cacheSize;
  }

  FifoCacheObject.prototype.set = function set$$1(key, selectorFn) {
    this._cache[key] = selectorFn;
    this._cacheOrdering.push(key);

    if (this._cacheOrdering.length > this._cacheSize) {
      var earliest = this._cacheOrdering[0];
      this.remove(earliest);
    }
  };

  FifoCacheObject.prototype.get = function get$$1(key) {
    return this._cache[key];
  };

  FifoCacheObject.prototype.remove = function remove(key) {
    var index = this._cacheOrdering.indexOf(key);

    if (index > -1) {
      this._cacheOrdering.splice(index, 1);
    }
    delete this._cache[key];
  };

  FifoCacheObject.prototype.clear = function clear() {
    this._cache = {};
    this._cacheOrdering = [];
  };

  return FifoCacheObject;
}();

var LruCacheObject = function () {
  function LruCacheObject() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        cacheSize = _ref.cacheSize;

    classCallCheck(this, LruCacheObject);

    if (cacheSize === undefined) {
      throw new Error('Missing the required property `cacheSize`.');
    }
    if (!Number.isInteger(cacheSize) || cacheSize <= 0) {
      throw new Error('The `cacheSize` property must be a positive integer value.');
    }
    this._cache = {};
    this._cacheOrdering = [];
    this._cacheSize = cacheSize;
  }

  LruCacheObject.prototype.set = function set$$1(key, selectorFn) {
    this._cache[key] = selectorFn;
    this._registerCacheHit(key);

    if (this._cacheOrdering.length > this._cacheSize) {
      var earliest = this._cacheOrdering[0];
      this.remove(earliest);
    }
  };

  LruCacheObject.prototype.get = function get$$1(key) {
    this._registerCacheHit(key);
    return this._cache[key];
  };

  LruCacheObject.prototype.remove = function remove(key) {
    this._deleteCacheHit(key);
    delete this._cache[key];
  };

  LruCacheObject.prototype.clear = function clear() {
    this._cache = {};
    this._cacheOrdering = [];
  };

  LruCacheObject.prototype._registerCacheHit = function _registerCacheHit(key) {
    this._deleteCacheHit(key);
    this._cacheOrdering.push(key);
  };

  LruCacheObject.prototype._deleteCacheHit = function _deleteCacheHit(key) {
    var index = this._cacheOrdering.indexOf(key);
    if (index > -1) {
      this._cacheOrdering.splice(index, 1);
    }
  };

  return LruCacheObject;
}();

function createCachedSelector() {
  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  var defaultCacheCreator = FlatCacheObject;

  return function (resolver) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var cache = void 0;
    var selectorCreator = void 0;

    // Allow "options" to be provided as a "selectorCreator" for backward compatibility
    // @TODO Remove "options" as a function in next breaking release
    if (typeof options === 'function') {
      console.warn('[re-reselect] Deprecation warning: "selectorCreator" argument is discouraged and will be removed in the upcoming major release. Please use "options.selectorCreator" instead.');
      cache = new defaultCacheCreator();
      selectorCreator = options;
    } else {
      cache = options.cacheObject || new defaultCacheCreator();
      selectorCreator = options.selectorCreator || createSelector;
    }

    var selector = function selector() {
      // Application receives this function
      var cacheKey = resolver.apply(undefined, arguments);

      if (typeof cacheKey === 'string' || typeof cacheKey === 'number') {
        var cacheResponse = cache.get(cacheKey);

        if (cacheResponse === undefined) {
          cacheResponse = selectorCreator.apply(undefined, funcs);
          cache.set(cacheKey, cacheResponse);
        }

        return cacheResponse.apply(undefined, arguments);
      }
      return undefined;
    };

    // Further selector methods
    selector.getMatchingSelector = function () {
      var cacheKey = resolver.apply(undefined, arguments);
      // @NOTE It might update cache hit count in LRU-like caches
      return cache.get(cacheKey);
    };

    selector.removeMatchingSelector = function () {
      var cacheKey = resolver.apply(undefined, arguments);
      cache.remove(cacheKey);
    };

    selector.clearCache = function () {
      cache.clear();
    };

    selector.resultFunc = funcs[funcs.length - 1];

    return selector;
  };
}

export { FlatCacheObject, FifoCacheObject, LruCacheObject };
export default createCachedSelector;
//# sourceMappingURL=index.js.map

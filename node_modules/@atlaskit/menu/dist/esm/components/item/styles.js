import { __assign } from "tslib";
import { gridSize as gridSizeFn, fontSize, borderRadius, skeletonShimmer, } from '@atlaskit/theme/constants';
import { N800, N0, B100, N200, N20, N30, subtleHeading, subtleText, skeleton as skeletonColor, } from '@atlaskit/theme/colors';
import { headingSizes } from '@atlaskit/theme/typography';
import { keyframes } from '@emotion/core';
var gridSize = gridSizeFn();
var itemElemSpacing = gridSize * 1.5;
var itemElemSize = gridSize * 3;
var itemTopBottomPadding = gridSize;
var itemSidePadding = gridSize * 2.5;
var itemDescriptionSpacing = gridSize * 0.375;
var itemMinHeight = gridSize * 5;
var itemContentMinHeight = itemMinHeight - itemTopBottomPadding * 2;
var itemHeadingTopMargin = gridSize * 2.5;
var itemHeadingBottomMargin = gridSize * 0.75;
var itemHeadingContentHeight = headingSizes.h100.lineHeight;
var itemHeadingFontSize = headingSizes.h100.size;
var skeletonContentHeight = gridSize * 1.75;
// Skeleton content is slightly shorter than the real content.
// Because of that we slightly increase the top margin to offset this so the
// containing size both real and skeleton always equal approx 30px.
var skeletonHeadingTopMargin = itemHeadingTopMargin + (itemHeadingContentHeight - skeletonContentHeight);
var buttonOverrides = {
    backgroundColor: 'transparent',
    border: 0,
    outline: 0,
    margin: 0,
    width: '100%',
};
var anchorOverrides = {};
var customItemOverrides = {
    color: 'currentColor',
};
var disabledStyles = {
    cursor: 'not-allowed',
    '&, &:hover, &:focus, &:active': {
        backgroundColor: N0,
        color: N200,
    },
};
var selectedStyles = {
    backgroundColor: N20,
    textDecoration: 'none',
};
var shimmer = skeletonShimmer();
var shimmerKeyframes = keyframes(shimmer.keyframes);
var baseItemCSS = function (isDisabled, isSelected) { return (__assign(__assign({ padding: itemTopBottomPadding + "px " + itemSidePadding + "px", cursor: 'pointer', fontSize: fontSize(), display: 'block', boxSizing: 'border-box', color: N800, 
    // :not(style) is ensures that it works with streaming SSR because
    // Emotion adds style tags in between elements.
    '&:first-child:not(style)': {
        marginTop: gridSize * 0.75,
    }, '&:last-child:not(style)': {
        marginBottom: gridSize * 0.75,
    }, '&:hover': {
        color: N800,
        backgroundColor: N20,
        textDecoration: 'none',
    }, '&:focus': {
        boxShadow: B100 + " 0 0 0 2px inset",
        outline: 'none',
    }, '&:active': {
        boxShadow: 'none',
        color: N800,
        backgroundColor: N30,
    }, '::-moz-focus-inner': {
        border: 0,
    } }, (isSelected && selectedStyles)), (isDisabled && disabledStyles))); };
export var buttonItemCSS = function (isDisabled, isSelected) { return (__assign(__assign({}, buttonOverrides), baseItemCSS(isDisabled, isSelected))); };
export var itemCSS = baseItemCSS;
export var contentCSS = {
    flexGrow: 1,
    textAlign: 'left',
    overflow: 'hidden',
    outline: 'none',
    display: 'flex',
    flexDirection: 'column',
    lineHeight: "" + (gridSize * 2) / fontSize(),
};
export var truncateCSS = {
    display: 'block',
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap',
};
export var elemBeforeCSS = {
    display: 'flex',
    flexShrink: 0,
    marginRight: itemElemSpacing,
};
export var elemAfterCSS = {
    display: 'flex',
    flexShrink: 0,
    marginLeft: itemElemSpacing,
};
export var descriptionCSS = __assign(__assign({}, truncateCSS), { color: subtleText(), marginTop: itemDescriptionSpacing, fontSize: headingSizes.h200.size });
export var contentCSSWrapper = {
    display: 'flex',
    minHeight: itemContentMinHeight,
    alignItems: 'center',
};
export var linkItemCSS = function (isDisabled, isSelected) { return (__assign(__assign({}, anchorOverrides), baseItemCSS(isDisabled, isSelected))); };
export var customItemCSS = function (isDisabled, isSelected) { return (__assign(__assign({}, customItemOverrides), baseItemCSS(isDisabled, isSelected))); };
export var itemHeadingCSS = {
    textTransform: 'uppercase',
    fontSize: itemHeadingFontSize,
    lineHeight: itemHeadingContentHeight / itemHeadingFontSize,
    fontWeight: 700,
    color: subtleHeading(),
    marginTop: itemHeadingTopMargin,
    marginBottom: itemHeadingBottomMargin,
    padding: "0 " + itemSidePadding + "px",
};
export var skeletonHeadingItemCSS = function (width, isShimmering) { return (__assign(__assign({}, itemHeadingCSS), { marginTop: skeletonHeadingTopMargin, '&::after': __assign(__assign({ 
        // This renders the skeleton heading "text".
        backgroundColor: skeletonColor() }, (isShimmering && __assign(__assign({}, shimmer.css), { animationName: "" + shimmerKeyframes }))), { height: skeletonContentHeight, width: width || '30%', borderRadius: borderRadius(), display: 'block', content: '""' }) })); };
export var itemSkeletonCSS = function (hasAvatar, hasIcon, width, isShimmering) { return (__assign(__assign(__assign(__assign(__assign({}, itemCSS(false, false)), { pointerEvents: 'none', display: 'flex', alignItems: 'center', minHeight: itemMinHeight }), (!width && {
    '&:nth-child(1n)::after': {
        flexBasis: '70%',
    },
    '&:nth-child(2n)::after': {
        flexBasis: '50%',
    },
    '&:nth-child(3n)::after': {
        flexBasis: '60%',
    },
    '&:nth-child(4n)::after': {
        flexBasis: '90%',
    },
    '&:nth-child(5n)::after': {
        flexBasis: '35%',
    },
    '&:nth-child(6n)::after': {
        flexBasis: '77%',
    },
})), ((hasAvatar || hasIcon) && {
    '&::before': __assign(__assign({ 
        // This will render a skeleton in the "elemBefore" position.
        content: '""', backgroundColor: skeletonColor() }, (isShimmering && __assign(__assign({}, shimmer.css), { animationName: "" + shimmerKeyframes }))), { marginRight: itemElemSpacing, width: itemElemSize, height: itemElemSize, borderRadius: hasAvatar ? '100%' : borderRadius(), flexShrink: 0 }),
})), { '&::after': __assign(__assign({ 
        // This will render the skeleton "text".
        content: '""', backgroundColor: skeletonColor() }, (isShimmering && __assign(__assign({}, shimmer.css), { animationName: "" + shimmerKeyframes }))), { height: skeletonContentHeight, borderRadius: borderRadius(), flexBasis: '100%' || width }) })); };
//# sourceMappingURL=styles.js.map
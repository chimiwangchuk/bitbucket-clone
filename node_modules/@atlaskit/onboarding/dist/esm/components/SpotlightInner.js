import { __assign, __extends } from "tslib";
import React from 'react';
import { layers } from '@atlaskit/theme/constants';
import Portal from '@atlaskit/portal';
import ScrollLock from 'react-scrolllock';
import NodeResovler from 'react-node-resolver';
import scrollIntoView from 'scroll-into-view-if-needed';
import { canUseDOM } from 'exenv';
import { Fade } from './Animation';
import Clone from './Clone';
import SpotlightDialog from './SpotlightDialog';
import { SpotlightTransitionConsumer } from './SpotlightTransition';
import { ElementBox } from '../utils/use-element-box';
var SpotlightInner = /** @class */ (function (_super) {
    __extends(SpotlightInner, _super);
    function SpotlightInner() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            // This is only used when targetReplacement is specified.
            // In this case, we have to render the targetReplacement component,
            // get a dom reference from that component, then render again passing
            // that reference into SpotlightDialog (Popper).
            replacementElement: null,
        };
        _this.isPositionFixed = function (element) {
            return window.getComputedStyle(element).position === 'fixed';
        };
        _this.hasPositionFixedParent = function (element, 
        // We cap this method to be called to 1000 times to prevent flooding the stack.
        // In reality this only seems to be a problem in CI.
        _maxTries) {
            if (_maxTries === void 0) { _maxTries = 1000; }
            var offsetParent = element.offsetParent;
            if (!offsetParent || _maxTries === 0) {
                return false;
            }
            if (_this.isPositionFixed(offsetParent)) {
                return true;
            }
            return _this.hasPositionFixedParent(offsetParent, _maxTries - 1);
        };
        _this.getTargetNodeStyle = function (box) {
            if (!canUseDOM) {
                return {};
            }
            var targetNode = _this.props.targetNode;
            if (_this.isPositionFixed(targetNode) ||
                _this.hasPositionFixedParent(targetNode)) {
                return __assign(__assign({}, box), { 
                    // fixed position holds the target in place if overflow/scroll is necessary
                    position: 'fixed' });
            }
            return {
                height: box.height,
                left: box.left + window.pageXOffset,
                top: box.top + window.pageYOffset,
                width: box.width,
                position: 'absolute',
            };
        };
        return _this;
    }
    SpotlightInner.prototype.componentDidUpdate = function (prevProps) {
        if (prevProps.targetNode !== this.props.targetNode) {
            scrollIntoView(this.props.targetNode, {
                scrollMode: 'if-needed',
            });
        }
    };
    SpotlightInner.prototype.componentDidMount = function () {
        scrollIntoView(this.props.targetNode, {
            scrollMode: 'if-needed',
        });
        this.props.onOpened();
    };
    SpotlightInner.prototype.componentWillUnmount = function () {
        this.props.onClosed();
    };
    SpotlightInner.prototype.render = function () {
        var _this = this;
        var _a = this.props, pulse = _a.pulse, target = _a.target, targetNode = _a.targetNode, targetBgColor = _a.targetBgColor, targetOnClick = _a.targetOnClick, targetRadius = _a.targetRadius, testId = _a.testId, TargetReplacement = _a.targetReplacement;
        var replacementElement = this.state.replacementElement;
        return (React.createElement(SpotlightTransitionConsumer, null, function (_a) {
            var isOpen = _a.isOpen, onExited = _a.onExited;
            return (React.createElement(Portal, { zIndex: layers.spotlight() + 1 },
                TargetReplacement ? (React.createElement(NodeResovler, { innerRef: function (elem) {
                        return _this.setState({ replacementElement: elem });
                    } },
                    React.createElement(ElementBox, { element: targetNode }, function (box) { return (React.createElement(TargetReplacement, __assign({ "data-testid": testId + "--target" }, _this.getTargetNodeStyle(box)))); }))) : (React.createElement(ElementBox, { element: targetNode }, function (box) { return (React.createElement(Clone, { testId: testId + "--target", pulse: pulse, target: target, style: _this.getTargetNodeStyle(box), targetBgColor: targetBgColor, targetNode: targetNode, targetOnClick: targetOnClick, targetRadius: targetRadius })); })),
                TargetReplacement && !replacementElement ? null : (React.createElement(Fade, { in: isOpen, onExited: onExited }, function (animationStyles) { return (React.createElement(SpotlightDialog, { testId: testId + "--dialog", actions: _this.props.actions, actionsBeforeElement: _this.props.actionsBeforeElement, children: _this.props.children, dialogPlacement: _this.props.dialogPlacement, dialogWidth: _this.props.dialogWidth, footer: _this.props.footer, header: _this.props.header, heading: _this.props.heading, image: _this.props.image, targetNode: replacementElement || targetNode, animationStyles: animationStyles })); })),
                React.createElement(ScrollLock, null)));
        }));
    };
    SpotlightInner.defaultProps = {
        dialogWidth: 400,
        pulse: true,
    };
    return SpotlightInner;
}(React.Component));
export default SpotlightInner;
//# sourceMappingURL=SpotlightInner.js.map
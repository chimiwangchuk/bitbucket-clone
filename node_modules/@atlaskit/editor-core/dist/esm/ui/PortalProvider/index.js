import { __extends, __read } from "tslib";
import React from 'react';
import { createPortal, unstable_renderSubtreeIntoContainer, unmountComponentAtNode, } from 'react-dom';
import { EventDispatcher } from '../../event-dispatcher';
import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE, } from '../../plugins/analytics';
var PortalProviderAPI = /** @class */ (function (_super) {
    __extends(PortalProviderAPI, _super);
    function PortalProviderAPI(onAnalyticsEvent) {
        var _this = _super.call(this) || this;
        _this.portals = new Map();
        _this.setContext = function (context) {
            _this.context = context;
        };
        _this.onAnalyticsEvent = onAnalyticsEvent;
        return _this;
    }
    PortalProviderAPI.prototype.render = function (children, container, hasReactContext) {
        if (hasReactContext === void 0) { hasReactContext = false; }
        this.portals.set(container, { children: children, hasReactContext: hasReactContext });
        unstable_renderSubtreeIntoContainer(this.context, children(), container);
    };
    // TODO: until https://product-fabric.atlassian.net/browse/ED-5013
    // we (unfortunately) need to re-render to pass down any updated context.
    // selectively do this for nodeviews that opt-in via `hasReactContext`
    PortalProviderAPI.prototype.forceUpdate = function () {
        var _this = this;
        this.portals.forEach(function (portal, container) {
            if (!portal.hasReactContext) {
                return;
            }
            unstable_renderSubtreeIntoContainer(_this.context, portal.children(), container);
        });
    };
    PortalProviderAPI.prototype.remove = function (container) {
        this.portals.delete(container);
        // There is a race condition that can happen caused by Prosemirror vs React,
        // where Prosemirror removes the container from the DOM before React gets
        // around to removing the child from the container
        // This will throw a NotFoundError: The node to be removed is not a child of this node
        // Both Prosemirror and React remove the elements asynchronously, and in edge
        // cases Prosemirror beats React
        try {
            unmountComponentAtNode(container);
        }
        catch (error) {
            if (this.onAnalyticsEvent) {
                this.onAnalyticsEvent({
                    payload: {
                        action: ACTION.FAILED_TO_UNMOUNT,
                        actionSubject: ACTION_SUBJECT.EDITOR,
                        actionSubjectId: ACTION_SUBJECT_ID.REACT_NODE_VIEW,
                        attributes: {
                            error: error,
                            domNodes: {
                                container: container ? container.className : undefined,
                                child: container.firstElementChild
                                    ? container.firstElementChild.className
                                    : undefined,
                            },
                        },
                        eventType: EVENT_TYPE.OPERATIONAL,
                    },
                });
            }
        }
    };
    return PortalProviderAPI;
}(EventDispatcher));
export { PortalProviderAPI };
var PortalProvider = /** @class */ (function (_super) {
    __extends(PortalProvider, _super);
    function PortalProvider(props) {
        var _this = _super.call(this, props) || this;
        _this.portalProviderAPI = new PortalProviderAPI(props.onAnalyticsEvent);
        return _this;
    }
    PortalProvider.prototype.render = function () {
        return this.props.render(this.portalProviderAPI);
    };
    PortalProvider.prototype.componentDidUpdate = function () {
        this.portalProviderAPI.forceUpdate();
    };
    PortalProvider.displayName = 'PortalProvider';
    return PortalProvider;
}(React.Component));
export { PortalProvider };
var PortalRenderer = /** @class */ (function (_super) {
    __extends(PortalRenderer, _super);
    function PortalRenderer(props) {
        var _this = _super.call(this, props) || this;
        _this.handleUpdate = function (portals) { return _this.setState({ portals: portals }); };
        props.portalProviderAPI.setContext(_this);
        props.portalProviderAPI.on('update', _this.handleUpdate);
        _this.state = { portals: new Map() };
        return _this;
    }
    PortalRenderer.prototype.render = function () {
        var portals = this.state.portals;
        return (React.createElement(React.Fragment, null, Array.from(portals.entries()).map(function (_a) {
            var _b = __read(_a, 2), container = _b[0], children = _b[1];
            return createPortal(children, container);
        })));
    };
    return PortalRenderer;
}(React.Component));
export { PortalRenderer };
//# sourceMappingURL=index.js.map
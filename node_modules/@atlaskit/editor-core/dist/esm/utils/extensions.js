import { __awaiter, __generator } from "tslib";
import React from 'react';
import Loadable from 'react-loadable';
import { combineProviders, getItemsFromModule, resolveImport, } from '@atlaskit/editor-common';
import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE, INPUT_METHOD, } from '../';
import { fireAnalyticsEvent } from '../plugins/analytics';
/**
 * Utils to send analytics event when a extension is inserted using quickInsert
 */
function sendExtensionQuickInsertAnalytics(item, createAnalyticsEvent) {
    if (createAnalyticsEvent) {
        fireAnalyticsEvent(createAnalyticsEvent)({
            payload: {
                action: ACTION.INSERTED,
                actionSubject: ACTION_SUBJECT.DOCUMENT,
                actionSubjectId: ACTION_SUBJECT_ID.EXTENSION,
                attributes: {
                    extensionType: item.extensionType,
                    key: item.key,
                    inputMethod: INPUT_METHOD.QUICK_INSERT,
                },
                eventType: EVENT_TYPE.TRACK,
            },
        });
    }
}
export function extensionProviderToQuickInsertProvider(extensionProvider, editorActions, createAnalyticsEvent) {
    return __awaiter(this, void 0, void 0, function () {
        var extensions;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, extensionProvider.getExtensions()];
                case 1:
                    extensions = _a.sent();
                    return [2 /*return*/, {
                            getItems: function () {
                                var quickInsertItems = getItemsFromModule(extensions, 'quickInsert', function (item) {
                                    var Icon = Loadable({
                                        loader: item.icon,
                                        loading: function () { return null; },
                                    });
                                    return {
                                        title: item.title,
                                        description: item.description,
                                        icon: function () { return React.createElement(Icon, { label: item.title }); },
                                        action: function (insert) {
                                            if (typeof item.node === 'function') {
                                                resolveImport(item.node()).then(function (node) {
                                                    sendExtensionQuickInsertAnalytics(item, createAnalyticsEvent);
                                                    editorActions.replaceSelection(node);
                                                });
                                                return insert('');
                                            }
                                            else {
                                                sendExtensionQuickInsertAnalytics(item, createAnalyticsEvent);
                                                return insert(item.node);
                                            }
                                        },
                                    };
                                });
                                return Promise.all(quickInsertItems);
                            },
                        }];
            }
        });
    });
}
export function combineQuickInsertProviders(quickInsertProviders) {
    return __awaiter(this, void 0, void 0, function () {
        var invokeList;
        return __generator(this, function (_a) {
            invokeList = combineProviders(quickInsertProviders).invokeList;
            return [2 /*return*/, {
                    getItems: function () {
                        return invokeList('getItems');
                    },
                }];
        });
    });
}
//# sourceMappingURL=extensions.js.map
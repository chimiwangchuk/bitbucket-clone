import { Node } from 'prosemirror-model';
import { validator } from '@atlaskit/adf-utils';
import { analyticsService } from '../analytics';
import { sanitizeNodeForPrivacy } from '../utils/filter/privacy-filter';
var FALSE_POSITIVE_MARKS = ['code', 'alignment', 'indentation'];
/**
 * Checks if node is an empty paragraph.
 */
export function isEmptyParagraph(node) {
    return !!node && node.type.name === 'paragraph' && !node.childCount;
}
/**
 * Returns false if node contains only empty inline nodes and hardBreaks.
 */
export function hasVisibleContent(node) {
    var isInlineNodeHasVisibleContent = function (inlineNode) {
        return inlineNode.isText
            ? !!inlineNode.textContent.trim()
            : inlineNode.type.name !== 'hardBreak';
    };
    if (node.isInline) {
        return isInlineNodeHasVisibleContent(node);
    }
    else if (node.isBlock && (node.isLeaf || node.isAtom)) {
        return true;
    }
    else if (!node.childCount) {
        return false;
    }
    for (var index = 0; index < node.childCount; index++) {
        var child = node.child(index);
        if (hasVisibleContent(child)) {
            return true;
        }
    }
    return false;
}
/**
 * Checks if a node has any content. Ignores node that only contain empty block nodes.
 */
export function isNodeEmpty(node) {
    if (node && node.textContent) {
        return false;
    }
    if (!node ||
        !node.childCount ||
        (node.childCount === 1 && isEmptyParagraph(node.firstChild))) {
        return true;
    }
    var block = [];
    var nonBlock = [];
    node.forEach(function (child) {
        child.isInline ? nonBlock.push(child) : block.push(child);
    });
    return (!nonBlock.length &&
        !block.filter(function (childNode) {
            return (!!childNode.childCount &&
                !(childNode.childCount === 1 && isEmptyParagraph(childNode.firstChild))) ||
                childNode.isAtom;
        }).length);
}
/**
 * Checks if a node looks like an empty document
 */
export function isEmptyDocument(node) {
    var nodeChild = node.content.firstChild;
    if (node.childCount !== 1 || !nodeChild) {
        return false;
    }
    return isEmptyParagraph(nodeChild);
}
// Checks to see if the parent node is the document, ie not contained within another entity
export function hasDocAsParent($anchor) {
    return $anchor.depth === 1;
}
export function isInEmptyLine(state) {
    var selection = state.selection;
    var _a = selection, $cursor = _a.$cursor, $anchor = _a.$anchor;
    if (!$cursor) {
        return false;
    }
    var node = $cursor.node();
    if (!node) {
        return false;
    }
    return isEmptyParagraph(node) && hasDocAsParent($anchor);
}
export function bracketTyped(state) {
    var selection = state.selection;
    var _a = selection, $cursor = _a.$cursor, $anchor = _a.$anchor;
    if (!$cursor) {
        return false;
    }
    var node = $cursor.nodeBefore;
    if (!node) {
        return false;
    }
    if (node.type.name === 'text' && node.text === '{') {
        var paragraphNode = $anchor.node();
        return paragraphNode.marks.length === 0 && hasDocAsParent($anchor);
    }
    return false;
}
function wrapWithUnsupported(originalValue, type) {
    if (type === void 0) { type = 'block'; }
    return {
        type: "unsupported" + (type === 'block' ? 'Block' : 'Inline'),
        attrs: { originalValue: originalValue },
    };
}
function fireAnalyticsEvent(entity, error, type) {
    if (type === void 0) { type = 'block'; }
    var code = error.code, meta = error.meta;
    analyticsService.trackEvent('atlassian.editor.unsupported', {
        name: entity.type || 'unknown',
        type: type,
        errorCode: code,
        meta: meta && JSON.stringify(meta),
    });
}
export function processRawValue(schema, value, providerFactory, sanitizePrivateContent, contentTransformer) {
    if (!value) {
        return;
    }
    var node;
    if (typeof value === 'string') {
        try {
            if (contentTransformer) {
                var doc = contentTransformer.parse(value);
                node = doc.toJSON();
            }
            else {
                node = JSON.parse(value);
            }
        }
        catch (e) {
            // eslint-disable-next-line no-console
            console.error("Error processing value: " + value + " isn't a valid JSON");
            return;
        }
    }
    else {
        node = value;
    }
    if (Array.isArray(node)) {
        // eslint-disable-next-line no-console
        console.error("Error processing value: " + node + " is an array, but it must be an object.");
        return;
    }
    try {
        // ProseMirror always require a child under doc
        if (node.type === 'doc') {
            if (Array.isArray(node.content) && node.content.length === 0) {
                node.content.push({
                    type: 'paragraph',
                    content: [],
                });
            }
            // Just making sure doc is always valid
            if (!node.version) {
                node.version = 1;
            }
        }
        if (contentTransformer) {
            return Node.fromJSON(schema, node);
        }
        var nodes = Object.keys(schema.nodes);
        var marks_1 = Object.keys(schema.marks);
        var validate = validator(nodes, marks_1, { allowPrivateAttributes: true });
        var emptyDoc = { type: 'doc', content: [] };
        var _a = validate(node, function (entity, error, options) {
            // Remove any invalid marks
            if (marks_1.indexOf(entity.type) > -1) {
                if (!(error.code === 'INVALID_TYPE' &&
                    FALSE_POSITIVE_MARKS.indexOf(entity.type) > -1)) {
                    fireAnalyticsEvent(entity, error, 'mark');
                }
                return;
            }
            /**
             * There's a inconsistency between ProseMirror and ADF.
             * `content` is actually optional in ProseMirror.
             * And, also empty `text` node is not valid.
             */
            if (error.code === 'MISSING_PROPERTIES' &&
                entity.type === 'paragraph') {
                return { type: 'paragraph', content: [] };
            }
            // Can't fix it by wrapping
            // TODO: We can repair missing content like `panel` without a `paragraph`.
            if (error.code === 'INVALID_CONTENT_LENGTH') {
                return entity;
            }
            if (options.allowUnsupportedBlock) {
                fireAnalyticsEvent(entity, error);
                return wrapWithUnsupported(entity);
            }
            else if (options.allowUnsupportedInline) {
                fireAnalyticsEvent(entity, error, 'inline');
                return wrapWithUnsupported(entity, 'inline');
            }
            return entity;
        }).entity, entity = _a === void 0 ? emptyDoc : _a;
        var newEntity = maySanitizePrivateContent(entity, providerFactory, sanitizePrivateContent);
        var parsedDoc = Node.fromJSON(schema, newEntity);
        // throws an error if the document is invalid
        parsedDoc.check();
        return parsedDoc;
    }
    catch (e) {
        // eslint-disable-next-line no-console
        console.error("Error processing document:\n" + e.message + "\n\n", JSON.stringify(node));
        return;
    }
}
var maySanitizePrivateContent = function (entity, providerFactory, sanitizePrivateContent) {
    if (sanitizePrivateContent && providerFactory) {
        return sanitizeNodeForPrivacy(entity, providerFactory);
    }
    return entity;
};
export var getStepRange = function (transaction) {
    var from = -1;
    var to = -1;
    transaction.steps.forEach(function (step) {
        step.getMap().forEach(function (_oldStart, _oldEnd, newStart, newEnd) {
            from = newStart < from || from === -1 ? newStart : from;
            to = newEnd < to || to === -1 ? newEnd : to;
        });
    });
    if (from !== -1) {
        return { from: from, to: to };
    }
    return null;
};
/**
 * Find the farthest node given a condition
 * @param predicate Function to check the node
 */
export var findFarthestParentNode = function (predicate) { return function ($pos) {
    var candidate = null;
    for (var i = $pos.depth; i > 0; i--) {
        var node = $pos.node(i);
        if (predicate(node)) {
            candidate = {
                pos: i > 0 ? $pos.before(i) : 0,
                start: $pos.start(i),
                depth: i,
                node: node,
            };
        }
    }
    return candidate;
}; };
export var isSelectionEndOfParagraph = function (state) {
    return state.selection.$to.parent.type === state.schema.nodes.paragraph &&
        state.selection.$to.pos === state.doc.resolve(state.selection.$to.pos).end();
};
export function nodesBetweenChanged(tr, f, startPos) {
    var stepRange = getStepRange(tr);
    if (!stepRange) {
        return;
    }
    tr.doc.nodesBetween(stepRange.from, stepRange.to, f, startPos);
}
export function getNodesCount(node) {
    var count = {};
    node.nodesBetween(0, node.nodeSize - 2, function (node) {
        count[node.type.name] = (count[node.type.name] || 0) + 1;
    });
    return count;
}
//# sourceMappingURL=document.js.map
import { inputRules, InputRule } from 'prosemirror-inputrules';
import { startMeasure, stopMeasure } from '@atlaskit/editor-common';
export function defaultInputRuleHandler(inputRule, isBlockNodeRule) {
    if (isBlockNodeRule === void 0) { isBlockNodeRule = false; }
    var originalHandler = inputRule.handler;
    inputRule.handler = function (state, match, start, end) {
        // Skip any input rule inside code
        // https://product-fabric.atlassian.net/wiki/spaces/E/pages/37945345/Editor+content+feature+rules#Editorcontent/featurerules-Rawtextblocks
        var unsupportedMarks = isBlockNodeRule
            ? hasUnsupportedMarkForBlockInputRule(state, start, end)
            : hasUnsupportedMarkForInputRule(state, start, end);
        if (state.selection.$from.parent.type.spec.code || unsupportedMarks) {
            return;
        }
        return originalHandler(state, match, start, end);
    };
    return inputRule;
}
// The chrome profiler groups all input rules together, making it tricky to detect which one is slow.
// This instrumentated method will add new marks with the format input-rule:<pluginName> making it
// pretty straightforward to find issues.
export function instrumentedInputRule(pluginName, _a) {
    var rules = _a.rules;
    var plugin = inputRules({ rules: rules });
    var handleTextInput = plugin.props.handleTextInput;
    var timerId = "input-rule:" + pluginName;
    plugin.props.handleTextInput = function (view, from, to, text) {
        startMeasure(timerId);
        var result = handleTextInput(view, from, to, text);
        stopMeasure(timerId, function () { });
        return result;
    };
    return plugin;
}
export function createInputRule(match, handler, isBlockNodeRule) {
    if (isBlockNodeRule === void 0) { isBlockNodeRule = false; }
    return defaultInputRuleHandler(new InputRule(match, handler), isBlockNodeRule);
}
// ProseMirror uses the Unicode Character 'OBJECT REPLACEMENT CHARACTER' (U+FFFC) as text representation for
// leaf nodes, i.e. nodes that don't have any content or text property (e.g. hardBreak, emoji, mention, rule)
// It was introduced because of https://github.com/ProseMirror/prosemirror/issues/262
// This can be used in an input rule regex to be able to include or exclude such nodes.
export var leafNodeReplacementCharacter = '\ufffc';
var hasUnsupportedMarkForBlockInputRule = function (state, start, end) {
    var doc = state.doc, marks = state.schema.marks;
    var unsupportedMarksPresent = false;
    var isUnsupportedMark = function (node) {
        return node.type === marks.code ||
            node.type === marks.link ||
            node.type === marks.typeAheadQuery;
    };
    doc.nodesBetween(start, end, function (node) {
        unsupportedMarksPresent =
            unsupportedMarksPresent ||
                node.marks.filter(isUnsupportedMark).length > 0;
    });
    return unsupportedMarksPresent;
};
var hasUnsupportedMarkForInputRule = function (state, start, end) {
    var doc = state.doc, marks = state.schema.marks;
    var unsupportedMarksPresent = false;
    var isCodemark = function (mark) { return mark.type === marks.code; };
    doc.nodesBetween(start, end, function (node) {
        unsupportedMarksPresent =
            unsupportedMarksPresent || node.marks.filter(isCodemark).length > 0;
    });
    return unsupportedMarksPresent;
};
//# sourceMappingURL=input-rules.js.map
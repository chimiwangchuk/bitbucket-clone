import { __assign } from "tslib";
import { findTable, findParentNodeOfType, } from 'prosemirror-utils';
import { defaultTableSelection } from './pm-plugins/main';
import { pluginKey as tableResizingPluginKey } from './pm-plugins/table-resizing';
import { TableSortStep } from './utils';
import { buildTableDecorationSet, hasColumnSelectedDecorations, removeColumnControlsSelected as removeColumnControlsSelectedDecorations, } from './decorations';
import { DecorationSet } from 'prosemirror-view';
import { CellSelection } from 'prosemirror-tables';
// #endregion
var nextTableSorting = function (tr, table) {
    var tableSortStep = tr.steps.find(function (step) { return step instanceof TableSortStep; });
    return tableSortStep && table && table.pos === tableSortStep.pos
        ? tableSortStep.next
        : undefined;
};
var nextResizeHandleColumnIndex = function (tr, resizeHandleColumnIndex) {
    if (tr.getMeta(tableResizingPluginKey)) {
        return undefined;
    }
    return resizeHandleColumnIndex;
};
var updateTargetCellPosition = function (_a) {
    var tr = _a.tr, table = _a.table;
    return function (pluginState) {
        var tableNode = table && table.node;
        if (!tableNode) {
            return __assign(__assign({}, pluginState), { targetCellPosition: undefined });
        }
        var _a = tr.doc.type.schema.nodes, tableCell = _a.tableCell, tableHeader = _a.tableHeader;
        var cell = findParentNodeOfType([tableCell, tableHeader])(tr.selection);
        var targetCellPosition = cell ? cell.pos : undefined;
        if (pluginState.targetCellPosition === targetCellPosition) {
            return pluginState;
        }
        return __assign(__assign({}, pluginState), { targetCellPosition: targetCellPosition });
    };
};
var updateTableNodePluginState = function (_a) {
    var tr = _a.tr, table = _a.table;
    return function (pluginState) {
        var tableNode = table && table.node;
        if (!tableNode) {
            return pluginState;
        }
        return __assign(__assign(__assign({}, pluginState), defaultTableSelection), { tableNode: tableNode, ordering: nextTableSorting(tr, table), resizeHandleColumnIndex: nextResizeHandleColumnIndex(tr, pluginState.resizeHandleColumnIndex) });
    };
};
var updateDecorationSet = function (_a) {
    var tr = _a.tr, table = _a.table;
    return function (pluginState) {
        if (!(tr.docChanged || tr.selection instanceof CellSelection)) {
            return pluginState;
        }
        return __assign(__assign({}, pluginState), { decorationSet: buildTableDecorationSet(true)({
                decorationSet: DecorationSet.empty,
                tr: tr,
            }) });
    };
};
var updateColumnControlsSelectedDecorations = function (_a) {
    var tr = _a.tr;
    return function (pluginState) {
        var isTransactionFromMouseClick = !tr.docChanged && tr.selectionSet && tr.getMeta('pointer');
        if (!isTransactionFromMouseClick ||
            !hasColumnSelectedDecorations(pluginState.decorationSet)) {
            return pluginState;
        }
        return __assign(__assign({}, pluginState), { decorationSet: removeColumnControlsSelectedDecorations(pluginState.decorationSet) });
    };
};
var buildPluginState = function (builders) { return function (props) { return function (pluginState) {
    return builders.reduce(function (_pluginState, transform) { return transform(props)(_pluginState); }, pluginState);
}; }; };
export var handleDocOrSelectionChanged = function (tr, pluginState) {
    return buildPluginState([
        updateTargetCellPosition,
        updateTableNodePluginState,
        updateColumnControlsSelectedDecorations,
        updateDecorationSet,
    ])({ tr: tr, table: findTable(tr.selection) })(pluginState);
};
//# sourceMappingURL=handlers.js.map
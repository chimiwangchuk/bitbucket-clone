import { Decoration, DecorationSet } from 'prosemirror-view';
import { getCellsInRow, getSelectionRect, findTable, } from 'prosemirror-utils';
import { TableMap } from 'prosemirror-tables';
import { TableCssClassName as ClassName, TableDecorations, } from '../types';
import { getPluginState } from '../pm-plugins/main';
import { nonNullable } from '../../../utils';
var filterDecorationByKey = function (key, decorationSet) {
    return decorationSet.find(undefined, undefined, function (spec) { return spec.key.indexOf(key) > -1; });
};
export var findColumnControlSelectedDecoration = function (decorationSet) {
    return filterDecorationByKey(TableDecorations.COLUMN_SELECTED, decorationSet);
};
export var findControlsHoverDecoration = function (decorationSet) {
    return filterDecorationByKey(TableDecorations.ALL_CONTROLS_HOVER, decorationSet);
};
export var createCellHoverDecoration = function (cells, type) {
    return cells.map(function (cell) {
        return Decoration.node(cell.pos, cell.pos + cell.node.nodeSize, {
            class: ClassName.HOVERED_CELL_WARNING,
        }, {
            key: TableDecorations.CELL_CONTROLS_HOVER,
        });
    });
};
export var createControlsHoverDecoration = function (cells, type, danger) {
    return cells.map(function (cell) {
        var classes = [ClassName.HOVERED_CELL];
        if (danger) {
            classes.push(ClassName.HOVERED_CELL_IN_DANGER);
        }
        classes.push(type === 'column'
            ? ClassName.HOVERED_COLUMN
            : type === 'row'
                ? ClassName.HOVERED_ROW
                : ClassName.HOVERED_TABLE);
        var key;
        switch (type) {
            case 'row':
                key = TableDecorations.ROW_CONTROLS_HOVER;
                break;
            case 'column':
                key = TableDecorations.COLUMN_CONTROLS_HOVER;
                break;
            default:
                key = TableDecorations.TABLE_CONTROLS_HOVER;
                break;
        }
        return Decoration.node(cell.pos, cell.pos + cell.node.nodeSize, {
            class: classes.join(' '),
        }, { key: key });
    });
};
export var createColumnSelectedDecorations = function (tr) {
    var selection = tr.selection, doc = tr.doc;
    var table = findTable(selection);
    var rect = getSelectionRect(selection);
    if (!table || !rect) {
        return [];
    }
    var map = TableMap.get(table.node);
    var cellPositions = map.cellsInRect(rect);
    return cellPositions.map(function (pos, index) {
        var cell = doc.nodeAt(pos + table.start);
        return Decoration.node(pos + table.start, pos + table.start + cell.nodeSize, {
            class: ClassName.COLUMN_SELECTED,
        }, {
            key: TableDecorations.COLUMN_SELECTED + "_" + index,
        });
    });
};
export var createColumnControlsDecoration = function (selection) {
    var cells = getCellsInRow(0)(selection) || [];
    var index = 0;
    return cells.map(function (cell) {
        var colspan = cell.node.attrs.colspan || 1;
        var element = document.createElement('div');
        element.classList.add(ClassName.COLUMN_CONTROLS_DECORATIONS);
        element.dataset.startIndex = "" + index;
        index += colspan;
        element.dataset.endIndex = "" + index;
        return Decoration.widget(cell.pos + 1, 
        // Do not delay the rendering for this Decoration
        // because we need to always render all controls
        // to keep the order safe
        element, {
            key: TableDecorations.COLUMN_CONTROLS_DECORATIONS + "_" + index,
            // this decoration should be the first one, even before gap cursor.
            side: -100,
        });
    });
};
export var updateNodeDecorations = function (node, decorationSet, decorations, key) {
    var filteredDecorations = filterDecorationByKey(key, decorationSet);
    var decorationSetFiltered = decorationSet.remove(filteredDecorations);
    return decorationSetFiltered.add(node, decorations);
};
export var updatePluginStateDecorations = function (state, decorations, key) {
    return updateNodeDecorations(state.doc, getPluginState(state).decorationSet || DecorationSet.empty, decorations, key);
};
var makeArray = function (n) { return Array.from(Array(n).keys()); };
/*
 * This function will create two specific decorations for each cell in a column index target,
 * for example given that table:
 *
 * ```
 *    0       1      2      3
 * _____________________ _______
 * |      |             |      |
 * |  B1  |     C1      |  A1  |
 * |______|______ ______|______|
 * |             |      |      |
 * |     B2      |      |  A2  |
 * |______ ______|      |______|
 * |      |      |  D1  |      |
 * |  B3  |  C2  |      |  A3  |
 * |______|______|______|______|
 *        ^      ^      ^      ^
 *        |      |      |      |
 *        |      |      |      |
 *        |      |      |      |
 *        0      1      3      4
 *         \     |      |     /
 *          \    |      |    /
 *           \   |      |   /
 *            \  |      |  /
 *             \ |      | /
 *         columnEndIndexTarget === CellColumnPositioning.right
 * ```
 *
 * When a user wants to resize a cell,
 * they need to grab and hold the end of that column,
 * and this will be the `columnEndIndexTarget` using
 * the CellColumnPositioning interface.
 *
 * Let's say the `columnEndIndexTarget.right` is 3,
 * so this function will return two types of decorations for each cell on that column,
 * that means 2 `resizerHandle` and 2 `lastCellElement`,
 * here is the explanation for each one of them :
 *
 * - resizerHandle:
 *
 *   Given the cell C1, this decoration will add a div to create this area
 * ```
 *    ▁▁▁▁▁▁▁▁▁▁▁▁▁
 *   |           ▒▒|
 *   |     C1    ▒▒|
 *   |           ▒▒|
 *    ▔▔▔▔▔▔▔▔▔▔▔▔▔
 * ```
 *   This ▒ represents the area where table resizing will start,
 *   and you can follow that using checking the class name `ClassName.RESIZE_HANDLE_DECORATION` on the code
 *
 * - lastCellElementDecoration
 *
 *   Given the content of the cell C1
 *    ▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
 *   |                   |
 *   |   _____________   |
 *   |  |             |  |
 *   |  |     <p>     |  |
 *   |  |_____________|  |
 *   |                   |
 *   |   _____________   |
 *   |  |             |  |
 *   |  |   <media>   |  |
 *   |  |_____________|  |
 *   |                   |
 *   |   _____________   |
 *   |  |             |  |
 *   |  |   <media>   |  |
 *   |  |_____________|  |
 *   |                   |
 *    ▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔
 *   Currently, we are removing the margin-bottom from the last media using this kind of CSS rule:
 *   `div:last-of-type`; This is quite unstable, and after we create the `resizerHandle` div,
 *   that logic will apply the margin in the wrong element, to avoid that,
 *   we will add a new class on the last item for each cell,
 *   hence the second media will receive this class `ClassName.LAST_ITEM_IN_CELL`
 */
export var createResizeHandleDecoration = function (tr, columnEndIndexTarget) {
    var emptyResult = [[], []];
    var table = findTable(tr.selection);
    if (!table || !table.node) {
        return emptyResult;
    }
    var map = TableMap.get(table.node);
    if (!map.width) {
        return emptyResult;
    }
    var createResizerHandleDecoration = function (cellColumnPositioning, columnIndex, rowIndex, cellPos, cellNode) {
        var element = document.createElement('div');
        element.classList.add(ClassName.RESIZE_HANDLE_DECORATION);
        element.dataset.startIndex = "" + cellColumnPositioning.left;
        element.dataset.endIndex = "" + cellColumnPositioning.right;
        var position = cellPos + cellNode.nodeSize - 1;
        return Decoration.widget(position, element, {
            key: TableDecorations.COLUMN_RESIZING_HANDLE + "_" + rowIndex + "_" + columnIndex,
        });
    };
    var createLastCellElementDecoration = function (cellColumnPositioning, cellPos, cellNode) {
        var lastItemPositions;
        cellNode.forEach(function (childNode, offset, index) {
            if (index === cellNode.childCount - 1) {
                var from = offset + cellPos + 1;
                lastItemPositions = {
                    from: from,
                    to: from + childNode.nodeSize,
                };
            }
        });
        if (!lastItemPositions) {
            return null;
        }
        return Decoration.node(lastItemPositions.from, lastItemPositions.to, {
            class: ClassName.LAST_ITEM_IN_CELL,
        }, {
            key: TableDecorations.LAST_CELL_ELEMENT + "_" + cellColumnPositioning.left + "_" + cellColumnPositioning.right,
        });
    };
    var resizeHandleCellDecorations = [];
    var lastCellElementsDecorations = [];
    for (var rowIndex = 0; rowIndex < map.height; rowIndex++) {
        var seen = {};
        for (var columnIndex = 0; columnIndex < map.width; columnIndex++) {
            var cellPosition = map.map[map.width * rowIndex + columnIndex];
            if (seen[cellPosition]) {
                continue;
            }
            seen[cellPosition] = true;
            var cellPos = table.start + cellPosition;
            var cell = tr.doc.nodeAt(cellPos);
            if (!cell) {
                continue;
            }
            var colspan = cell.attrs.colspan || 1;
            var startIndex = columnIndex;
            var endIndex = colspan + startIndex;
            if (endIndex !== columnEndIndexTarget.right) {
                continue;
            }
            var resizerHandleDec = createResizerHandleDecoration({ left: startIndex, right: endIndex }, columnIndex, rowIndex, cellPos, cell);
            var lastCellDec = createLastCellElementDecoration({ left: startIndex, right: endIndex }, cellPos, cell);
            resizeHandleCellDecorations.push(resizerHandleDec);
            lastCellElementsDecorations.push(lastCellDec);
        }
    }
    return [
        resizeHandleCellDecorations,
        lastCellElementsDecorations.filter(nonNullable),
    ];
};
/*
 * This function will create a decoration for each cell using the right position on the CellColumnPositioning
 * for example given that table:
 *
 * ```
 *    0       1      2      3   <--- column indexes
 * _____________________ _______
 * |      |             |      |
 * |  B1  |     C1      |  A1  |
 * |______|______ ______|______|
 * |             |      |      |
 * |     B2      |  D1  |  A2  |
 * |______ ______|______|______|
 * |      |      |             |
 * |  B3  |  C2  |      D2     |
 * |______|______|_____________|
 * ```
 *
 * and given the left and right represents the C1 cell:
 *
 * ```
 *      left          right
 *        1             3
 *        |             |
 *        |             |
 *        |             |
 * _______∨_____________∨_______
 * |      |             |      |
 * |  B1  |     C1      |  A1  |
 * |______|______ ______|______|
 * |             |      |      |
 * |     B2      |  D1  |  A2  |
 * |______ ______|______|______|
 * |      |      |             |
 * |  B3  |  C2  |      D2     |
 * |______|______|_____________|
 * ```
 *
 * Taking that table, and the right as parameters,
 * this function will return two decorations applying a new class `ClassName.WITH_RESIZE_LINE`
 * only on the cells: `C1` and `D1`.
 */
export var createColumnLineResize = function (selection, cellColumnPositioning) {
    var table = findTable(selection);
    if (!table || cellColumnPositioning.right === null) {
        return [];
    }
    var columnIndex = cellColumnPositioning.right - 1;
    var map = TableMap.get(table.node);
    var cellPositions = makeArray(map.height)
        .map(function (rowIndex) { return map.map[map.width * rowIndex + columnIndex]; })
        .filter(function (cellPosition, rowIndex) {
        if (columnIndex === map.width) {
            return true; // If is the last column no filter applied
        }
        var nextPosition = map.map[map.width * rowIndex + columnIndex + 1];
        return cellPosition !== nextPosition; // Removed it if next position is merged
    });
    var cells = cellPositions.map(function (pos) { return ({
        pos: pos + table.start,
        node: table.node.nodeAt(pos),
    }); });
    return cells
        .map(function (cell, index) {
        if (!cell || !cell.node) {
            return;
        }
        return Decoration.node(cell.pos, cell.pos + cell.node.nodeSize, {
            class: ClassName.WITH_RESIZE_LINE,
        }, {
            key: TableDecorations.COLUMN_RESIZING_HANDLE_LINE + "_" + cellColumnPositioning.right + "_" + index,
        });
    })
        .filter(nonNullable);
};
//# sourceMappingURL=decoration.js.map
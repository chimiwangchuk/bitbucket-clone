import { __read, __spread } from "tslib";
import { defineMessages } from 'react-intl';
import { hasParentNodeOfType } from 'prosemirror-utils';
import RemoveIcon from '@atlaskit/icon/glyph/editor/remove';
import EditIcon from '@atlaskit/icon/glyph/editor/edit';
import FullWidthIcon from '@atlaskit/icon/glyph/editor/media-full-width';
import WideIcon from '@atlaskit/icon/glyph/editor/media-wide';
import CenterIcon from '@atlaskit/icon/glyph/editor/media-center';
import commonMessages from '../../messages';
import { pluginKey as macroPluginKey } from '../macro';
import { hoverDecoration } from '../base/pm-plugins/decoration';
import { editExtension } from './actions';
import { getPluginState } from './plugin';
import { updateExtensionLayout, removeExtension } from './commands';
export var messages = defineMessages({
    edit: {
        id: 'fabric.editor.edit',
        defaultMessage: 'Edit',
        description: 'Edit the properties for this extension.',
    },
});
var isLayoutSupported = function (state, selectedExtNode) {
    var _a = state.schema.nodes, bodiedExtension = _a.bodiedExtension, extension = _a.extension, layoutSection = _a.layoutSection, table = _a.table, expand = _a.expand, selection = state.selection;
    if (!selectedExtNode) {
        return false;
    }
    return !!((selectedExtNode.node.type === bodiedExtension ||
        (selectedExtNode.node.type === extension &&
            !hasParentNodeOfType([bodiedExtension, table, expand].filter(Boolean))(selection))) &&
        !hasParentNodeOfType([layoutSection])(selection));
};
var breakoutOptions = function (state, formatMessage, extensionState, breakoutEnabled) {
    var layout = extensionState.layout, nodeWithPos = extensionState.nodeWithPos;
    return nodeWithPos && breakoutEnabled && isLayoutSupported(state, nodeWithPos)
        ? [
            {
                type: 'button',
                icon: CenterIcon,
                onClick: updateExtensionLayout('default'),
                selected: layout === 'default',
                title: formatMessage(commonMessages.layoutFixedWidth),
            },
            {
                type: 'button',
                icon: WideIcon,
                onClick: updateExtensionLayout('wide'),
                selected: layout === 'wide',
                title: formatMessage(commonMessages.layoutWide),
            },
            {
                type: 'button',
                icon: FullWidthIcon,
                onClick: updateExtensionLayout('full-width'),
                selected: layout === 'full-width',
                title: formatMessage(commonMessages.layoutFullWidth),
            },
        ]
        : [];
};
var editButton = function (formatMessage, extensionState, allowNewConfigPanel) {
    if (!extensionState.showEditButton) {
        return [];
    }
    return [
        {
            type: 'button',
            icon: EditIcon,
            // Taking the latest `updateExtension` from plugin state to avoid race condition @see ED-8501
            onClick: function (state, dispatch) {
                var macroState = macroPluginKey.getState(state);
                return editExtension(macroState && macroState.macroProvider, allowNewConfigPanel, getPluginState(state).updateExtension)(state, dispatch);
            },
            title: formatMessage(messages.edit),
        },
    ];
};
export var getToolbarConfig = function (breakoutEnabled, allowNewConfigPanel) {
    if (breakoutEnabled === void 0) { breakoutEnabled = true; }
    if (allowNewConfigPanel === void 0) { allowNewConfigPanel = false; }
    return function (state, _a) {
        var formatMessage = _a.formatMessage;
        var extensionState = getPluginState(state);
        if (extensionState &&
            !extensionState.showContextPanel &&
            extensionState.element) {
            var nodeType = [
                state.schema.nodes.extension,
                state.schema.nodes.inlineExtension,
                state.schema.nodes.bodiedExtension,
            ];
            var editButtonArray = editButton(formatMessage, extensionState, allowNewConfigPanel);
            var breakoutButtonArray = breakoutOptions(state, formatMessage, extensionState, breakoutEnabled);
            return {
                title: 'Extension floating controls',
                getDomRef: function () { return extensionState.element.parentElement || undefined; },
                nodeType: nodeType,
                items: __spread(editButtonArray, breakoutButtonArray, [
                    {
                        type: 'separator',
                        hidden: editButtonArray.length === 0 && breakoutButtonArray.length === 0,
                    },
                    {
                        type: 'button',
                        icon: RemoveIcon,
                        appearance: 'danger',
                        onClick: removeExtension(),
                        onMouseEnter: hoverDecoration(nodeType, true),
                        onMouseLeave: hoverDecoration(nodeType, false),
                        title: formatMessage(commonMessages.remove),
                    },
                ]),
            };
        }
        return;
    };
};
//# sourceMappingURL=toolbar.js.map
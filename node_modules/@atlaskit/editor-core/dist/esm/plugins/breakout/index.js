import { __assign, __makeTemplateObject } from "tslib";
import React from 'react';
import { css } from 'styled-components';
import { Plugin, PluginKey } from 'prosemirror-state';
import { findParentNode } from 'prosemirror-utils';
import { breakout } from '@atlaskit/adf-schema';
import { calcBreakoutWidth } from '@atlaskit/editor-common';
import WithPluginState from '../../ui/WithPluginState';
import { pluginKey as widthPluginKey } from '../width';
import LayoutButton from './ui/LayoutButton';
import { isSupportedNodeForBreakout } from './utils/is-supported-node';
import { BreakoutCssClassName } from './constants';
export var breakoutStyles = css(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  .ProseMirror > .", "[data-layout='full-width'],\n  .ProseMirror > .", "[data-layout='wide'] {\n    margin-left: 50%;\n    transform: translateX(-50%);\n  }\n"], ["\n  .ProseMirror > .", "[data-layout='full-width'],\n  .ProseMirror > .", "[data-layout='wide'] {\n    margin-left: 50%;\n    transform: translateX(-50%);\n  }\n"])), BreakoutCssClassName.BREAKOUT_MARK, BreakoutCssClassName.BREAKOUT_MARK);
export var pluginKey = new PluginKey('breakoutPlugin');
export var getPluginState = function (state) { return pluginKey.getState(state); };
var debounce = null;
var BreakoutView = /** @class */ (function () {
    function BreakoutView(node, view, eventDispatcher) {
        var _this = this;
        this.updateWidth = function () {
            var widthState = widthPluginKey.getState(_this.view.state);
            var width = calcBreakoutWidth(_this.node.attrs.mode, widthState.width);
            _this.dom.style.width = width;
        };
        // update pluginState on each nodeView update in order to reposition layout button relatively the updated node
        this.updateState = function () {
            if (debounce) {
                clearTimeout(debounce);
            }
            debounce = setTimeout(function () {
                var pluginState = pluginKey.getState(_this.view.state);
                if (_this.node !== pluginState.breakoutNode) {
                    var nextPluginState = __assign(__assign({}, pluginState), { breakoutNode: _this.node });
                    _this.eventDispatcher.emit(pluginKey.key, nextPluginState);
                }
                debounce = null;
            });
        };
        var contentDOM = document.createElement('div');
        contentDOM.className = BreakoutCssClassName.BREAKOUT_MARK_DOM;
        var dom = document.createElement('div');
        dom.className = BreakoutCssClassName.BREAKOUT_MARK;
        dom.setAttribute('data-layout', node.attrs.mode);
        dom.appendChild(contentDOM);
        this.dom = dom;
        this.node = node;
        this.view = view;
        this.contentDOM = contentDOM;
        this.eventDispatcher = eventDispatcher;
        eventDispatcher.on(widthPluginKey.key, this.updateWidth);
        this.updateWidth();
        this.updateState();
    }
    BreakoutView.prototype.destroy = function () {
        this.eventDispatcher.off(widthPluginKey.key, this.updateWidth);
    };
    return BreakoutView;
}());
function createPlugin(_a) {
    var dispatch = _a.dispatch, eventDispatcher = _a.eventDispatcher;
    return new Plugin({
        state: {
            init: function () {
                return {
                    breakoutNode: null,
                };
            },
            apply: function (tr, pluginState) {
                var breakoutNode = findParentNode(isSupportedNodeForBreakout)(tr.selection);
                var node = breakoutNode ? breakoutNode.node : null;
                if (node !== pluginState.breakoutNode) {
                    var nextPluginState = __assign(__assign({}, pluginState), { breakoutNode: node });
                    dispatch(pluginKey, nextPluginState);
                    return nextPluginState;
                }
                return pluginState;
            },
        },
        key: pluginKey,
        props: {
            nodeViews: {
                breakout: function (node, view) {
                    return new BreakoutView(node, view, eventDispatcher);
                },
            },
        },
    });
}
var breakoutPlugin = function (options) { return ({
    name: 'breakout',
    pmPlugins: function () {
        return [{ name: 'breakout', plugin: createPlugin }];
    },
    marks: function () {
        return [{ name: 'breakout', mark: breakout }];
    },
    contentComponent: function (_a) {
        var editorView = _a.editorView, popupsMountPoint = _a.popupsMountPoint, popupsBoundariesElement = _a.popupsBoundariesElement, popupsScrollableElement = _a.popupsScrollableElement;
        // This is a bit crappy, but should be resolved once we move to a static schema.
        if (options && !options.allowBreakoutButton) {
            return null;
        }
        return (React.createElement(WithPluginState, { plugins: {
                pluginState: pluginKey,
            }, render: function (_a) {
                var pluginState = _a.pluginState;
                return (React.createElement(LayoutButton, { editorView: editorView, mountPoint: popupsMountPoint, boundariesElement: popupsBoundariesElement, scrollableElement: popupsScrollableElement, node: pluginState.breakoutNode }));
            } }));
    },
}); };
export default breakoutPlugin;
var templateObject_1;
//# sourceMappingURL=index.js.map
import { Plugin, PluginKey } from 'prosemirror-state';
import { DecorationSet, Decoration } from 'prosemirror-view';
import { isInEmptyLine, isEmptyDocument, bracketTyped, } from '../../utils/document';
import { pluginKey as alignmentPluginKey } from '../alignment/pm-plugins/main';
import { placeHolderClassName } from './styles';
export var pluginKey = new PluginKey('placeholderPlugin');
import { focusStateKey } from '../base/pm-plugins/focus-handler';
function getPlaceholderState(editorState) {
    return pluginKey.getState(editorState);
}
export function createPlaceholderDecoration(editorState, placeholderText, pos) {
    if (pos === void 0) { pos = 1; }
    var placeholderDecoration = document.createElement('span');
    var placeHolderClass = placeHolderClassName;
    var alignment = alignmentPluginKey.getState(editorState);
    if (alignment && alignment.align === 'end') {
        placeHolderClass = placeHolderClass + ' align-end';
    }
    else if (alignment && alignment.align === 'center') {
        placeHolderClass = placeHolderClass + ' align-center';
    }
    placeholderDecoration.className = placeHolderClass;
    var placeholderNode = document.createElement('span');
    placeholderNode.textContent = placeholderText;
    placeholderDecoration.appendChild(placeholderNode);
    return DecorationSet.create(editorState.doc, [
        Decoration.widget(pos, placeholderDecoration, {
            side: -1,
            key: 'placeholder',
        }),
    ]);
}
function removePlaceholderIfData(view, event) {
    var placeHolderState = getPlaceholderState(view.state);
    var compositionEvent = event;
    var hasData = compositionEvent.type === 'compositionstart' ||
        (compositionEvent.type === 'compositionupdate' && !!compositionEvent.data);
    if (placeHolderState.hasPlaceholder && hasData) {
        view.dispatch(view.state.tr.setMeta(pluginKey, { removePlaceholder: true }));
    }
    return false;
}
function applyPlaceholderIfEmpty(view, event) {
    var placeHolderState = getPlaceholderState(view.state);
    var compositionEvent = event;
    var emptyData = compositionEvent.data === '';
    if (!placeHolderState.hasPlaceholder && emptyData) {
        view.dispatch(view.state.tr.setMeta(pluginKey, {
            applyPlaceholderIfEmpty: true,
        }));
    }
    return false;
}
function setPlaceHolderState(placeholderText, pos) {
    return {
        hasPlaceholder: true,
        placeholderText: placeholderText,
        pos: pos ? pos : 1,
    };
}
var emptyPlaceholder = { hasPlaceholder: false };
function createPlaceHolderStateFrom(editorState, getPlaceholderHintMessage, defaultPlaceholderText, bracketPlaceholderText) {
    var isEditorFocused = focusStateKey.getState(editorState);
    if (defaultPlaceholderText && isEmptyDocument(editorState.doc)) {
        return setPlaceHolderState(defaultPlaceholderText);
    }
    var placeholderHint = getPlaceholderHintMessage();
    if (placeholderHint && isInEmptyLine(editorState) && isEditorFocused) {
        var $from = editorState.selection.$from;
        return setPlaceHolderState(placeholderHint, $from.pos);
    }
    if (bracketPlaceholderText && bracketTyped(editorState) && isEditorFocused) {
        var $from = editorState.selection.$from;
        // Space is to account for positioning of the bracket
        var bracketHint = '  ' + bracketPlaceholderText;
        return setPlaceHolderState(bracketHint, $from.pos - 1);
    }
    return emptyPlaceholder;
}
function createGetPlaceholderHintMessage(placeholderHints) {
    var index = 0;
    return function () {
        if (!placeholderHints || placeholderHints.length === 0) {
            return;
        }
        var length = placeholderHints.length;
        var placeholder = placeholderHints[index++];
        index = index % length;
        return placeholder;
    };
}
export function createPlugin(defaultPlaceholderText, placeholderHints, bracketPlaceholderText) {
    if (!defaultPlaceholderText && !placeholderHints && !bracketPlaceholderText) {
        return;
    }
    var getPlaceholderHintMessage = createGetPlaceholderHintMessage(placeholderHints);
    return new Plugin({
        key: pluginKey,
        state: {
            init: function (_, state) {
                return createPlaceHolderStateFrom(state, getPlaceholderHintMessage, defaultPlaceholderText, bracketPlaceholderText);
            },
            apply: function (tr, _oldPluginState, _oldEditorState, newEditorState) {
                var meta = tr.getMeta(pluginKey);
                if (meta) {
                    if (meta.removePlaceholder) {
                        return emptyPlaceholder;
                    }
                    if (meta.applyPlaceholderIfEmpty) {
                        return createPlaceHolderStateFrom(newEditorState, getPlaceholderHintMessage, defaultPlaceholderText, bracketPlaceholderText);
                    }
                }
                return createPlaceHolderStateFrom(newEditorState, getPlaceholderHintMessage, defaultPlaceholderText, bracketPlaceholderText);
            },
        },
        props: {
            decorations: function (editorState) {
                var _a = getPlaceholderState(editorState), hasPlaceholder = _a.hasPlaceholder, placeholderText = _a.placeholderText, pos = _a.pos;
                if (hasPlaceholder && placeholderText && pos !== undefined) {
                    return createPlaceholderDecoration(editorState, placeholderText, pos);
                }
                return;
            },
            // Workaround for ED-4063: On Mobile / Android, a user can start typing but it won't trigger
            // an Editor state update so the placeholder will still be shown. We hook into the compositionstart
            // and compositionend events instead, to make sure we show/hide the placeholder for these devices.
            handleDOMEvents: {
                compositionstart: removePlaceholderIfData,
                compositionupdate: function (view, event) {
                    return applyPlaceholderIfEmpty(view, event) ||
                        removePlaceholderIfData(view, event);
                },
                compositionend: applyPlaceholderIfEmpty,
            },
        },
    });
}
var placeholderPlugin = function (options) { return ({
    name: 'placeholder',
    pmPlugins: function () {
        return [
            {
                name: 'placeholder',
                plugin: function () {
                    return createPlugin(options && options.placeholder, options && options.placeholderHints, options && options.placeholderBracketHint);
                },
            },
        ];
    },
}); };
export default placeholderPlugin;
//# sourceMappingURL=index.js.map
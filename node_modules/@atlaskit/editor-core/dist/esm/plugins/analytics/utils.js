import { __read, __spread } from "tslib";
import { findParentNode } from 'prosemirror-utils';
import { CellSelection } from 'prosemirror-tables';
import { NodeSelection } from 'prosemirror-state';
import { GapCursorSelection, Side } from '../gap-cursor/selection';
import { AnalyticsStep } from './analytics-step';
import { editorAnalyticsChannel, } from './index';
import { ACTION, ACTION_SUBJECT } from './types';
import { SELECTION_TYPE, SELECTION_POSITION } from './types/utils';
import { analyticsPluginKey } from './plugin-key';
function getAnalyticsState(editorState) {
    return analyticsPluginKey.getState(editorState);
}
export function getStateContext(state, payload) {
    if (payload.action === ACTION.INSERTED &&
        payload.actionSubject === ACTION_SUBJECT.DOCUMENT &&
        payload.attributes) {
        var _a = getSelectionType(state), type = _a.type, position = _a.position;
        payload.attributes.selectionType = type;
        if (position) {
            payload.attributes.selectionPosition = position;
        }
        payload.attributes.insertLocation = findInsertLocation(state);
    }
    return payload;
}
export function getSelectionType(state) {
    var selection = state.selection;
    var type;
    var position;
    if (selection instanceof GapCursorSelection) {
        type = SELECTION_TYPE.GAP_CURSOR;
        position =
            selection.side === Side.LEFT
                ? SELECTION_POSITION.LEFT
                : SELECTION_POSITION.RIGHT;
    }
    else if (selection instanceof CellSelection) {
        type = SELECTION_TYPE.CELL;
    }
    else if (selection instanceof NodeSelection) {
        type = SELECTION_TYPE.NODE;
    }
    else if (selection.from !== selection.to) {
        type = SELECTION_TYPE.RANGED;
    }
    else {
        type = SELECTION_TYPE.CURSOR;
        var from = selection.from, $from = selection.$from;
        if (from === $from.start()) {
            position = SELECTION_POSITION.START;
        }
        else if (from === $from.end()) {
            position = SELECTION_POSITION.END;
        }
        else {
            position = SELECTION_POSITION.MIDDLE;
        }
    }
    return {
        type: type,
        position: position,
    };
}
export function findInsertLocation(state) {
    var selection = state.selection;
    if (selection instanceof NodeSelection) {
        return selection.node.type.name;
    }
    if (selection instanceof CellSelection) {
        return state.schema.nodes.table.name;
    }
    // Text selection
    var parentNodeInfo = findParentNode(function (node) { return node.type !== state.schema.nodes.paragraph; })(state.selection);
    return parentNodeInfo ? parentNodeInfo.node.type.name : state.doc.type.name;
}
export function addAnalytics(state, tr, payload, channel) {
    if (channel === void 0) { channel = editorAnalyticsChannel; }
    var createAnalyticsEvent = getAnalyticsState(state);
    payload = getStateContext(state, payload);
    if (createAnalyticsEvent) {
        var storedMarks = tr.storedMarks;
        tr.step(new AnalyticsStep(createAnalyticsEvent, [
            {
                payload: payload,
                channel: channel,
            },
        ], tr.selection.$from.pos));
        // When you add a new step all the storedMarks are removed it
        if (storedMarks) {
            tr.setStoredMarks(storedMarks);
        }
    }
    return tr;
}
export function withAnalytics(payload, channel) {
    return function (command) { return function (state, dispatch, view) {
        return command(state, function (tr) {
            if (dispatch) {
                if (payload instanceof Function) {
                    var dynamicPayload = payload(state);
                    if (dynamicPayload) {
                        dispatch(addAnalytics(state, tr, dynamicPayload, channel));
                    }
                }
                else {
                    dispatch(addAnalytics(state, tr, payload, channel));
                }
            }
        }, view);
    }; };
}
export function ruleWithAnalytics(getPayload) {
    return function (rule) {
        // Monkey patching handler to add analytics
        var handler = rule.handler;
        rule.handler = function (state, match, start, end) {
            var tr = handler(state, match, start, end);
            if (tr) {
                var payload = getPayload(state, match, start, end);
                tr = addAnalytics(state, tr, payload);
            }
            return tr;
        };
        return rule;
    };
}
export var fireAnalyticsEvent = function (createAnalyticsEvent) { return function (_a) {
    var payload = _a.payload, _b = _a.channel, channel = _b === void 0 ? editorAnalyticsChannel : _b;
    return createAnalyticsEvent && createAnalyticsEvent(payload).fire(channel);
}; };
export function getAnalyticsEventsFromTransaction(tr) {
    return tr.steps
        .filter(function (step) { return step instanceof AnalyticsStep; })
        .reduce(function (acc, step) { return __spread(acc, step.analyticsEvents); }, []);
}
//# sourceMappingURL=utils.js.map
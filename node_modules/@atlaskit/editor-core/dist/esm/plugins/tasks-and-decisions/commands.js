import { uuid } from '@atlaskit/adf-schema';
import { TextSelection, } from 'prosemirror-state';
import { autoJoin } from 'prosemirror-commands';
import { safeInsert, hasParentNodeOfType, replaceParentNodeOfType, findParentNodeOfType, setTextSelection, } from 'prosemirror-utils';
import { GapCursorSelection } from '../gap-cursor';
import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE, addAnalytics, INPUT_METHOD, USER_CONTEXT, } from '../analytics';
import { stateKey as taskDecisionStateKey } from './pm-plugins/main';
var getContextData = function (contextProvider) {
    if (contextProvider === void 0) { contextProvider = {}; }
    var objectId = contextProvider.objectId, containerId = contextProvider.containerId;
    var userContext = objectId
        ? USER_CONTEXT.EDIT
        : USER_CONTEXT.NEW;
    return {
        objectId: objectId,
        containerId: containerId,
        userContext: userContext,
    };
};
var generateAnalyticsPayload = function (listType, contextData, inputMethod, itemLocalId, listLocalId, itemIdx, listSize) {
    var containerId;
    var objectId;
    var userContext;
    if (contextData) {
        (containerId = contextData.containerId, objectId = contextData.objectId, userContext = contextData.userContext);
    }
    return {
        action: ACTION.INSERTED,
        actionSubject: ACTION_SUBJECT.DOCUMENT,
        actionSubjectId: listType === 'taskList'
            ? ACTION_SUBJECT_ID.ACTION
            : ACTION_SUBJECT_ID.DECISION,
        eventType: EVENT_TYPE.TRACK,
        attributes: {
            inputMethod: inputMethod,
            containerAri: containerId,
            objectAri: objectId,
            userContext: userContext,
            localId: itemLocalId,
            listLocalId: listLocalId,
            position: itemIdx,
            listSize: listSize,
        },
    };
};
export var getListTypes = function (listType, schema) {
    var _a = schema.nodes, decisionList = _a.decisionList, decisionItem = _a.decisionItem, taskList = _a.taskList, taskItem = _a.taskItem;
    if (listType === 'taskList') {
        return {
            list: taskList,
            item: taskItem,
        };
    }
    return {
        list: decisionList,
        item: decisionItem,
    };
};
export var insertTaskDecision = function (view, listType, inputMethod, listLocalId, itemLocalId) {
    if (inputMethod === void 0) { inputMethod = INPUT_METHOD.TOOLBAR; }
    var state = view.state;
    var schema = state.schema;
    var addAndCreateList = function (_a) {
        var tr = _a.tr, list = _a.list, item = _a.item, listLocalId = _a.listLocalId, itemLocalId = _a.itemLocalId;
        return createListAtSelection(tr, list, item, schema, state, listLocalId, itemLocalId);
    };
    var addToList = function (_a) {
        var state = _a.state, tr = _a.tr, item = _a.item, itemLocalId = _a.itemLocalId;
        var $to = state.selection.$to;
        var pos = $to.end($to.depth);
        return tr
            .split(pos, 1, [{ type: item, attrs: { localId: itemLocalId } }])
            .setSelection(new TextSelection(tr.doc.resolve(pos + $to.depth)));
    };
    var tr = insertTaskDecisionWithAnalytics(state, listType, inputMethod, addAndCreateList, addToList, listLocalId, itemLocalId);
    return autoJoin(function (state, dispatch) {
        if (tr) {
            if (dispatch) {
                dispatch(tr);
            }
            return true;
        }
        return false;
    }, ['taskList', 'decisionList']);
};
export var insertTaskDecisionWithAnalytics = function (state, listType, inputMethod, addAndCreateList, addToList, listLocalId, itemLocalId) {
    var schema = state.schema;
    var _a = getListTypes(listType, schema), list = _a.list, item = _a.item;
    var tr = state.tr;
    var $to = state.selection.$to;
    var listNode = findParentNodeOfType(list)(state.selection);
    var contextIdentifierProvider = taskDecisionStateKey.getState(state)
        .contextIdentifierProvider;
    var contextData = getContextData(contextIdentifierProvider);
    var insertTrCreator;
    var itemIdx;
    var listSize;
    if (!listNode) {
        // Not a list - convert to one.
        itemIdx = 0;
        listSize = 1;
        insertTrCreator = addAndCreateList;
    }
    else if ($to.node().textContent.length >= 0) {
        listSize = listNode.node.childCount + 1;
        listLocalId = listLocalId || listNode.node.attrs.localId;
        var listItemNode = findParentNodeOfType(item)(state.selection); // finds current item in list
        itemIdx = listItemNode
            ? state.doc.resolve(listItemNode.pos).index() + 1
            : 0;
        insertTrCreator = addToList ? addToList : addAndCreateList;
    }
    listLocalId = listLocalId || uuid.generate();
    itemLocalId = itemLocalId || uuid.generate();
    if (insertTrCreator) {
        var insertTr = insertTrCreator({
            state: state,
            tr: tr,
            list: list,
            item: item,
            listLocalId: listLocalId,
            itemLocalId: itemLocalId,
        });
        if (insertTr) {
            insertTr = addAnalytics(state, insertTr, generateAnalyticsPayload(listType, contextData, inputMethod, itemLocalId, listLocalId, itemIdx || 0, listSize || 0));
        }
        return insertTr;
    }
    return null;
};
export var isSupportedSourceNode = function (schema, selection) {
    var _a = schema.nodes, paragraph = _a.paragraph, blockquote = _a.blockquote, decisionList = _a.decisionList, taskList = _a.taskList;
    return hasParentNodeOfType([blockquote, paragraph, decisionList, taskList])(selection);
};
export var changeInDepth = function (before, after) {
    return after.depth - before.depth;
};
export var createListAtSelection = function (tr, list, item, schema, state, listLocalId, itemLocalId) {
    if (listLocalId === void 0) { listLocalId = uuid.generate(); }
    if (itemLocalId === void 0) { itemLocalId = uuid.generate(); }
    var selection = state.selection;
    var $from = selection.$from, $to = selection.$to;
    if ($from.parent !== $to.parent) {
        // ignore selections across multiple nodes
        return null;
    }
    var _a = schema.nodes, paragraph = _a.paragraph, blockquote = _a.blockquote, decisionList = _a.decisionList, taskList = _a.taskList, decisionItem = _a.decisionItem, taskItem = _a.taskItem, mediaGroup = _a.mediaGroup;
    if ($from.parent.type === mediaGroup) {
        return null;
    }
    var emptyList = list.create({ localId: listLocalId }, [
        item.create({ localId: itemLocalId }),
    ]);
    // we don't take the content of a block node next to the gap cursor and always create an empty task
    if (selection instanceof GapCursorSelection) {
        return safeInsert(emptyList)(tr);
    }
    // try to replace when selection is in nodes which support it
    if (isSupportedSourceNode(schema, selection)) {
        var _b = selection.$from.node(), nodeType = _b.type, childCount = _b.childCount;
        var newListNode = list.create({ localId: uuid.generate() }, [
            item.create({ localId: uuid.generate() }, $from.node($from.depth).content),
        ]);
        var listParent = findParentNodeOfType(taskList)(selection) ||
            findParentNodeOfType(decisionList)(selection);
        var listItem = findParentNodeOfType(taskItem)(selection) ||
            findParentNodeOfType(decisionItem)(selection);
        // For a selection inside a task/decision list, we can't just simply replace the
        // node type as it will mess up lists with > 1 item
        if (listParent && listItem) {
            var start = void 0;
            var end = void 0;
            var selectionPos = selection.from;
            // if selection is in first item in list, we need to delete extra so that
            // this list isn't split
            if (listParent.node.firstChild === listItem.node) {
                start = listParent.start - 1;
                end = listItem.start + listItem.node.nodeSize;
                if (listParent.node.childCount === 1) {
                    end = listParent.start + listParent.node.nodeSize - 1;
                }
            }
            else {
                start = listItem.start - 1;
                end = listItem.start + listItem.node.nodeSize;
                selectionPos += 2; // as we have added the new list node
            }
            tr.replaceWith(start, end, newListNode);
            tr = setTextSelection(selectionPos)(tr);
            return tr;
        }
        // For a selection inside one of these node types we can just convert the node type
        var nodeTypesToReplace = [blockquote];
        if (nodeType === paragraph && childCount > 0) {
            // Only convert paragraphs containing content.
            // Empty paragraphs use the default flow.
            // This distinction ensures the text selection remains in the correct location.
            nodeTypesToReplace.push(paragraph);
        }
        var newTr = tr;
        newTr = replaceParentNodeOfType(nodeTypesToReplace, newListNode)(tr);
        // Adjust depth for new selection, if it has changed (e.g. paragraph to list (ol > li))
        var depthAdjustment = changeInDepth($to, newTr.selection.$to);
        tr = tr.setSelection(new TextSelection(tr.doc.resolve($to.pos + depthAdjustment)));
        // replacing successful
        if (newTr !== tr) {
            return tr;
        }
    }
    return safeInsert(emptyList)(tr);
};
//# sourceMappingURL=commands.js.map
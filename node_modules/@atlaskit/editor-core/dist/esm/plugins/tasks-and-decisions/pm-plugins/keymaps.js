import { __assign } from "tslib";
import { uuid } from '@atlaskit/adf-schema';
import { keymap } from 'prosemirror-keymap';
import { Fragment, Slice } from 'prosemirror-model';
import { TextSelection, } from 'prosemirror-state';
import { findParentNodeOfTypeClosestToPos } from 'prosemirror-utils';
import { insertTaskDecisionWithAnalytics } from '../commands';
import { autoJoin, chainCommands } from 'prosemirror-commands';
import { filter, isEmptySelectionAtEnd, isEmptySelectionAtStart, } from '../../../utils/commands';
import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE, INDENT_DIR, INDENT_TYPE, INPUT_METHOD, withAnalytics, } from '../../analytics';
import { isInsideTaskOrDecisionItem, isActionOrDecisionList, isActionOrDecisionItem, isInsideTask, getBlockRange, getCurrentIndentLevel, walkOut, isEmptyTaskDecision, liftBlock, subtreeHeight, } from './helpers';
import { liftSelection, wrapSelectionInTaskList, joinAtCut } from './commands';
var indentationAnalytics = function (curIndentLevel, direction) { return ({
    action: ACTION.FORMATTED,
    actionSubject: ACTION_SUBJECT.TEXT,
    actionSubjectId: ACTION_SUBJECT_ID.FORMAT_INDENT,
    eventType: EVENT_TYPE.TRACK,
    attributes: {
        inputMethod: INPUT_METHOD.KEYBOARD,
        previousIndentationLevel: curIndentLevel,
        newIndentLevel: direction === INDENT_DIR.OUTDENT
            ? curIndentLevel - 1
            : curIndentLevel + 1,
        direction: direction,
        indentType: INDENT_TYPE.TASK_LIST,
    },
}); };
var nodeAfter = function ($pos) { return $pos.doc.resolve($pos.end()).nodeAfter; };
var actionDecisionFollowsOrNothing = function ($pos) {
    var after = nodeAfter($pos);
    return !after || isActionOrDecisionItem(after);
};
var joinTaskDecisionFollowing = function (state, dispatch) {
    // look for the node after this current one
    var $next = walkOut(state.selection.$from);
    // if there's no taskItem or taskList following, then
    // we just do the normal behaviour
    var _a = state.schema.nodes, taskList = _a.taskList, taskItem = _a.taskItem, decisionList = _a.decisionList, decisionItem = _a.decisionItem, paragraph = _a.paragraph, bulletList = _a.bulletList, orderedList = _a.orderedList, listItem = _a.listItem;
    var parentList = findParentNodeOfTypeClosestToPos($next, [
        taskList,
        taskItem,
        decisionList,
        decisionItem,
    ]);
    if (!parentList) {
        if ($next.parent.type === paragraph) {
            // try to join paragraph and taskList when backspacing
            return joinAtCut($next.doc.resolve($next.pos))(state, dispatch);
        }
        // If the item we are joining is a list
        if ($next.parent.type === bulletList || $next.parent.type === orderedList) {
            // If the list has an item
            if ($next.parent.firstChild &&
                $next.parent.firstChild.type === listItem) {
                // Place the cursor at the first listItem
                var resolvedStartPos = state.doc.resolve($next.pos + 1);
                // Unindent the first listItem.
                // As if placing your cursor just after the first dot of the list (before the text)
                // and pressing Shift-Tab.
                var tr_1 = liftBlock(state.tr, resolvedStartPos, resolvedStartPos);
                // If autoJoin not used, two ul/ol elements appear rather than one with multiple li elements
                return autoJoin(function (state, dispatch) {
                    if (tr_1) {
                        if (dispatch) {
                            dispatch(tr_1);
                        }
                        return true;
                    }
                    return false;
                }, ['bulletList', 'orderedList'])(state, dispatch);
            }
        }
    }
    return false;
};
var unindent = filter(isInsideTask, function (state, dispatch) {
    var curIndentLevel = getCurrentIndentLevel(state.selection);
    if (!curIndentLevel || curIndentLevel === 1) {
        return false;
    }
    return withAnalytics(indentationAnalytics(curIndentLevel, INDENT_DIR.OUTDENT))(autoJoin(liftSelection, ['taskList']))(state, dispatch);
});
var indent = filter(isInsideTask, function (state, dispatch) {
    // limit ui indentation to 6 levels
    var curIndentLevel = getCurrentIndentLevel(state.selection);
    if (!curIndentLevel || curIndentLevel >= 6) {
        return true;
    }
    var _a = state.schema.nodes, taskList = _a.taskList, taskItem = _a.taskItem;
    var _b = state.selection, $from = _b.$from, $to = _b.$to;
    var maxDepth = subtreeHeight($from, $to, [taskList, taskItem]);
    if (maxDepth >= 6) {
        return true;
    }
    return withAnalytics(indentationAnalytics(curIndentLevel, INDENT_DIR.INDENT))(autoJoin(wrapSelectionInTaskList, ['taskList']))(state, dispatch);
});
var backspaceFrom = function ($from) { return function (state, dispatch) {
    // previous was empty, just delete backwards
    var taskBefore = $from.doc.resolve($from.before());
    if (taskBefore.nodeBefore &&
        isActionOrDecisionItem(taskBefore.nodeBefore) &&
        taskBefore.nodeBefore.nodeSize === 2) {
        return false;
    }
    // if nested, just unindent
    var _a = state.schema.nodes, taskList = _a.taskList, paragraph = _a.paragraph;
    if ($from.node($from.depth - 2).type === taskList) {
        return unindent(state, dispatch);
    }
    // bottom level, should "unwrap" taskItem contents into paragraph
    // we achieve this by slicing the content out, and replacing
    if (actionDecisionFollowsOrNothing($from)) {
        if (dispatch) {
            var taskContent = state.doc.slice($from.start(), $from.end()).content;
            // might be end of document after
            var slice = taskContent.size
                ? paragraph.createChecked(undefined, taskContent)
                : paragraph.createChecked();
            dispatch(splitListItemWith(state.tr, slice, $from, true));
        }
        return true;
    }
    return false;
}; };
var backspace = filter(isEmptySelectionAtStart, autoJoin(chainCommands(function (state, dispatch) { return joinAtCut(state.selection.$from)(state, dispatch); }, filter(isInsideTaskOrDecisionItem, function (state, dispatch) {
    return backspaceFrom(state.selection.$from)(state, dispatch);
})), ['taskList', 'decisionList']));
var deleteHandler = filter([isInsideTaskOrDecisionItem, isEmptySelectionAtEnd], chainCommands(joinTaskDecisionFollowing, function (state, dispatch) {
    // look for the node after this current one
    var $next = walkOut(state.selection.$from);
    var _a = state.schema.nodes, taskList = _a.taskList, paragraph = _a.paragraph;
    // previous was empty, just delete backwards
    var taskBefore = $next.doc.resolve($next.before());
    if (taskBefore.nodeBefore &&
        isActionOrDecisionItem(taskBefore.nodeBefore) &&
        taskBefore.nodeBefore.nodeSize === 2) {
        return false;
    }
    // if nested, just unindent
    if ($next.node($next.depth - 2).type === taskList) {
        var tr = liftBlock(state.tr, $next, $next);
        if (dispatch && tr) {
            dispatch(tr);
        }
        return true;
    }
    // bottom level, should "unwrap" taskItem contents into paragraph
    // we achieve this by slicing the content out, and replacing
    if (actionDecisionFollowsOrNothing(state.selection.$from)) {
        if (dispatch) {
            var taskContent = state.doc.slice($next.start(), $next.end()).content;
            // might be end of document after
            var slice = taskContent.size
                ? paragraph.createChecked(undefined, taskContent)
                : [];
            dispatch(splitListItemWith(state.tr, slice, $next, false));
        }
        return true;
    }
    return false;
}));
var deleteForwards = autoJoin(deleteHandler, ['taskList', 'decisionList']);
var splitListItemWith = function (tr, content, $from, setSelection) {
    var origDoc = tr.doc;
    // split just before the current item
    // we can only split if there was a list item before us
    var container = $from.node($from.depth - 2);
    var posInList = $from.index($from.depth - 1);
    var shouldSplit = !(!isActionOrDecisionList(container) && posInList === 0);
    if (shouldSplit) {
        // this only splits a node to delete it, so we probably don't need a random uuid
        // but generate one anyway for correctness
        tr = tr.split($from.pos, 1, [
            {
                type: $from.parent.type,
                attrs: { localId: uuid.generate() },
            },
        ]);
    }
    // and delete the action at the current pos
    // we can do this because we know either first new child will be taskItem or nothing at all
    var frag = Fragment.from(content);
    tr = tr.replace(tr.mapping.map($from.start() - 2), tr.mapping.map($from.end() + 2), frag.size ? new Slice(frag, 0, 0) : Slice.empty);
    // put cursor inside paragraph
    if (setSelection) {
        tr = tr.setSelection(new TextSelection(tr.doc.resolve($from.pos + 1 - (shouldSplit ? 0 : 2))));
    }
    // lift list up if the node after the initial one was a taskList
    // which means it would have empty placeholder content if we just immediately delete it
    //
    // if it's a taskItem then it can stand alone, so it's fine
    var $oldAfter = origDoc.resolve($from.after());
    // if different levels then we shouldn't lift
    if ($oldAfter.depth === $from.depth - 1) {
        if ($oldAfter.nodeAfter && isActionOrDecisionList($oldAfter.nodeAfter)) {
            // getBlockRange expects to be inside the taskItem
            var pos = tr.mapping.map($oldAfter.pos + 2);
            var $after = tr.doc.resolve(pos);
            var blockRange = getBlockRange($after, tr.doc.resolve($after.after($after.depth - 1) - 1));
            if (blockRange) {
                tr = tr.lift(blockRange, blockRange.depth - 1).scrollIntoView();
            }
            // we delete 1 past the range of the empty taskItem
            // otherwise we hit a bug in prosemirror-transform:
            // Cannot read property 'content' of undefined
            tr = tr.deleteRange(pos - 3, pos - 1);
        }
    }
    return tr;
};
var splitListItem = function (state, dispatch) {
    var tr = state.tr, $from = state.selection.$from;
    var paragraph = state.schema.nodes.paragraph;
    if (actionDecisionFollowsOrNothing($from)) {
        if (dispatch) {
            dispatch(splitListItemWith(tr, paragraph.createChecked(), $from, true));
        }
        return true;
    }
    return false;
};
var enter = filter(isInsideTaskOrDecisionItem, chainCommands(filter(isEmptyTaskDecision, chainCommands(unindent, splitListItem)), function (state, dispatch) {
    var selection = state.selection, schema = state.schema;
    var taskItem = schema.nodes.taskItem;
    var $from = selection.$from;
    var node = $from.node($from.depth);
    var nodeType = node && node.type;
    var listType = nodeType === taskItem ? 'taskList' : 'decisionList';
    var addItem = function (_a) {
        var tr = _a.tr, itemLocalId = _a.itemLocalId;
        return tr.split($from.pos, 1, [
            { type: nodeType, attrs: { localId: itemLocalId } },
        ]);
    };
    var insertTr = insertTaskDecisionWithAnalytics(state, listType, INPUT_METHOD.KEYBOARD, addItem);
    if (insertTr && dispatch) {
        insertTr.scrollIntoView();
        dispatch(insertTr);
    }
    return true;
}));
export function keymapPlugin(schema, allowNestedTasks, consumeTabs) {
    var indentHandlers = {
        'Shift-Tab': consumeTabs
            ? chainCommands(unindent, isInsideTaskOrDecisionItem)
            : unindent,
        Tab: consumeTabs
            ? chainCommands(indent, isInsideTaskOrDecisionItem)
            : indent,
    };
    var defaultHandlers = consumeTabs
        ? {
            'Shift-Tab': isInsideTaskOrDecisionItem,
            Tab: isInsideTaskOrDecisionItem,
        }
        : {};
    var keymaps = __assign({ Backspace: backspace, Delete: deleteForwards, Enter: enter }, (allowNestedTasks ? indentHandlers : defaultHandlers));
    return keymap(keymaps);
}
export default keymapPlugin;
//# sourceMappingURL=keymaps.js.map
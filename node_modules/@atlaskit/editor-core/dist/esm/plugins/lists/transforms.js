import { __read } from "tslib";
import { Fragment, NodeRange, Slice, } from 'prosemirror-model';
import { EditorState, TextSelection, } from 'prosemirror-state';
import { liftTarget, ReplaceAroundStep } from 'prosemirror-transform';
import { getListLiftTarget } from './utils';
import { mapSlice, mapChildren } from '../../utils/slice';
import { autoJoin } from 'prosemirror-commands';
function liftListItem(state, selection, tr) {
    var $from = selection.$from, $to = selection.$to;
    var nodeType = state.schema.nodes.listItem;
    var range = $from.blockRange($to, function (node) {
        return !!node.childCount &&
            !!node.firstChild &&
            node.firstChild.type === nodeType;
    });
    if (!range ||
        range.depth < 2 ||
        $from.node(range.depth - 1).type !== nodeType) {
        return tr;
    }
    var end = range.end;
    var endOfList = $to.end(range.depth);
    if (end < endOfList) {
        tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(nodeType.create(undefined, range.parent.copy())), 1, 0), 1, true));
        range = new NodeRange(tr.doc.resolve($from.pos), tr.doc.resolve(endOfList), range.depth);
    }
    return tr.lift(range, liftTarget(range)).scrollIntoView();
}
// Function will lift list item following selection to level-1.
export function liftFollowingList(state, from, to, rootListDepth, tr) {
    var listItem = state.schema.nodes.listItem;
    var lifted = false;
    tr.doc.nodesBetween(from, to, function (node, pos) {
        if (!lifted && node.type === listItem && pos > from) {
            lifted = true;
            var listDepth = rootListDepth + 3;
            while (listDepth > rootListDepth + 2) {
                var start = tr.doc.resolve(tr.mapping.map(pos));
                listDepth = start.depth;
                var end = tr.doc.resolve(tr.mapping.map(pos + node.textContent.length));
                var sel = new TextSelection(start, end);
                tr = liftListItem(state, sel, tr);
            }
        }
    });
    return tr;
}
// The function will list paragraphs in selection out to level 1 below root list.
export function liftSelectionList(state, tr) {
    var _a = state.selection, from = _a.from, to = _a.to;
    var paragraph = state.schema.nodes.paragraph;
    var listCol = [];
    tr.doc.nodesBetween(from, to, function (node, pos) {
        if (node.type === paragraph) {
            listCol.push({ node: node, pos: pos });
        }
    });
    for (var i = listCol.length - 1; i >= 0; i--) {
        var paragraph_1 = listCol[i];
        var start = tr.doc.resolve(tr.mapping.map(paragraph_1.pos));
        if (start.depth > 0) {
            var end = void 0;
            if (paragraph_1.node.textContent && paragraph_1.node.textContent.length > 0) {
                end = tr.doc.resolve(tr.mapping.map(paragraph_1.pos + paragraph_1.node.textContent.length));
            }
            else {
                end = tr.doc.resolve(tr.mapping.map(paragraph_1.pos + 1));
            }
            var range = start.blockRange(end);
            if (range) {
                tr.lift(range, getListLiftTarget(state.schema, start));
            }
        }
    }
    return tr;
}
// matchers for text lists
var bullets = /^\s*[\*\-\u2022](\s*|$)/;
var numbers = /^\s*\d[\.\)](\s+|$)/;
var getListType = function (node, schema) {
    if (!node.text) {
        return null;
    }
    var _a = schema.nodes, bulletList = _a.bulletList, orderedList = _a.orderedList;
    return [
        {
            node: bulletList,
            matcher: bullets,
        },
        {
            node: orderedList,
            matcher: numbers,
        },
    ].reduce(function (lastMatch, listType) {
        if (lastMatch) {
            return lastMatch;
        }
        var match = node.text.match(listType.matcher);
        return match ? [listType.node, match[0].length] : lastMatch;
    }, null);
};
var extractListFromParagaph = function (node, schema) {
    var _a = schema.nodes, hardBreak = _a.hardBreak, bulletList = _a.bulletList, orderedList = _a.orderedList;
    var content = mapChildren(node.content, function (node) { return node; });
    var listTypes = [bulletList, orderedList];
    // wrap each line into a listItem and a containing list
    var listified = content
        .map(function (child, index) {
        var listMatch = getListType(child, schema);
        var prevChild = index > 0 && content[index - 1];
        // only extract list when preceded by a hardbreak
        if (prevChild && prevChild.type !== hardBreak) {
            return child;
        }
        if (!listMatch || !child.text) {
            return child;
        }
        var _a = __read(listMatch, 2), nodeType = _a[0], length = _a[1];
        // convert to list item
        var newText = child.text.substr(length);
        var listItemNode = schema.nodes.listItem.createAndFill(undefined, schema.nodes.paragraph.createChecked(undefined, newText.length ? schema.text(newText) : undefined));
        if (!listItemNode) {
            return child;
        }
        return nodeType.createChecked(undefined, [listItemNode]);
    })
        .filter(function (child, idx, arr) {
        // remove hardBreaks that have a list node on either side
        // wasn't hardBreak, leave as-is
        if (child.type !== hardBreak) {
            return child;
        }
        if (idx > 0 && listTypes.indexOf(arr[idx - 1].type) > -1) {
            // list node on the left
            return null;
        }
        if (idx < arr.length - 1 && listTypes.indexOf(arr[idx + 1].type) > -1) {
            // list node on the right
            return null;
        }
        return child;
    });
    // try to join
    var mockState = EditorState.create({
        schema: schema,
    });
    var lastTr;
    var mockDispatch = function (tr) {
        lastTr = tr;
    };
    autoJoin(function (state, dispatch) {
        if (!dispatch) {
            return false;
        }
        dispatch(state.tr.replaceWith(0, 2, listified));
        return true;
    }, function () { return true; })(mockState, mockDispatch);
    var fragment = lastTr ? lastTr.doc.content : Fragment.from(listified);
    // try to re-wrap fragment in paragraph (which is the original node we unwrapped)
    var paragraph = schema.nodes.paragraph;
    if (paragraph.validContent(fragment)) {
        return Fragment.from(paragraph.create(node.attrs, fragment, node.marks));
    }
    // fragment now contains other nodes, get Prosemirror to wrap with ContentMatch later
    return fragment;
};
/**
 * Walks the slice, creating paragraphs that were previously separated by hardbreaks.
 * @param slice
 * @param schema
 * @returns the original paragraph node (as a fragment), or a fragment containing multiple nodes
 */
var splitIntoParagraphs = function (fragment, schema) {
    var paragraphs = [];
    var curChildren = [];
    var lastNode = null;
    var _a = schema.nodes, hardBreak = _a.hardBreak, paragraph = _a.paragraph;
    fragment.forEach(function (node) {
        if (lastNode && lastNode.type === hardBreak && node.type === hardBreak) {
            // double hardbreak
            // backtrack a little; remove the trailing hardbreak we added last loop
            curChildren.pop();
            // create a new paragraph
            paragraphs.push(paragraph.createChecked(undefined, curChildren));
            curChildren = [];
            return;
        }
        // add to this paragraph
        curChildren.push(node);
        lastNode = node;
    });
    if (curChildren.length) {
        paragraphs.push(paragraph.createChecked(undefined, curChildren));
    }
    return Fragment.from(paragraphs.length ? paragraphs : [paragraph.createAndFill()]);
};
export var splitParagraphs = function (slice, schema) {
    // exclude Text nodes with a code mark, since we transform those later
    // into a codeblock
    var hasCodeMark = false;
    slice.content.forEach(function (child) {
        hasCodeMark =
            hasCodeMark || child.marks.some(function (mark) { return mark.type === schema.marks.code; });
    });
    // slice might just be a raw text string
    if (schema.nodes.paragraph.validContent(slice.content) && !hasCodeMark) {
        var replSlice = splitIntoParagraphs(slice.content, schema);
        return new Slice(replSlice, slice.openStart + 1, slice.openEnd + 1);
    }
    return mapSlice(slice, function (node, parent) {
        if (node.type === schema.nodes.paragraph) {
            return splitIntoParagraphs(node.content, schema);
        }
        return node;
    });
};
// above will wrap everything in paragraphs for us
export var upgradeTextToLists = function (slice, schema) {
    return mapSlice(slice, function (node, parent) {
        if (node.type === schema.nodes.paragraph) {
            return extractListFromParagaph(node, schema);
        }
        return node;
    });
};
//# sourceMappingURL=transforms.js.map
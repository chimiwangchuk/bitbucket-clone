import { Plugin, PluginKey } from 'prosemirror-state';
import { pluginFactory } from '../../utils/plugin-state-factory';
import reducer from './reducer';
import { MobileScrollActionTypes } from './actions';
import { setHeightDiff, setWindowHeight } from './commands';
/**
 * Plugin to help fix behaviour of scrolling on mobile devices:
 *
 * 1. Ensures selection is scrolled into view when keyboards are shown
 * 2. On iOS devices it ensures the user does not end up typing behind the on-screen keyboard
 *    The viewport height on iOS does not change if the keyboard is showing or not,
 *    it is always the full height. There is a bridge method which informs us of
 *    the current height taken up by the keyboard which works with this plugin to
 *    set the scroll margin/threshold to match
 *
 */
export var mobileScrollPluginKey = new PluginKey('mobileScroll');
// 44 pixels squared is the minimum size for a tap target as per Apple's UX design guidelines
export var MIN_TAP_SIZE_PX = 44;
var getInitialState = function () { return ({
    keyboardHeight: -1,
    heightDiff: -1,
    windowHeight: window.innerHeight,
}); };
var _a = pluginFactory(mobileScrollPluginKey, reducer), createPluginState = _a.createPluginState, getPluginState = _a.getPluginState, createCommand = _a.createCommand;
var createPlugin = function (dispatch) {
    var rafId;
    return new Plugin({
        state: createPluginState(dispatch, getInitialState),
        key: mobileScrollPluginKey,
        props: {
            scrollThreshold: undefined,
            scrollMargin: undefined,
            handleScrollToSelection: function (editorView) {
                // document.scrollingElement not supported in IE11, but as this is a plugin for iOS
                // only, we don't care
                // eslint-disable-next-line compat/compat
                var scrollElement = document.scrollingElement;
                if (!scrollElement) {
                    return false;
                }
                var _a = getPluginState(editorView.state), keyboardHeight = _a.keyboardHeight, heightDiff = _a.heightDiff;
                var newHeightDiff = scrollElement.clientHeight - window.innerHeight;
                if (heightDiff !== newHeightDiff) {
                    setHeightDiff(newHeightDiff)(editorView.state, editorView.dispatch);
                    updateScrollValues.call(this, keyboardHeight, newHeightDiff);
                }
                return false;
            },
        },
        appendTransaction: function (transactions, oldState, newState) {
            var scrollTr = transactions.find(function (tr) {
                var mobileScrollAction = tr.getMeta(mobileScrollPluginKey);
                return (mobileScrollAction &&
                    (mobileScrollAction.type ===
                        MobileScrollActionTypes.SET_KEYBOARD_HEIGHT ||
                        mobileScrollAction.type ===
                            MobileScrollActionTypes.SET_WINDOW_HEIGHT));
            });
            if (scrollTr) {
                var _a = getPluginState(oldState), keyboardHeight = _a.keyboardHeight, windowHeight = _a.windowHeight;
                var _b = getPluginState(newState), newKeyboardHeight = _b.keyboardHeight, heightDiff = _b.heightDiff, newWindowHeight = _b.windowHeight;
                if (keyboardHeight !== newKeyboardHeight) {
                    updateScrollValues.call(this, newKeyboardHeight, heightDiff);
                }
                // scroll selection into view if viewport is now smaller
                if (newWindowHeight < windowHeight) {
                    return newState.tr.scrollIntoView();
                }
            }
        },
        view: function (editorView) {
            var handleResize = function () {
                var windowInnerHeight = window.innerHeight;
                var count = 0;
                var checkWindowHeight = function () {
                    // wait for height to stabilise before we commit to set it
                    // this helps handle menu transitions in Android which we don't want to scroll for
                    if (window.innerHeight === windowInnerHeight) {
                        count++;
                        if (count >= 5) {
                            rafId = undefined;
                            setWindowHeight(window.innerHeight)(editorView.state, editorView.dispatch);
                        }
                        else {
                            rafId = requestAnimationFrame(checkWindowHeight);
                        }
                    }
                };
                rafId = requestAnimationFrame(checkWindowHeight);
            };
            // the window will resize on Android when the keyboard shows/hides
            window.addEventListener('resize', handleResize);
            return {
                destroy: function () {
                    window.removeEventListener('resize', handleResize);
                    if (rafId) {
                        window.cancelAnimationFrame(rafId);
                    }
                },
            };
        },
    });
};
/**
 * Update the scroll values on the plugin props
 * These are used by ProseMirror to determine when and how far it should scroll
 */
var updateScrollValues = function (keyboardHeight, heightDiff) {
    if (keyboardHeight === -1 || heightDiff === -1) {
        return;
    }
    var _a = calculateScrollValues(keyboardHeight, heightDiff), scrollThreshold = _a.scrollThreshold, scrollMargin = _a.scrollMargin;
    if (this.props) {
        this.props.scrollThreshold = scrollThreshold;
        this.props.scrollMargin = scrollMargin;
    }
};
var calculateScrollValues = function (keyboardHeight, heightDiff) { return ({
    scrollThreshold: {
        top: 0,
        bottom: keyboardHeight + MIN_TAP_SIZE_PX - heightDiff,
        left: 0,
        right: 0,
    },
    scrollMargin: {
        top: 5,
        bottom: keyboardHeight - heightDiff + MIN_TAP_SIZE_PX,
        left: 0,
        right: 0,
    },
}); };
var mobileScrollPlugin = function () { return ({
    name: 'mobileScroll',
    pmPlugins: function () {
        return [
            {
                name: 'mobileScroll',
                plugin: function (_a) {
                    var dispatch = _a.dispatch;
                    return createPlugin(dispatch);
                },
            },
        ];
    },
}); };
export default mobileScrollPlugin;
export { createCommand, getPluginState };
//# sourceMappingURL=index.js.map
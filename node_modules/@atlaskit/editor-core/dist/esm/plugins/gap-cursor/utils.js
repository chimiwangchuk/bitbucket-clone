import { TableCssClassName } from '../table/types';
import { closestElement } from '../../utils';
import { Side } from './selection';
export var isLeftCursor = function (side) {
    return side === Side.LEFT;
};
export function getMediaNearPos(doc, $pos, schema, dir) {
    if (dir === void 0) { dir = -1; }
    var $currentPos = $pos;
    var currentNode = null;
    var _a = schema.nodes, mediaSingle = _a.mediaSingle, media = _a.media, mediaGroup = _a.mediaGroup;
    do {
        $currentPos = doc.resolve(dir === -1 ? $currentPos.before() : $currentPos.after());
        if (!$currentPos) {
            return null;
        }
        currentNode =
            (dir === -1 ? $currentPos.nodeBefore : $currentPos.nodeAfter) ||
                $currentPos.parent;
        if (!currentNode || currentNode.type === schema.nodes.doc) {
            return null;
        }
        if (currentNode.type === mediaSingle ||
            currentNode.type === media ||
            currentNode.type === mediaGroup) {
            return currentNode;
        }
    } while ($currentPos.depth > 0);
    return null;
}
export var isTextBlockNearPos = function (doc, schema, $pos, dir) {
    var $currentPos = $pos;
    var currentNode = dir === -1 ? $currentPos.nodeBefore : $currentPos.nodeAfter;
    // If next node is a text or a text block bail out early.
    if (currentNode && (currentNode.isTextblock || currentNode.isText)) {
        return true;
    }
    while ($currentPos.depth > 0) {
        $currentPos = doc.resolve(dir === -1 ? $currentPos.before() : $currentPos.after());
        if (!$currentPos) {
            return false;
        }
        currentNode =
            (dir === -1 ? $currentPos.nodeBefore : $currentPos.nodeAfter) ||
                $currentPos.parent;
        if (!currentNode || currentNode.type === schema.nodes.doc) {
            return false;
        }
        if (currentNode.isTextblock) {
            return true;
        }
    }
    var childNode = currentNode;
    while (childNode && childNode.firstChild) {
        childNode = childNode.firstChild;
        if (childNode && (childNode.isTextblock || childNode.isText)) {
            return true;
        }
    }
    return false;
};
export function getBreakoutModeFromTargetNode(node) {
    var layout;
    if (node.attrs.layout) {
        layout = node.attrs.layout;
    }
    if (node.marks && node.marks.length) {
        layout = (node.marks.find(function (mark) { return mark.type.name === 'breakout'; }) || {
            attrs: { mode: '' },
        }).attrs.mode;
    }
    if (['wide', 'full-width'].indexOf(layout) === -1) {
        return '';
    }
    return layout;
}
export var isIgnoredClick = function (elem) {
    if (elem.nodeName === 'BUTTON' || closestElement(elem, 'button')) {
        return true;
    }
    // check if target node has a parent table node
    var tableWrap;
    var node = elem;
    while (node) {
        if (node.className &&
            (node.getAttribute('class') || '').indexOf(TableCssClassName.TABLE_CONTAINER) > -1) {
            tableWrap = node;
            break;
        }
        node = node.parentNode;
    }
    if (tableWrap) {
        var rowControls = tableWrap.querySelector("." + TableCssClassName.ROW_CONTROLS_WRAPPER);
        var isColumnControlsDecoration = elem &&
            elem.classList &&
            elem.classList.contains(TableCssClassName.COLUMN_CONTROLS_DECORATIONS);
        return ((rowControls && rowControls.contains(elem)) || isColumnControlsDecoration);
    }
    return false;
};
//# sourceMappingURL=utils.js.map
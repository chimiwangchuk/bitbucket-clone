import { __assign, __awaiter, __generator } from "tslib";
import { Plugin, PluginKey } from 'prosemirror-state';
import { pluginFactory } from '../../../utils/plugin-state-factory';
import { AnnotationNodeView } from '../ui';
import { getAllAnnotations } from '../utils';
import { setInlineCommentState } from '../commands';
export var pluginKey = new PluginKey('inlineCommentPlugin');
function reducer(pluginState, action) {
    var _a;
    switch (action.type) {
        case 'INLINE_COMMENT_RESOLVE':
            return __assign(__assign({}, pluginState), (_a = {}, _a[action.data.id] = true, _a));
        case 'SET_INLINE_COMMENT_STATE':
            return action.data;
        default:
            return pluginState;
    }
}
var fetchProviderAnnotationStates = function (provider, annotationIds) { return __awaiter(void 0, void 0, void 0, function () {
    var data, result;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, provider.getState(annotationIds)];
            case 1:
                data = _a.sent();
                result = {};
                data.forEach(function (annotation) {
                    if (annotation.annotationType === 'inlineComment') {
                        result[annotation.id] = annotation.state.resolved;
                    }
                });
                return [2 /*return*/, result];
        }
    });
}); };
var fetchInlineCommentStates = function (provider, annotationIds) {
    return fetchProviderAnnotationStates(provider, annotationIds);
};
export var getPluginState = function (state) {
    return pluginKey.getState(state);
};
function fetchState(provider, annotationIds, state, dispatch) {
    return function () {
        return __awaiter(this, void 0, void 0, function () {
            var inlineCommentStates;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fetchInlineCommentStates(provider, annotationIds)];
                    case 1:
                        inlineCommentStates = _a.sent();
                        if (dispatch) {
                            setInlineCommentState(inlineCommentStates)(state, dispatch);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
}
var _a = pluginFactory(pluginKey, reducer), createPluginState = _a.createPluginState, createCommand = _a.createCommand;
export var inlineCommentPlugin = function (options) {
    var inlineCommentProvider = options.inlineCommentProvider, dispatch = options.dispatch, portalProviderAPI = options.portalProviderAPI, pollingInterval = options.pollingInterval;
    return new Plugin({
        key: pluginKey,
        state: createPluginState(dispatch, {}),
        view: function (editorView) {
            // Get initial state
            fetchState(inlineCommentProvider, getAllAnnotations(editorView.state.doc), editorView.state, editorView.dispatch)();
            var timerId = setInterval(function () {
                fetchState(inlineCommentProvider, getAllAnnotations(editorView.state.doc), editorView.state, editorView.dispatch)();
            }, pollingInterval || 10000);
            return {
                destroy: function () {
                    clearInterval(timerId);
                },
            };
        },
        props: {
            nodeViews: {
                annotation: function (node, view, getPos) {
                    return new AnnotationNodeView(node, view, getPos, portalProviderAPI).init();
                },
            },
        },
    });
};
export { createCommand };
//# sourceMappingURL=inline-comment.js.map
import React from 'react';
import { findDomRefAtPos } from 'prosemirror-utils';
import { annotation } from '@atlaskit/adf-schema';
import WithPluginState from '../../ui/WithPluginState';
import { stateKey as reactPluginKey } from '../../plugins/base/pm-plugins/react-nodeview';
import { pluginKey as inlineCommentPluginKey } from './pm-plugins/inline-comment';
import { reorderAnnotations } from './utils';
import { removeInlineCommentNearSelection, resolveInlineComment, } from './commands';
import { inlineCommentPlugin, getPluginState, } from './pm-plugins/inline-comment';
var annotationPlugin = function (annotationProvider) {
    return {
        name: 'annotation',
        marks: function () {
            return [
                {
                    name: 'annotation',
                    mark: annotation,
                },
            ];
        },
        pmPlugins: function () { return [
            {
                name: 'annotation',
                plugin: function (_a) {
                    var dispatch = _a.dispatch, portalProviderAPI = _a.portalProviderAPI;
                    return annotationProvider &&
                        annotationProvider.providers &&
                        annotationProvider.providers.inlineComment
                        ? inlineCommentPlugin({
                            dispatch: dispatch,
                            portalProviderAPI: portalProviderAPI,
                            inlineCommentProvider: annotationProvider.providers.inlineComment,
                            pollingInterval: annotationProvider.providers.inlineComment.pollingInterval,
                        })
                        : undefined;
                },
            },
        ]; },
        contentComponent: function (_a) {
            var editorView = _a.editorView;
            var annotationMarkType = editorView.state.schema.marks.annotation;
            if (!annotationProvider) {
                return null;
            }
            var Component = annotationProvider.component, providers = annotationProvider.providers;
            if (!Component || !providers || !providers.inlineComment) {
                return null;
            }
            return (React.createElement(WithPluginState, { plugins: {
                    selectionState: reactPluginKey,
                    annotationState: inlineCommentPluginKey,
                }, render: function () {
                    var state = editorView.state, dispatch = editorView.dispatch;
                    var _a = state.selection, from = _a.from, $from = _a.$from;
                    var node = state.doc.nodeAt(from);
                    if (!node) {
                        return null;
                    }
                    var annotationsMarks = node.marks.filter(function (mark) { return mark.type === annotationMarkType; });
                    if (!annotationsMarks.length) {
                        return null;
                    }
                    var annotations = annotationsMarks.map(function (mark) {
                        return {
                            id: mark.attrs.id,
                            type: mark.attrs.annotationType,
                        };
                    });
                    var inlineCommentState = getPluginState(state);
                    // This is currently specific to inlineComments. In future this will need to check all providers, not just one.
                    annotations = annotations.filter(function (mark) { return inlineCommentState[mark.id] === false; });
                    if (!annotations.length) {
                        return null;
                    }
                    // re-order to handle nested annotations
                    reorderAnnotations(annotations, $from);
                    var dom = findDomRefAtPos(from, editorView.domAtPos.bind(editorView));
                    return (React.createElement(Component, { annotations: annotations, dom: dom, onDelete: function (id) {
                            return removeInlineCommentNearSelection(id)(state, dispatch);
                        }, onResolve: function (id) {
                            return resolveInlineComment(id)(state, dispatch);
                        } }));
                } }));
        },
    };
};
export default annotationPlugin;
//# sourceMappingURL=index.js.map
import React from 'react';
import ReactDOM from 'react-dom';
import { Selection } from 'prosemirror-state';
import { ExpandIconButton } from '../ui/ExpandIconButton';
import { keyName } from 'w3c-keyname';
import { DOMSerializer, } from 'prosemirror-model';
import { expandMessages } from '@atlaskit/editor-common';
import { closestElement, isEmptyNode } from '../../../utils';
import { updateExpandTitle, toggleExpandExpanded, selectExpand, deleteExpandAtPos, } from '../commands';
import { expandClassNames } from '../ui/class-names';
import { GapCursorSelection, Side } from '../../../plugins/gap-cursor';
import { getFeatureFlags } from '../../feature-flags-context';
function buildExpandClassName(type, expanded) {
    return expandClassNames.prefix + " " + expandClassNames.type(type) + " " + (expanded ? expandClassNames.expanded : '');
}
var toDOM = function (node, intl) { return [
    'div',
    {
        // prettier-ignore
        'class': buildExpandClassName(node.type.name, node.attrs.__expanded),
        'data-node-type': node.type.name,
        'data-title': node.attrs.title,
    },
    [
        'div',
        {
            // prettier-ignore
            'class': expandClassNames.titleContainer,
            contenteditable: 'false',
            // Element gains access to focus events.
            // This is needed to prevent PM gaining access
            // on interacting with our controls.
            tabindex: '-1',
        },
        // prettier-ignore
        ['div', { 'class': expandClassNames.icon }],
        [
            'div',
            {
                // prettier-ignore
                'class': expandClassNames.inputContainer
            },
            [
                'input',
                {
                    // prettier-ignore
                    'class': expandClassNames.titleInput,
                    value: node.attrs.title,
                    placeholder: (intl &&
                        intl.formatMessage(expandMessages.expandPlaceholderText)) ||
                        expandMessages.expandPlaceholderText.defaultMessage,
                    type: 'text',
                },
            ],
        ],
    ],
    // prettier-ignore
    ['div', { 'class': expandClassNames.content }, 0],
]; };
var ExpandNodeView = /** @class */ (function () {
    function ExpandNodeView(node, view, getPos, reactContext) {
        var _this = this;
        this.allowInteractiveExpand = true;
        this.focusTitle = function () {
            if (_this.input) {
                _this.input.focus();
            }
        };
        this.handleIconKeyDown = function (event) {
            switch (keyName(event)) {
                case 'Tab':
                    event.preventDefault();
                    _this.focusTitle();
                    break;
                case 'Enter':
                    event.preventDefault();
                    _this.handleClick(event);
                    break;
            }
        };
        this.isAllowInteractiveExpandEnabled = function () {
            var state = _this.view.state;
            var featureFlags = getFeatureFlags(state);
            return featureFlags && !!featureFlags.interactiveExpand;
        };
        this.handleClick = function (event) {
            var target = event.target;
            if (closestElement(target, "." + expandClassNames.icon)) {
                if (!_this.isAllowInteractiveExpandEnabled()) {
                    return;
                }
                event.stopPropagation();
                var _a = _this.view, state = _a.state, dispatch = _a.dispatch;
                // We blur the editorView, to prevent any keyboard showing on mobile
                // When we're interacting with the expand toggle
                if (_this.view.dom instanceof HTMLElement) {
                    _this.view.dom.blur();
                }
                toggleExpandExpanded(_this.getPos(), _this.node.type)(state, dispatch);
                return;
            }
            if (target === _this.dom) {
                event.stopPropagation();
                var _b = _this.view, state = _b.state, dispatch = _b.dispatch;
                selectExpand(_this.getPos())(state, dispatch);
                return;
            }
        };
        this.handleInput = function (event) {
            var target = event.target;
            if (target === _this.input) {
                event.stopPropagation();
                var _a = _this.view, state = _a.state, dispatch = _a.dispatch;
                updateExpandTitle(target.value, _this.getPos(), _this.node.type)(state, dispatch);
            }
        };
        this.handleFocus = function (event) {
            event.stopImmediatePropagation();
        };
        this.handleTitleKeydown = function (event) {
            switch (keyName(event)) {
                case 'Enter':
                    _this.toggleExpand();
                    break;
                case 'Tab':
                case 'ArrowDown':
                    _this.moveToOutsideOfTitle(event);
                    break;
                case 'ArrowRight':
                    _this.setRightGapCursor(event);
                    break;
                case 'ArrowLeft':
                case 'ArrowUp':
                    _this.setLeftGapCursor(event);
                    break;
                case 'Backspace':
                    _this.deleteExpand(event);
                    break;
            }
        };
        this.deleteExpand = function (event) {
            if (!_this.input) {
                return;
            }
            var _a = _this.input, selectionStart = _a.selectionStart, selectionEnd = _a.selectionEnd;
            if (selectionStart !== selectionEnd || selectionStart !== 0) {
                return;
            }
            var state = _this.view.state;
            var expandNode = _this.node;
            if (expandNode && isEmptyNode(state.schema)(expandNode)) {
                deleteExpandAtPos(_this.getPos(), expandNode)(state, _this.view.dispatch);
            }
        };
        this.toggleExpand = function () {
            if (_this.isAllowInteractiveExpandEnabled()) {
                var _a = _this.view, state = _a.state, dispatch = _a.dispatch;
                toggleExpandExpanded(_this.getPos(), _this.node.type)(state, dispatch);
            }
        };
        this.moveToOutsideOfTitle = function (event) {
            event.preventDefault();
            var _a = _this.view, state = _a.state, dispatch = _a.dispatch;
            var expandPos = _this.getPos();
            if (typeof expandPos !== 'number') {
                return;
            }
            var pos = expandPos;
            if (_this.isCollapsed()) {
                pos = expandPos + _this.node.nodeSize;
            }
            var resolvedPos = state.doc.resolve(pos);
            if (!resolvedPos) {
                return;
            }
            if (_this.isCollapsed() &&
                resolvedPos.nodeAfter &&
                ['expand', 'nestedExpand'].indexOf(resolvedPos.nodeAfter.type.name) > -1) {
                return _this.setRightGapCursor(event);
            }
            var sel = Selection.findFrom(resolvedPos, 1, true);
            if (sel) {
                // If the input has focus, ProseMirror doesn't
                // Give PM focus back before changing our selection
                _this.view.focus();
                dispatch(state.tr.setSelection(sel));
            }
        };
        this.isCollapsed = function () {
            return !_this.node.attrs.__expanded;
        };
        this.setRightGapCursor = function (event) {
            if (!_this.input) {
                return;
            }
            var _a = _this.input, value = _a.value, selectionStart = _a.selectionStart, selectionEnd = _a.selectionEnd;
            if (selectionStart === selectionEnd && selectionStart === value.length) {
                var _b = _this.view, state = _b.state, dispatch = _b.dispatch;
                event.preventDefault();
                _this.view.focus();
                dispatch(state.tr.setSelection(new GapCursorSelection(state.doc.resolve(_this.node.nodeSize + _this.getPos()), Side.RIGHT)));
            }
        };
        this.setLeftGapCursor = function (event) {
            if (!_this.input) {
                return;
            }
            var _a = _this.input, selectionStart = _a.selectionStart, selectionEnd = _a.selectionEnd;
            if (selectionStart === selectionEnd && selectionStart === 0) {
                event.preventDefault();
                var _b = _this.view, state = _b.state, dispatch = _b.dispatch;
                _this.view.focus();
                dispatch(state.tr.setSelection(new GapCursorSelection(state.doc.resolve(_this.getPos()), Side.LEFT)));
            }
        };
        this.reactContext = reactContext() || {};
        var _a = DOMSerializer.renderSpec(document, toDOM(node, this.reactContext.intl)), dom = _a.dom, contentDOM = _a.contentDOM;
        this.getPos = getPos;
        this.pos = getPos();
        this.view = view;
        this.node = node;
        this.view = view;
        this.dom = dom;
        this.contentDOM = contentDOM;
        this.icon = this.dom.querySelector("." + expandClassNames.icon);
        this.input = this.dom.querySelector("." + expandClassNames.titleInput);
        this.titleContainer = this.dom.querySelector("." + expandClassNames.titleContainer);
        this.content = this.dom.querySelector("." + expandClassNames.content);
        this.renderIcon(this.reactContext.intl);
        this.initHandlers();
    }
    ExpandNodeView.prototype.initHandlers = function () {
        if (this.dom) {
            this.dom.addEventListener('click', this.handleClick);
            this.dom.addEventListener('input', this.handleInput);
        }
        if (this.input) {
            this.input.addEventListener('keydown', this.handleTitleKeydown);
        }
        if (this.titleContainer) {
            // If the user interacts in our title bar (either toggle or input)
            // Prevent ProseMirror from getting a focus event (causes weird selection issues).
            this.titleContainer.addEventListener('focus', this.handleFocus);
        }
        if (this.icon) {
            this.icon.addEventListener('keydown', this.handleIconKeyDown);
        }
    };
    ExpandNodeView.prototype.renderIcon = function (intl, node) {
        if (!this.icon) {
            return;
        }
        var __expanded = ((node && node.attrs) || this.node.attrs).__expanded;
        ReactDOM.render(React.createElement(ExpandIconButton, { allowInteractiveExpand: this.isAllowInteractiveExpandEnabled(), expanded: __expanded }), this.icon);
    };
    ExpandNodeView.prototype.stopEvent = function (event) {
        var target = event.target;
        return (target === this.input ||
            target === this.icon ||
            !!closestElement(target, "." + expandClassNames.icon));
    };
    ExpandNodeView.prototype.ignoreMutation = function () {
        return true;
    };
    ExpandNodeView.prototype.update = function (node, _decorations) {
        var _this = this;
        if (this.node.type === node.type) {
            if (this.node.attrs.__expanded !== node.attrs.__expanded) {
                // Instead of re-rendering the view on an expand toggle
                // we toggle a class name to hide the content and animate the chevron.
                if (this.dom) {
                    this.dom.classList.toggle(expandClassNames.expanded);
                    this.renderIcon(this.reactContext && this.reactContext.intl, node);
                }
                if (this.content) {
                    // Disallow interaction/selection inside when collapsed.
                    this.content.setAttribute('contenteditable', node.attrs.__expanded);
                }
            }
            // During a collab session the title doesn't sync with other users
            // since we're intentionally being less aggressive about re-rendering.
            // We also apply a rAF to avoid abrupt continuous replacement of the title.
            window.requestAnimationFrame(function () {
                if (_this.input && _this.node.attrs.title !== _this.input.value) {
                    _this.input.value = _this.node.attrs.title;
                }
            });
            this.node = node;
            return true;
        }
        return false;
    };
    ExpandNodeView.prototype.destroy = function () {
        if (this.dom) {
            this.dom.removeEventListener('click', this.handleClick);
            this.dom.removeEventListener('input', this.handleInput);
        }
        if (this.input) {
            this.input.removeEventListener('keydown', this.handleTitleKeydown);
        }
        if (this.titleContainer) {
            this.titleContainer.removeEventListener('focus', this.handleFocus);
        }
        if (this.icon) {
            this.icon.removeEventListener('keydown', this.handleIconKeyDown);
            ReactDOM.unmountComponentAtNode(this.icon);
        }
        this.dom = undefined;
        this.contentDOM = undefined;
        this.icon = undefined;
        this.input = undefined;
        this.titleContainer = undefined;
        this.content = undefined;
    };
    return ExpandNodeView;
}());
export { ExpandNodeView };
export default function (reactContext) {
    return function (node, view, getPos) {
        return new ExpandNodeView(node, view, getPos, reactContext);
    };
}
//# sourceMappingURL=index.js.map
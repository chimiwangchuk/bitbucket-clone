import { keymap } from 'prosemirror-keymap';
import { Selection, TextSelection, NodeSelection, } from 'prosemirror-state';
import * as keymaps from '../../../keymaps';
import { GapCursorSelection, Side } from '../../gap-cursor';
import { findExpand } from '../utils';
import { findTypeAheadQuery } from '../../type-ahead/utils/find-query-mark';
import { isEmptyNode } from '../../../utils';
import { expandClassNames } from '../ui/class-names';
import { deleteExpand } from '../commands';
var focusTitle = function (view, pos) {
    var dom = view.domAtPos(pos);
    var expandWrapper = dom.node.parentElement;
    if (expandWrapper) {
        var input = expandWrapper.querySelector('input');
        if (input) {
            input.focus();
            return true;
        }
    }
    return false;
};
export function expandKeymap() {
    var list = {};
    keymaps.bindKeymapWithCommand(keymaps.moveRight.common, function (state, _dispatch, editorView) {
        if (!editorView) {
            return false;
        }
        var selection = state.selection;
        var nodeAfter = selection.$from.nodeAfter;
        var _a = state.schema.nodes, expand = _a.expand, nestedExpand = _a.nestedExpand;
        if (selection instanceof GapCursorSelection &&
            selection.side === Side.LEFT &&
            nodeAfter &&
            (nodeAfter.type === expand || nodeAfter.type === nestedExpand)) {
            var $from = selection.$from;
            return focusTitle(editorView, $from.pos + 1);
        }
        return false;
    }, list);
    keymaps.bindKeymapWithCommand(keymaps.moveLeft.common, function (state, _dispatch, editorView) {
        if (!editorView) {
            return false;
        }
        var selection = state.selection;
        var nodeBefore = selection.$from.nodeBefore;
        var _a = state.schema.nodes, expand = _a.expand, nestedExpand = _a.nestedExpand;
        if (selection instanceof GapCursorSelection &&
            selection.side === Side.RIGHT &&
            nodeBefore &&
            (nodeBefore.type === expand || nodeBefore.type === nestedExpand)) {
            var $from = selection.$from;
            return focusTitle(editorView, Math.max($from.pos - 1, 0));
        }
        return false;
    }, list);
    keymaps.bindKeymapWithCommand(keymaps.tab.common, function (state, dispatch, editorView) {
        var $nodeAfter = state.selection.$from.nodeAfter;
        if (state.selection instanceof GapCursorSelection &&
            state.selection.side === Side.LEFT &&
            $nodeAfter &&
            $nodeAfter.type === state.schema.nodes.expand &&
            editorView) {
            var tr = state.tr;
            var pos = state.selection.from;
            tr.setSelection(new NodeSelection(tr.doc.resolve(pos)));
            if (dispatch) {
                dispatch(tr);
            }
            return true;
        }
        if (state.selection instanceof NodeSelection &&
            state.selection.node.type === state.schema.nodes.expand &&
            editorView &&
            editorView.dom instanceof HTMLElement) {
            var from = state.selection.from;
            var expand = editorView.nodeDOM(from);
            if (!expand || !(expand instanceof HTMLElement)) {
                return false;
            }
            var iconContainer = expand.querySelector("." + expandClassNames.iconContainer);
            if (iconContainer && iconContainer.focus) {
                var tr = state.tr;
                var pos = state.selection.from;
                tr.setSelection(new TextSelection(tr.doc.resolve(pos)));
                if (dispatch) {
                    dispatch(tr);
                }
                editorView.dom.blur();
                iconContainer.focus();
            }
            return true;
        }
        return false;
    }, list);
    keymaps.bindKeymapWithCommand(keymaps.moveUp.common, function (state, dispatch, editorView) {
        var queryMark = findTypeAheadQuery(state);
        if ((queryMark.start !== -1 && queryMark.end !== -1) || !editorView) {
            return false;
        }
        var selection = state.selection, schema = state.schema;
        var nodeBefore = selection.$from.nodeBefore;
        if (selection instanceof GapCursorSelection &&
            selection.side === Side.RIGHT &&
            nodeBefore &&
            (nodeBefore.type === schema.nodes.expand ||
                nodeBefore.type === schema.nodes.nestedExpand) &&
            !nodeBefore.attrs.__expanded) {
            var $from_1 = selection.$from;
            return focusTitle(editorView, Math.max($from_1.pos - 1, 0));
        }
        var $from = state.selection.$from;
        if (editorView.endOfTextblock('up')) {
            var expand = findExpand(state);
            var prevCursorPos = Math.max($from.pos - $from.parentOffset - 1, 0);
            // move cursor from expand's content to its title
            if (expand && expand.start === prevCursorPos) {
                return focusTitle(editorView, expand.start);
            }
            var sel = Selection.findFrom(state.doc.resolve(prevCursorPos), -1);
            var expandBefore = findExpand(state, sel);
            if (sel && expandBefore) {
                // moving cursor from outside of an expand to the title when it is collapsed
                if (!expandBefore.node.attrs.__expanded) {
                    return focusTitle(editorView, expandBefore.start);
                }
                // moving cursor from outside of an expand to the content when it is expanded
                else if (dispatch) {
                    dispatch(state.tr.setSelection(sel));
                }
                return true;
            }
        }
        return false;
    }, list);
    keymaps.bindKeymapWithCommand(keymaps.moveDown.common, function (state, dispatch, editorView) {
        if (!editorView) {
            return false;
        }
        var _a = state.schema.nodes, expand = _a.expand, nestedExpand = _a.nestedExpand;
        var selection = state.selection;
        var nodeAfter = selection.$from.nodeAfter;
        if (selection instanceof GapCursorSelection &&
            selection.side === Side.LEFT &&
            nodeAfter &&
            (nodeAfter.type === expand || nodeAfter.type === nestedExpand) &&
            !nodeAfter.attrs.__expanded) {
            var $from = selection.$from;
            return focusTitle(editorView, $from.pos + 1);
        }
        if (editorView.endOfTextblock('down')) {
            var $from = state.selection.$from;
            var $after = state.doc.resolve($from.after());
            if ($after.nodeAfter &&
                ($after.nodeAfter.type === expand ||
                    $after.nodeAfter.type === nestedExpand)) {
                return focusTitle(editorView, $after.pos + 1);
            }
        }
        return false;
    }, list);
    keymaps.bindKeymapWithCommand(keymaps.backspace.common, function (state, dispatch, editorView) {
        var selection = state.selection;
        if (!editorView || !selection.empty) {
            return false;
        }
        var _a = state.schema.nodes, expand = _a.expand, nestedExpand = _a.nestedExpand;
        var expandNode = findExpand(state);
        if (!expandNode) {
            // @see ED-7977
            var sel = Selection.findFrom(state.doc.resolve(Math.max(selection.$from.pos - 1, 0)), -1);
            var expandBefore = findExpand(state, sel);
            if (expandBefore &&
                (expandBefore.node.type === expand ||
                    expandBefore.node.type === nestedExpand) &&
                !expandBefore.node.attrs.__expanded) {
                return focusTitle(editorView, expandBefore.start);
            }
            return false;
        }
        var textSel = Selection.findFrom(state.doc.resolve(expandNode.pos), 1, true);
        if (textSel &&
            selection.$from.pos === textSel.$from.pos &&
            isEmptyNode(state.schema)(expandNode.node) &&
            dispatch) {
            return deleteExpand()(state, dispatch);
        }
        return false;
    }, list);
    return keymap(list);
}
//# sourceMappingURL=keymap.js.map
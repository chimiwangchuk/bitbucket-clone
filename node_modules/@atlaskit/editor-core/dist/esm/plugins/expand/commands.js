import { __assign } from "tslib";
import { NodeSelection } from 'prosemirror-state';
import { safeInsert, findTable } from 'prosemirror-utils';
import { createCommand } from './pm-plugins/main';
import { findExpand } from './utils';
import { addAnalytics, ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, INPUT_METHOD, EVENT_TYPE, PLATFORMS, MODE, } from '../analytics';
import { GapCursorSelection, Side } from '../gap-cursor';
export var setExpandRef = function (ref) {
    return createCommand({
        type: 'SET_EXPAND_REF',
        data: {
            ref: ref,
        },
    }, function (tr) { return tr.setMeta('addToHistory', false); });
};
export var deleteExpandAtPos = function (expandNodePos, expandNode) { return function (state, dispatch) {
    if (!expandNode || isNaN(expandNodePos)) {
        return false;
    }
    var payload = {
        action: ACTION.DELETED,
        actionSubject: expandNode.type === state.schema.nodes.expand
            ? ACTION_SUBJECT.EXPAND
            : ACTION_SUBJECT.NESTED_EXPAND,
        attributes: { inputMethod: INPUT_METHOD.TOOLBAR },
        eventType: EVENT_TYPE.TRACK,
    };
    if (expandNode && dispatch) {
        dispatch(addAnalytics(state, state.tr.delete(expandNodePos, expandNodePos + expandNode.nodeSize), payload));
    }
    return true;
}; };
export var deleteExpand = function () { return function (state, dispatch) {
    var expandNode = findExpand(state);
    if (!expandNode) {
        return false;
    }
    return deleteExpandAtPos(expandNode.pos, expandNode.node)(state, dispatch);
}; };
export var selectExpand = function (pos) { return function (state, dispatch) {
    if (dispatch) {
        dispatch(state.tr.setSelection(new NodeSelection(state.doc.resolve(pos))));
    }
    return true;
}; };
export var updateExpandTitle = function (title, pos, nodeType) { return function (state, dispatch) {
    var node = state.doc.nodeAt(pos);
    if (node && node.type === nodeType && dispatch) {
        var tr = state.tr;
        tr.setNodeMarkup(pos, node.type, __assign(__assign({}, node.attrs), { title: title }), node.marks);
        dispatch(tr);
    }
    return true;
}; };
export var toggleExpandExpanded = function (pos, nodeType) { return function (state, dispatch) {
    var node = state.doc.nodeAt(pos);
    if (node && node.type === nodeType && dispatch) {
        var tr = state.tr;
        var isExpandedNext = !node.attrs.__expanded;
        tr.setNodeMarkup(pos, node.type, __assign(__assign({}, node.attrs), { __expanded: isExpandedNext }), node.marks);
        // If we're going to collapse the expand and our cursor is currently inside
        // Move to a right gap cursor, if the toolbar is interacted (or an API),
        // it will insert below rather than inside (which will be invisible).
        if (isExpandedNext === false && findExpand(state)) {
            tr.setSelection(new GapCursorSelection(state.doc.resolve(pos + node.nodeSize), Side.RIGHT));
        }
        // log when people open/close expands
        // TODO: ED-8523 make platform/mode global attributes?
        var payload = {
            action: ACTION.TOGGLE_EXPAND,
            actionSubject: nodeType === state.schema.nodes.expand
                ? ACTION_SUBJECT.EXPAND
                : ACTION_SUBJECT.NESTED_EXPAND,
            attributes: {
                platform: PLATFORMS.WEB,
                mode: MODE.EDITOR,
                expanded: isExpandedNext,
            },
            eventType: EVENT_TYPE.TRACK,
        };
        // `isRemote` meta prevents this step from being
        // sync'd between sessions in collab edit
        dispatch(addAnalytics(state, tr.setMeta('isRemote', true), payload));
    }
    return true;
}; };
export var createExpandNode = function (state) {
    var _a = state.schema.nodes, expand = _a.expand, nestedExpand = _a.nestedExpand;
    var expandType = findTable(state.selection) ? nestedExpand : expand;
    return expandType.createAndFill({});
};
export var insertExpand = function (state, dispatch) {
    var expandNode = createExpandNode(state);
    var payload = {
        action: ACTION.INSERTED,
        actionSubject: ACTION_SUBJECT.DOCUMENT,
        actionSubjectId: expandNode.type === state.schema.nodes.expand
            ? ACTION_SUBJECT_ID.EXPAND
            : ACTION_SUBJECT_ID.NESTED_EXPAND,
        attributes: { inputMethod: INPUT_METHOD.INSERT_MENU },
        eventType: EVENT_TYPE.TRACK,
    };
    if (dispatch) {
        dispatch(addAnalytics(state, safeInsert(expandNode)(state.tr).scrollIntoView(), payload));
    }
    return true;
};
//# sourceMappingURL=commands.js.map
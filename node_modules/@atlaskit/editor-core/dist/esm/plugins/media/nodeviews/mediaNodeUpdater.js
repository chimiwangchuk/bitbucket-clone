import { __awaiter, __generator } from "tslib";
import uuidV4 from 'uuid/v4';
import { DEFAULT_IMAGE_HEIGHT, DEFAULT_IMAGE_WIDTH, } from '@atlaskit/editor-common';
import { getMediaClient, isMediaBlobUrl, getAttrsFromUrl, } from '@atlaskit/media-client';
import { ACTION, ACTION_SUBJECT, EVENT_TYPE, } from '../../analytics';
import { replaceExternalMedia, updateAllMediaNodesAttrs, updateMediaNodeAttrs, } from '../commands/helpers';
var MediaNodeUpdater = /** @class */ (function () {
    function MediaNodeUpdater(props) {
        var _this = this;
        // Updates the node with contextId if it doesn't have one already
        // TODO [MS-2258]: remove updateContextId in order to only use updateFileAttrs
        this.updateContextId = function () { return __awaiter(_this, void 0, void 0, function () {
            var attrs, id, objectId;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        attrs = this.getAttrs();
                        if (!attrs || attrs.type !== 'file') {
                            return [2 /*return*/];
                        }
                        id = attrs.id;
                        return [4 /*yield*/, this.getObjectId()];
                    case 1:
                        objectId = _a.sent();
                        updateAllMediaNodesAttrs(id, {
                            __contextId: objectId,
                        }, this.props.isMediaSingle)(this.props.view.state, this.props.view.dispatch);
                        return [2 /*return*/];
                }
            });
        }); };
        this.hasFileAttributesDefined = function () {
            var attrs = _this.getAttrs();
            return (attrs &&
                attrs.type === 'file' &&
                attrs.__fileName &&
                attrs.__fileMimeType &&
                attrs.__fileSize &&
                attrs.__contextId);
        };
        this.updateFileAttrs = function (isMediaSingle) {
            if (isMediaSingle === void 0) { isMediaSingle = true; }
            return __awaiter(_this, void 0, void 0, function () {
                var attrs, mediaProvider, mediaClientConfig, mediaClient, options, fileState, contextId, _a, name, mimeType, size, newAttrs, attrsChanged;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            attrs = this.getAttrs();
                            return [4 /*yield*/, this.props.mediaProvider];
                        case 1:
                            mediaProvider = _b.sent();
                            if (!mediaProvider ||
                                !mediaProvider.uploadParams ||
                                !attrs ||
                                attrs.type !== 'file' ||
                                this.hasFileAttributesDefined()) {
                                return [2 /*return*/];
                            }
                            mediaClientConfig = mediaProvider.viewMediaClientConfig;
                            mediaClient = getMediaClient(mediaClientConfig);
                            options = {
                                collectionName: attrs.collection,
                            };
                            return [4 /*yield*/, mediaClient.file.getCurrentState(attrs.id, options)];
                        case 2:
                            fileState = _b.sent();
                            if (fileState.status === 'error') {
                                return [2 /*return*/];
                            }
                            _a = this.getNodeContextId();
                            if (_a) return [3 /*break*/, 4];
                            return [4 /*yield*/, this.getObjectId()];
                        case 3:
                            _a = (_b.sent());
                            _b.label = 4;
                        case 4:
                            contextId = _a;
                            name = fileState.name, mimeType = fileState.mimeType, size = fileState.size;
                            newAttrs = {
                                __fileName: name,
                                __fileMimeType: mimeType,
                                __fileSize: size,
                                __contextId: contextId,
                            };
                            attrsChanged = hasPrivateAttrsChanged(attrs, newAttrs);
                            if (attrsChanged) {
                                // TODO [MS-2258]: we should pass this.props.isMediaSingle and remove hardcoded "true"
                                updateAllMediaNodesAttrs(attrs.id, newAttrs, isMediaSingle)(this.props.view.state, this.props.view.dispatch);
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        this.getAttrs = function () {
            var attrs = _this.props.node.attrs;
            if (attrs) {
                return attrs;
            }
            return undefined;
        };
        this.getObjectId = function () { return __awaiter(_this, void 0, void 0, function () {
            var contextIdentifierProvider;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.props
                            .contextIdentifierProvider];
                    case 1:
                        contextIdentifierProvider = _a.sent();
                        return [2 /*return*/, contextIdentifierProvider && contextIdentifierProvider.objectId];
                }
            });
        }); };
        this.uploadExternalMedia = function (pos) { return __awaiter(_this, void 0, void 0, function () {
            var node, mediaProvider, uploadMediaClientConfig, mediaClient, collection, uploader, uploadableFileUpfrontIds, dimensions, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        node = this.props.node;
                        return [4 /*yield*/, this.props.mediaProvider];
                    case 1:
                        mediaProvider = _a.sent();
                        if (!(node && mediaProvider)) return [3 /*break*/, 5];
                        uploadMediaClientConfig = mediaProvider.uploadMediaClientConfig;
                        if (!uploadMediaClientConfig || !node.attrs.url) {
                            return [2 /*return*/];
                        }
                        mediaClient = getMediaClient(uploadMediaClientConfig);
                        collection = mediaProvider.uploadParams && mediaProvider.uploadParams.collection;
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, mediaClient.file.uploadExternal(node.attrs.url, collection)];
                    case 3:
                        uploader = _a.sent();
                        uploadableFileUpfrontIds = uploader.uploadableFileUpfrontIds, dimensions = uploader.dimensions;
                        replaceExternalMedia(pos + 1, {
                            id: uploadableFileUpfrontIds.id,
                            collection: collection,
                            height: dimensions.height,
                            width: dimensions.width,
                            occurrenceKey: uploadableFileUpfrontIds.occurrenceKey,
                        })(this.props.view.state, this.props.view.dispatch);
                        return [3 /*break*/, 5];
                    case 4:
                        e_1 = _a.sent();
                        //keep it as external media
                        if (this.props.dispatchAnalyticsEvent) {
                            this.props.dispatchAnalyticsEvent({
                                action: ACTION.UPLOAD_EXTERNAL_FAIL,
                                actionSubject: ACTION_SUBJECT.EDITOR,
                                eventType: EVENT_TYPE.OPERATIONAL,
                            });
                        }
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/];
                }
            });
        }); };
        this.getNodeContextId = function () {
            var attrs = _this.getAttrs();
            if (!attrs || attrs.type !== 'file') {
                return undefined;
            }
            return attrs.__contextId;
        };
        this.updateDimensions = function (dimensions) {
            updateAllMediaNodesAttrs(dimensions.id, {
                height: dimensions.height,
                width: dimensions.width,
            }, true)(_this.props.view.state, _this.props.view.dispatch);
        };
        this.hasDifferentContextId = function () { return __awaiter(_this, void 0, void 0, function () {
            var nodeContextId, currentContextId;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        nodeContextId = this.getNodeContextId();
                        return [4 /*yield*/, this.getObjectId()];
                    case 1:
                        currentContextId = _a.sent();
                        if (nodeContextId &&
                            currentContextId &&
                            nodeContextId !== currentContextId) {
                            return [2 /*return*/, true];
                        }
                        return [2 /*return*/, false];
                }
            });
        }); };
        this.isNodeFromDifferentCollection = function () { return __awaiter(_this, void 0, void 0, function () {
            var mediaProvider, currentCollectionName, attrs, nodeCollection, __contextId, contextId, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.props.mediaProvider];
                    case 1:
                        mediaProvider = _b.sent();
                        if (!mediaProvider || !mediaProvider.uploadParams) {
                            return [2 /*return*/, false];
                        }
                        currentCollectionName = mediaProvider.uploadParams.collection;
                        attrs = this.getAttrs();
                        if (!attrs || attrs.type !== 'file') {
                            return [2 /*return*/, false];
                        }
                        nodeCollection = attrs.collection, __contextId = attrs.__contextId;
                        _a = __contextId;
                        if (_a) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.getObjectId()];
                    case 2:
                        _a = (_b.sent());
                        _b.label = 3;
                    case 3:
                        contextId = _a;
                        if (contextId && currentCollectionName !== nodeCollection) {
                            return [2 /*return*/, true];
                        }
                        return [2 /*return*/, false];
                }
            });
        }); };
        this.handleExternalMedia = function (pos) { return __awaiter(_this, void 0, void 0, function () {
            var e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.isMediaBlobUrl()) return [3 /*break*/, 6];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 5]);
                        return [4 /*yield*/, this.copyNodeFromBlobUrl(pos)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 3:
                        e_2 = _a.sent();
                        return [4 /*yield*/, this.uploadExternalMedia(pos)];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 5: return [3 /*break*/, 8];
                    case 6: return [4 /*yield*/, this.uploadExternalMedia(pos)];
                    case 7:
                        _a.sent();
                        _a.label = 8;
                    case 8: return [2 /*return*/];
                }
            });
        }); };
        this.copyNodeFromBlobUrl = function (pos) { return __awaiter(_this, void 0, void 0, function () {
            var attrs, url, mediaAttrs, mediaProvider, currentCollectionName, contextId, id, collection, height, width, mimeType, name, size, uploadMediaClientConfig, mediaClient, auth, source, destination, mediaFile;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        attrs = this.getAttrs();
                        if (!attrs || attrs.type !== 'external') {
                            return [2 /*return*/];
                        }
                        url = attrs.url;
                        mediaAttrs = getAttrsFromUrl(url);
                        if (!mediaAttrs) {
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, this.props.mediaProvider];
                    case 1:
                        mediaProvider = _a.sent();
                        if (!mediaProvider || !mediaProvider.uploadParams) {
                            return [2 /*return*/];
                        }
                        currentCollectionName = mediaProvider.uploadParams.collection;
                        contextId = mediaAttrs.contextId, id = mediaAttrs.id, collection = mediaAttrs.collection, height = mediaAttrs.height, width = mediaAttrs.width, mimeType = mediaAttrs.mimeType, name = mediaAttrs.name, size = mediaAttrs.size;
                        uploadMediaClientConfig = mediaProvider.uploadMediaClientConfig;
                        if (!uploadMediaClientConfig ||
                            !uploadMediaClientConfig.getAuthFromContext) {
                            return [2 /*return*/];
                        }
                        mediaClient = getMediaClient(uploadMediaClientConfig);
                        return [4 /*yield*/, uploadMediaClientConfig.getAuthFromContext(contextId)];
                    case 2:
                        auth = _a.sent();
                        source = {
                            id: id,
                            collection: collection,
                            authProvider: function () { return Promise.resolve(auth); },
                        };
                        destination = {
                            collection: currentCollectionName,
                            authProvider: uploadMediaClientConfig.authProvider,
                            occurrenceKey: uuidV4(),
                        };
                        return [4 /*yield*/, mediaClient.file.copyFile(source, destination)];
                    case 3:
                        mediaFile = _a.sent();
                        replaceExternalMedia(pos + 1, {
                            id: mediaFile.id,
                            collection: currentCollectionName,
                            height: height,
                            width: width,
                            __fileName: name,
                            __fileMimeType: mimeType,
                            __fileSize: size,
                        })(this.props.view.state, this.props.view.dispatch);
                        return [2 /*return*/];
                }
            });
        }); };
        // Copies the pasted node into the current collection
        this.copyNode = function () { return __awaiter(_this, void 0, void 0, function () {
            var mediaProvider, _a, isMediaSingle, view, attrs, nodeContextId, uploadMediaClientConfig, mediaClient, auth_1, objectId, id, collection, source, currentCollectionName, destination, mediaFile;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.props.mediaProvider];
                    case 1:
                        mediaProvider = _b.sent();
                        _a = this.props, isMediaSingle = _a.isMediaSingle, view = _a.view;
                        attrs = this.getAttrs();
                        if (!mediaProvider ||
                            !mediaProvider.uploadParams ||
                            !attrs ||
                            attrs.type !== 'file') {
                            return [2 /*return*/];
                        }
                        nodeContextId = this.getNodeContextId();
                        uploadMediaClientConfig = mediaProvider.uploadMediaClientConfig;
                        if (!(uploadMediaClientConfig &&
                            uploadMediaClientConfig.getAuthFromContext &&
                            nodeContextId)) return [3 /*break*/, 5];
                        mediaClient = getMediaClient(uploadMediaClientConfig);
                        return [4 /*yield*/, uploadMediaClientConfig.getAuthFromContext(nodeContextId)];
                    case 2:
                        auth_1 = _b.sent();
                        return [4 /*yield*/, this.getObjectId()];
                    case 3:
                        objectId = _b.sent();
                        id = attrs.id, collection = attrs.collection;
                        source = {
                            id: id,
                            collection: collection,
                            authProvider: function () { return Promise.resolve(auth_1); },
                        };
                        currentCollectionName = mediaProvider.uploadParams.collection;
                        destination = {
                            collection: currentCollectionName,
                            authProvider: uploadMediaClientConfig.authProvider,
                            occurrenceKey: uuidV4(),
                        };
                        return [4 /*yield*/, mediaClient.file.copyFile(source, destination)];
                    case 4:
                        mediaFile = _b.sent();
                        updateMediaNodeAttrs(source.id, {
                            id: mediaFile.id,
                            collection: currentCollectionName,
                            __contextId: objectId,
                        }, isMediaSingle)(view.state, view.dispatch);
                        _b.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        }); };
        this.props = props;
    }
    MediaNodeUpdater.prototype.isMediaBlobUrl = function () {
        var attrs = this.getAttrs();
        return !!(attrs && attrs.type === 'external' && isMediaBlobUrl(attrs.url));
    };
    MediaNodeUpdater.prototype.getRemoteDimensions = function () {
        return __awaiter(this, void 0, void 0, function () {
            var mediaProvider, mediaOptions, attrs, height, width, id, collection, viewMediaClientConfig, mediaClient, state;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.props.mediaProvider];
                    case 1:
                        mediaProvider = _a.sent();
                        mediaOptions = this.props.mediaOptions;
                        attrs = this.getAttrs();
                        if (!mediaProvider || !attrs) {
                            return [2 /*return*/, false];
                        }
                        height = attrs.height, width = attrs.width;
                        if (attrs.type === 'external' || !attrs.id) {
                            return [2 /*return*/, false];
                        }
                        id = attrs.id, collection = attrs.collection;
                        if (height && width) {
                            return [2 /*return*/, false];
                        }
                        // can't fetch remote dimensions on mobile, so we'll default them
                        if (mediaOptions && !mediaOptions.allowRemoteDimensionsFetch) {
                            return [2 /*return*/, {
                                    id: id,
                                    height: DEFAULT_IMAGE_HEIGHT,
                                    width: DEFAULT_IMAGE_WIDTH,
                                }];
                        }
                        viewMediaClientConfig = mediaProvider.viewMediaClientConfig;
                        mediaClient = getMediaClient(viewMediaClientConfig);
                        return [4 /*yield*/, mediaClient.getImageMetadata(id, {
                                collection: collection,
                            })];
                    case 2:
                        state = _a.sent();
                        if (!state || !state.original) {
                            return [2 /*return*/, false];
                        }
                        return [2 /*return*/, {
                                id: id,
                                height: state.original.height || DEFAULT_IMAGE_HEIGHT,
                                width: state.original.width || DEFAULT_IMAGE_WIDTH,
                            }];
                }
            });
        });
    };
    return MediaNodeUpdater;
}());
export { MediaNodeUpdater };
var hasPrivateAttrsChanged = function (currentAttrs, newAttrs) {
    return (currentAttrs.__fileName !== newAttrs.__fileName ||
        currentAttrs.__fileMimeType !== newAttrs.__fileMimeType ||
        currentAttrs.__fileSize !== newAttrs.__fileSize ||
        currentAttrs.__contextId !== newAttrs.__contextId);
};
//# sourceMappingURL=mediaNodeUpdater.js.map
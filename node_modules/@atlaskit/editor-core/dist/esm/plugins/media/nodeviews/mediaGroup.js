import { __awaiter, __extends, __generator } from "tslib";
import React from 'react';
import EditorCloseIcon from '@atlaskit/icon/glyph/editor/close';
import { Filmstrip } from '@atlaskit/media-filmstrip';
import { WithProviders, } from '@atlaskit/editor-common';
import ReactNodeView from '../../../nodeviews/ReactNodeView';
import { stateKey as mediaStateKey, } from '../pm-plugins/main';
import { setNodeSelection } from '../../../utils';
import WithPluginState from '../../../ui/WithPluginState';
import { stateKey as reactNodeViewStateKey } from '../../../plugins/base/pm-plugins/react-nodeview';
import { pluginKey as editorDisabledPluginKey, } from '../../editor-disabled';
import { MediaNodeUpdater } from './mediaNodeUpdater';
var MediaGroup = /** @class */ (function (_super) {
    __extends(MediaGroup, _super);
    function MediaGroup(props) {
        var _this = _super.call(this, props) || this;
        _this.state = {
            viewMediaClientConfig: undefined,
        };
        _this.updateNodeAttrs = function (props) {
            var view = props.view, mediaProvider = props.mediaProvider, contextIdentifierProvider = props.contextIdentifierProvider;
            _this.mediaNodes.forEach(function (node) {
                var mediaNodeUpdater = new MediaNodeUpdater({
                    view: view,
                    mediaProvider: mediaProvider,
                    contextIdentifierProvider: contextIdentifierProvider,
                    node: node,
                    isMediaSingle: false,
                });
                mediaNodeUpdater.updateFileAttrs(false);
            });
        };
        _this.setMediaItems = function (props) {
            var node = props.node;
            _this.mediaNodes = [];
            node.forEach(function (item, childOffset) {
                _this.mediaPluginState.mediaGroupNodes[item.attrs.id] = {
                    node: item,
                    getPos: function () { return props.getPos() + childOffset + 1; },
                };
                _this.mediaNodes.push(item);
            });
        };
        _this.getIdentifier = function (item) {
            if (item.attrs.type === 'external') {
                return {
                    mediaItemType: 'external-image',
                    dataURI: item.attrs.url,
                };
            }
            return {
                id: item.attrs.id,
                mediaItemType: 'file',
                collectionName: item.attrs.collection,
            };
        };
        _this.renderChildNodes = function () {
            var viewMediaClientConfig = _this.state.viewMediaClientConfig;
            var _a = _this.props, getPos = _a.getPos, allowLazyLoading = _a.allowLazyLoading, selected = _a.selected, disabled = _a.disabled;
            var items = _this.mediaNodes.map(function (item, idx) {
                // We declared this to get a fresh position every time
                var getNodePos = function () {
                    return getPos() + idx + 1;
                };
                return {
                    identifier: _this.getIdentifier(item),
                    selectable: true,
                    isLazy: allowLazyLoading,
                    selected: selected === getNodePos(),
                    onClick: function () {
                        setNodeSelection(_this.props.view, getNodePos());
                    },
                    actions: [
                        {
                            handler: disabled
                                ? function () { }
                                : _this.mediaPluginState.handleMediaNodeRemoval.bind(null, undefined, getNodePos),
                            icon: React.createElement(EditorCloseIcon, { label: "delete" }),
                        },
                    ],
                };
            });
            return (React.createElement(Filmstrip, { items: items, mediaClientConfig: viewMediaClientConfig }));
        };
        _this.mediaNodes = [];
        _this.mediaPluginState = mediaStateKey.getState(props.view.state);
        _this.setMediaItems(props);
        return _this;
    }
    MediaGroup.prototype.componentDidMount = function () {
        var _this = this;
        this.updateMediaClientConfig();
        this.mediaNodes.forEach(function (node) { return __awaiter(_this, void 0, void 0, function () {
            var _a, view, mediaProvider, contextIdentifierProvider, mediaNodeUpdater, contextId, hasDifferentContextId;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (node.attrs.type === 'external') {
                            return [2 /*return*/];
                        }
                        _a = this.props, view = _a.view, mediaProvider = _a.mediaProvider, contextIdentifierProvider = _a.contextIdentifierProvider;
                        mediaNodeUpdater = new MediaNodeUpdater({
                            view: view,
                            mediaProvider: mediaProvider,
                            contextIdentifierProvider: contextIdentifierProvider,
                            node: node,
                            isMediaSingle: false,
                        });
                        contextId = mediaNodeUpdater.getNodeContextId();
                        if (!!contextId) return [3 /*break*/, 2];
                        return [4 /*yield*/, mediaNodeUpdater.updateContextId()];
                    case 1:
                        _b.sent();
                        _b.label = 2;
                    case 2: return [4 /*yield*/, mediaNodeUpdater.hasDifferentContextId()];
                    case 3:
                        hasDifferentContextId = _b.sent();
                        if (!hasDifferentContextId) return [3 /*break*/, 5];
                        return [4 /*yield*/, mediaNodeUpdater.copyNode()];
                    case 4:
                        _b.sent();
                        _b.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        }); });
    };
    MediaGroup.prototype.UNSAFE_componentWillReceiveProps = function (props) {
        this.updateMediaClientConfig();
        this.setMediaItems(props);
        if (props.isCopyPasteEnabled !== false) {
            this.updateNodeAttrs(props);
        }
    };
    MediaGroup.prototype.shouldComponentUpdate = function (nextProps) {
        if (this.props.selected !== nextProps.selected ||
            this.props.node !== nextProps.node ||
            this.state.viewMediaClientConfig !==
                this.mediaPluginState.mediaClientConfig) {
            return true;
        }
        return false;
    };
    MediaGroup.prototype.updateMediaClientConfig = function () {
        var viewMediaClientConfig = this.state.viewMediaClientConfig;
        var mediaClientConfig = this.mediaPluginState.mediaClientConfig;
        if (!viewMediaClientConfig && mediaClientConfig) {
            this.setState({
                viewMediaClientConfig: mediaClientConfig,
            });
        }
    };
    MediaGroup.prototype.render = function () {
        return this.renderChildNodes();
    };
    MediaGroup.displayName = 'MediaGroup';
    return MediaGroup;
}(React.Component));
export default MediaGroup;
var MediaGroupNodeView = /** @class */ (function (_super) {
    __extends(MediaGroupNodeView, _super);
    function MediaGroupNodeView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MediaGroupNodeView.prototype.render = function (props, forwardRef) {
        var _this = this;
        var allowLazyLoading = props.allowLazyLoading, providerFactory = props.providerFactory, isCopyPasteEnabled = props.isCopyPasteEnabled;
        var getPos = this.getPos;
        return (React.createElement(WithProviders, { providers: ['mediaProvider', 'contextIdentifierProvider'], providerFactory: providerFactory, renderNode: function (_a) {
                var mediaProvider = _a.mediaProvider, contextIdentifierProvider = _a.contextIdentifierProvider;
                var renderFn = function (_a) {
                    var editorDisabledPlugin = _a.editorDisabledPlugin;
                    var nodePos = getPos();
                    var _b = _this.view.state.selection, $anchor = _b.$anchor, $head = _b.$head;
                    var isSelected = nodePos < $anchor.pos && $head.pos < nodePos + _this.node.nodeSize;
                    if (!mediaProvider) {
                        return null;
                    }
                    return (React.createElement(MediaGroup, { node: _this.node, getPos: getPos, view: _this.view, forwardRef: forwardRef, selected: isSelected ? $anchor.pos : null, disabled: (editorDisabledPlugin || {}).editorDisabled, allowLazyLoading: allowLazyLoading, mediaProvider: mediaProvider, contextIdentifierProvider: contextIdentifierProvider, isCopyPasteEnabled: isCopyPasteEnabled }));
                };
                return (React.createElement(WithPluginState, { editorView: _this.view, plugins: {
                        reactNodeViewState: reactNodeViewStateKey,
                        editorDisabledPlugin: editorDisabledPluginKey,
                    }, render: renderFn }));
            } }));
    };
    return MediaGroupNodeView;
}(ReactNodeView));
export var ReactMediaGroupNode = function (portalProviderAPI, providerFactory, allowLazyLoading, isCopyPasteEnabled) { return function (node, view, getPos) {
    return new MediaGroupNodeView(node, view, getPos, portalProviderAPI, {
        allowLazyLoading: allowLazyLoading,
        providerFactory: providerFactory,
        isCopyPasteEnabled: isCopyPasteEnabled,
    }).init();
}; };
//# sourceMappingURL=mediaGroup.js.map
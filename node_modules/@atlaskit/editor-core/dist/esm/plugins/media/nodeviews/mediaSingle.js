import { __assign, __awaiter, __extends, __generator } from "tslib";
import React from 'react';
import { Component } from 'react';
import { MediaSingle, WithProviders, DEFAULT_IMAGE_HEIGHT, DEFAULT_IMAGE_WIDTH, browser, } from '@atlaskit/editor-common';
import { NodeSelection } from 'prosemirror-state';
import { SelectionBasedNodeView, } from '../../../nodeviews/ReactNodeView';
import MediaItem from './media';
import WithPluginState from '../../../ui/WithPluginState';
import { pluginKey as widthPluginKey } from '../../width';
import { setNodeSelection, setTextSelection } from '../../../utils';
import ResizableMediaSingle from '../ui/ResizableMediaSingle';
import { createDisplayGrid } from '../../../plugins/grid';
import { stateKey as mediaPluginKey } from '../pm-plugins/main';
import { isMobileUploadCompleted } from '../commands/helpers';
import { MediaNodeUpdater } from './mediaNodeUpdater';
import { findParentNodeOfTypeClosestToPos } from 'prosemirror-utils';
import { CellSelection } from 'prosemirror-tables';
var MediaSingleNode = /** @class */ (function (_super) {
    __extends(MediaSingleNode, _super);
    function MediaSingleNode() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            width: undefined,
            height: undefined,
            viewMediaClientConfig: undefined,
        };
        _this.createMediaNodeUpdater = function (props) {
            var node = _this.props.node.firstChild;
            return new MediaNodeUpdater(__assign(__assign({}, props), { isMediaSingle: true, node: node ? node : _this.props.node, dispatchAnalyticsEvent: _this.props.dispatchAnalyticsEvent }));
        };
        _this.setViewMediaClientConfig = function (props) { return __awaiter(_this, void 0, void 0, function () {
            var mediaProvider, viewMediaClientConfig;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, props.mediaProvider];
                    case 1:
                        mediaProvider = _a.sent();
                        if (mediaProvider) {
                            viewMediaClientConfig = mediaProvider.viewMediaClientConfig;
                            this.setState({
                                viewMediaClientConfig: viewMediaClientConfig,
                            });
                        }
                        return [2 /*return*/];
                }
            });
        }); };
        _this.updateMediaNodeAttributes = function (props) { return __awaiter(_this, void 0, void 0, function () {
            var mediaNodeUpdater, addPendingTask, node, updatedDimensions, pos, updatingNode, contextId, hasDifferentContextId, copyNode;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        mediaNodeUpdater = this.createMediaNodeUpdater(props);
                        addPendingTask = this.props.mediaPluginState.addPendingTask;
                        node = this.props.node.firstChild;
                        if (!node) {
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, mediaNodeUpdater.getRemoteDimensions()];
                    case 1:
                        updatedDimensions = _a.sent();
                        if (updatedDimensions) {
                            mediaNodeUpdater.updateDimensions(updatedDimensions);
                        }
                        if (!(node.attrs.type === 'external' && node.attrs.__external)) return [3 /*break*/, 3];
                        pos = this.props.getPos();
                        updatingNode = mediaNodeUpdater.handleExternalMedia(pos);
                        addPendingTask(updatingNode);
                        return [4 /*yield*/, updatingNode];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                    case 3:
                        contextId = mediaNodeUpdater.getNodeContextId();
                        if (!!contextId) return [3 /*break*/, 5];
                        return [4 /*yield*/, mediaNodeUpdater.updateContextId()];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5: return [4 /*yield*/, mediaNodeUpdater.hasDifferentContextId()];
                    case 6:
                        hasDifferentContextId = _a.sent();
                        if (!hasDifferentContextId) return [3 /*break*/, 8];
                        copyNode = mediaNodeUpdater.copyNode();
                        addPendingTask(copyNode);
                        return [4 /*yield*/, copyNode];
                    case 7:
                        _a.sent();
                        _a.label = 8;
                    case 8: return [2 /*return*/];
                }
            });
        }); };
        _this.onExternalImageLoaded = function (_a) {
            var width = _a.width, height = _a.height;
            _this.setState({
                width: width,
                height: height,
            }, function () {
                _this.forceUpdate();
            });
        };
        _this.selectMediaSingle = function (_a) {
            var event = _a.event;
            // We need to call "stopPropagation" here in order to prevent the browser from navigating to
            // another URL if the media node is wrapped in a link mark.
            event.stopPropagation();
            var propPos = _this.props.getPos();
            var state = _this.props.view.state;
            if (event.shiftKey) {
                // don't select text if there is current selection in a table (as this would override selected cells)
                if (state.selection instanceof CellSelection) {
                    return;
                }
                setTextSelection(_this.props.view, state.selection.from < propPos ? state.selection.from : propPos, 
                // + 3 needed for offset of the media inside mediaSingle and cursor to make whole mediaSingle selected
                state.selection.to > propPos ? state.selection.to : propPos + 3);
            }
            else {
                setNodeSelection(_this.props.view, propPos);
            }
        };
        _this.updateSize = function (width, layout) {
            var _a = _this.props.view, state = _a.state, dispatch = _a.dispatch;
            var pos = _this.props.getPos();
            if (typeof pos === 'undefined') {
                return;
            }
            var tr = state.tr.setNodeMarkup(pos, undefined, __assign(__assign({}, _this.props.node.attrs), { layout: layout,
                width: width }));
            tr.setMeta('scrollIntoView', false);
            return dispatch(tr);
        };
        _this.getLineLength = function (view, pos) {
            if (typeof pos !== 'number' || isNaN(pos) || !view) {
                return null;
            }
            var _a = view.state.schema.nodes, expand = _a.expand, nestedExpand = _a.nestedExpand, layoutColumn = _a.layoutColumn;
            var $pos = view.state.doc.resolve(pos);
            var isInsideOfBlockNode = !!findParentNodeOfTypeClosestToPos($pos, [
                expand,
                nestedExpand,
                layoutColumn,
            ]);
            if (isInsideOfBlockNode) {
                var domNode = view.nodeDOM($pos.pos);
                if (domNode instanceof HTMLElement) {
                    return domNode.offsetWidth;
                }
            }
            return null;
        };
        return _this;
    }
    MediaSingleNode.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {
        if (nextProps.mediaProvider !== this.props.mediaProvider) {
            this.setViewMediaClientConfig(nextProps);
        }
        // Forced updates not required on mobile
        if (nextProps.isCopyPasteEnabled === false) {
            return;
        }
        // We need to call this method on any prop change since attrs can get removed with collab editing
        // the method internally checks if we already have all attrs
        this.createMediaNodeUpdater(nextProps).updateFileAttrs();
    };
    MediaSingleNode.prototype.componentDidMount = function () {
        return __awaiter(this, void 0, void 0, function () {
            var contextIdentifierProvider, _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        contextIdentifierProvider = this.props.contextIdentifierProvider;
                        return [4 /*yield*/, Promise.all([
                                this.setViewMediaClientConfig(this.props),
                                this.updateMediaNodeAttributes(this.props),
                            ])];
                    case 1:
                        _c.sent();
                        _a = this.setState;
                        _b = {};
                        return [4 /*yield*/, contextIdentifierProvider];
                    case 2:
                        _a.apply(this, [(_b.contextIdentifierProvider = _c.sent(),
                                _b)]);
                        return [2 /*return*/];
                }
            });
        });
    };
    MediaSingleNode.prototype.render = function () {
        var _a = this.props, selected = _a.selected, getPos = _a.getPos, node = _a.node, mediaOptions = _a.mediaOptions, fullWidthMode = _a.fullWidthMode, state = _a.view.state, view = _a.view;
        var contextIdentifierProvider = this.state.contextIdentifierProvider;
        var _b = node.attrs, layout = _b.layout, mediaSingleWidth = _b.width;
        var childNode = node.firstChild;
        var _c = childNode.attrs, width = _c.width, height = _c.height, type = _c.type;
        if (type === 'external') {
            var _d = this.state, stateWidth = _d.width, stateHeight = _d.height;
            if (width === null) {
                width = stateWidth || DEFAULT_IMAGE_WIDTH;
            }
            if (height === null) {
                height = stateHeight || DEFAULT_IMAGE_HEIGHT;
            }
        }
        if (!width || !height) {
            width = DEFAULT_IMAGE_WIDTH;
            height = DEFAULT_IMAGE_HEIGHT;
        }
        var cardWidth = this.props.width;
        var cardHeight = (height / width) * cardWidth;
        var cardDimensions = {
            width: cardWidth + "px",
            height: cardHeight + "px",
        };
        var mediaSingleProps = {
            layout: layout,
            width: width,
            height: height,
            containerWidth: this.props.width,
            lineLength: this.props.lineLength,
            pctWidth: mediaSingleWidth,
            fullWidthMode: fullWidthMode,
        };
        var uploadComplete = isMobileUploadCompleted(this.props.mediaPluginState, childNode.attrs.id);
        var originalDimensions = {
            width: width,
            height: height,
        };
        var MediaChild = (React.createElement(MediaItem, { view: this.props.view, node: childNode, getPos: this.props.getPos, cardDimensions: cardDimensions, originalDimensions: originalDimensions, viewMediaClientConfig: this.state.viewMediaClientConfig, selected: selected(), onClick: this.selectMediaSingle, onExternalImageLoaded: this.onExternalImageLoaded, allowLazyLoading: mediaOptions && mediaOptions.allowLazyLoading, uploadComplete: uploadComplete, url: childNode.attrs.url, contextIdentifierProvider: contextIdentifierProvider }));
        var canResize = !!this.props.mediaOptions.allowResizing;
        if (!this.props.mediaOptions.allowResizingInTables) {
            // If resizing not allowed in tables, check parents for tables
            var pos = getPos();
            if (pos) {
                var $pos = state.doc.resolve(pos);
                var table = state.schema.nodes.table;
                var disabledNode = !!findParentNodeOfTypeClosestToPos($pos, [table]);
                canResize = canResize && !disabledNode;
            }
        }
        return canResize ? (React.createElement(ResizableMediaSingle, __assign({}, mediaSingleProps, { lineLength: fullWidthMode
                ? this.props.lineLength
                : this.getLineLength(view, getPos()) || this.props.lineLength, view: this.props.view, getPos: getPos, updateSize: this.updateSize, displayGrid: createDisplayGrid(this.props.eventDispatcher), gridSize: 12, viewMediaClientConfig: this.state.viewMediaClientConfig, state: this.props.view.state, allowBreakoutSnapPoints: mediaOptions && mediaOptions.allowBreakoutSnapPoints, selected: this.props.selected() }), MediaChild)) : (React.createElement(MediaSingle, __assign({}, mediaSingleProps), MediaChild));
    };
    MediaSingleNode.defaultProps = {
        mediaOptions: {},
    };
    MediaSingleNode.displayName = 'MediaSingleNode';
    return MediaSingleNode;
}(Component));
export default MediaSingleNode;
var MediaSingleNodeView = /** @class */ (function (_super) {
    __extends(MediaSingleNodeView, _super);
    function MediaSingleNodeView() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.lastOffsetLeft = 0;
        _this.forceViewUpdate = false;
        return _this;
    }
    MediaSingleNodeView.prototype.createDomRef = function () {
        var domRef = document.createElement('div');
        if (browser.chrome &&
            this.reactComponentProps.mediaOptions &&
            this.reactComponentProps.mediaOptions.allowMediaSingleEditable) {
            // workaround Chrome bug in https://product-fabric.atlassian.net/browse/ED-5379
            // see also: https://github.com/ProseMirror/prosemirror/issues/884
            domRef.contentEditable = 'true';
        }
        return domRef;
    };
    MediaSingleNodeView.prototype.viewShouldUpdate = function (nextNode) {
        if (this.forceViewUpdate) {
            this.forceViewUpdate = false;
            return true;
        }
        if (this.node.attrs !== nextNode.attrs) {
            return true;
        }
        return _super.prototype.viewShouldUpdate.call(this, nextNode);
    };
    MediaSingleNodeView.prototype.getNodeMediaId = function (node) {
        if (node.firstChild) {
            return node.firstChild.attrs.id;
        }
        return undefined;
    };
    MediaSingleNodeView.prototype.update = function (node, decorations, isValidUpdate) {
        var _this = this;
        if (!isValidUpdate) {
            isValidUpdate = function (currentNode, newNode) {
                return _this.getNodeMediaId(currentNode) === _this.getNodeMediaId(newNode);
            };
        }
        return _super.prototype.update.call(this, node, decorations, isValidUpdate);
    };
    MediaSingleNodeView.prototype.render = function () {
        var _this = this;
        var _a = this.reactComponentProps, eventDispatcher = _a.eventDispatcher, fullWidthMode = _a.fullWidthMode, providerFactory = _a.providerFactory, mediaOptions = _a.mediaOptions, dispatchAnalyticsEvent = _a.dispatchAnalyticsEvent;
        // getPos is a boolean for marks, since this is a node we know it must be a function
        var getPos = this.getPos;
        return (React.createElement(WithProviders, { providers: ['mediaProvider', 'contextIdentifierProvider'], providerFactory: providerFactory, renderNode: function (_a) {
                var mediaProvider = _a.mediaProvider, contextIdentifierProvider = _a.contextIdentifierProvider;
                return (React.createElement(WithPluginState, { editorView: _this.view, plugins: {
                        width: widthPluginKey,
                        mediaPluginState: mediaPluginKey,
                    }, render: function (_a) {
                        var width = _a.width, mediaPluginState = _a.mediaPluginState;
                        var selection = _this.view.state.selection;
                        var isSelected = function () {
                            return _this.isSelectionInsideNode(selection.from, selection.to) ||
                                (selection instanceof NodeSelection &&
                                    selection.from === getPos());
                        };
                        return (React.createElement(MediaSingleNode, { width: width.width, lineLength: width.lineLength, node: _this.node, getPos: getPos, mediaProvider: mediaProvider, contextIdentifierProvider: contextIdentifierProvider, mediaOptions: mediaOptions || {}, view: _this.view, fullWidthMode: fullWidthMode, selected: isSelected, eventDispatcher: eventDispatcher, mediaPluginState: mediaPluginState, dispatchAnalyticsEvent: dispatchAnalyticsEvent }));
                    } }));
            } }));
    };
    MediaSingleNodeView.prototype.ignoreMutation = function () {
        // DOM has changed; recalculate if we need to re-render
        if (this.dom) {
            var offsetLeft = this.dom.offsetLeft;
            if (offsetLeft !== this.lastOffsetLeft) {
                this.lastOffsetLeft = offsetLeft;
                this.forceViewUpdate = true;
                this.update(this.node, [], function () { return true; });
            }
        }
        return true;
    };
    return MediaSingleNodeView;
}(SelectionBasedNodeView));
export var ReactMediaSingleNode = function (portalProviderAPI, eventDispatcher, providerFactory, mediaOptions, fullWidthMode, dispatchAnalyticsEvent, isCopyPasteEnabled) {
    if (mediaOptions === void 0) { mediaOptions = {}; }
    return function (node, view, getPos) {
        return new MediaSingleNodeView(node, view, getPos, portalProviderAPI, {
            eventDispatcher: eventDispatcher,
            fullWidthMode: fullWidthMode,
            providerFactory: providerFactory,
            mediaOptions: mediaOptions,
            dispatchAnalyticsEvent: dispatchAnalyticsEvent,
            isCopyPasteEnabled: isCopyPasteEnabled,
        }).init();
    };
};
//# sourceMappingURL=mediaSingle.js.map
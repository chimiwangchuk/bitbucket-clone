import { __awaiter, __generator } from "tslib";
import { MediaPicker, isImagePreview } from '@atlaskit/media-picker';
var PickerFacade = /** @class */ (function () {
    function PickerFacade(pickerType, config, pickerConfig, mediaPickerFactoryClass, analyticsName) {
        var _this = this;
        if (mediaPickerFactoryClass === void 0) { mediaPickerFactoryClass = MediaPicker; }
        this.config = config;
        this.pickerConfig = pickerConfig;
        this.mediaPickerFactoryClass = mediaPickerFactoryClass;
        this.onDragListeners = [];
        this.onStartListeners = [];
        this.eventListeners = {};
        this.handleUploadPreviewUpdate = function (event) {
            var file = event.file, preview = event.preview;
            //check if upload-error was called before upload-preview-update
            var isErroredFile = _this.erroredFiles.has(file.id);
            var _a = isImagePreview(preview)
                ? preview
                : { dimensions: undefined, scaleFactor: undefined }, dimensions = _a.dimensions, scaleFactor = _a.scaleFactor;
            var state = {
                id: file.id,
                fileName: file.name,
                fileSize: file.size,
                fileMimeType: file.type,
                dimensions: dimensions,
                scaleFactor: scaleFactor,
                status: isErroredFile ? 'error' : undefined,
            };
            _this.eventListeners[file.id] = [];
            _this.onStartListeners.forEach(function (cb) {
                return cb(state, function (evt) { return _this.subscribeStateChanged(file, evt); }, _this.analyticsName || _this.pickerType);
            });
        };
        this.subscribeStateChanged = function (file, onStateChanged) {
            var subscribers = _this.eventListeners[file.id];
            if (!subscribers) {
                return;
            }
            subscribers.push(onStateChanged);
        };
        this.handleUploadError = function (_a) {
            var error = _a.error, fileId = _a.fileId;
            var listeners = _this.eventListeners[fileId];
            _this.erroredFiles.add(fileId);
            if (!listeners) {
                return;
            }
            listeners.forEach(function (cb) {
                return cb({
                    id: fileId,
                    status: 'error',
                    error: error && { description: error.description, name: error.name },
                });
            });
            // remove listeners
            delete _this.eventListeners[fileId];
        };
        this.handleMobileUploadEnd = function (event) {
            var file = event.file;
            var listeners = _this.eventListeners[file.id];
            if (!listeners) {
                return;
            }
            listeners.forEach(function (cb) {
                return cb({
                    id: file.id,
                    status: 'mobile-upload-end',
                    fileMimeType: file.type,
                    collection: file.collectionName,
                    publicId: file.publicId,
                });
            });
        };
        this.handleReady = function (event) {
            var file = event.file;
            var listeners = _this.eventListeners[file.id];
            if (!listeners) {
                return;
            }
            listeners.forEach(function (cb) {
                return cb({
                    id: file.id,
                    status: 'ready',
                });
            });
            // remove listeners
            delete _this.eventListeners[file.id];
        };
        this.pickerType = pickerType;
        this.errorReporter = config.errorReporter;
        this.analyticsName = analyticsName;
        this.erroredFiles = new Set();
    }
    PickerFacade.prototype.init = function () {
        return __awaiter(this, void 0, void 0, function () {
            var picker, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(this.pickerType === 'customMediaPicker')) return [3 /*break*/, 1];
                        picker = this.picker = this.pickerConfig;
                        return [3 /*break*/, 3];
                    case 1:
                        if (!(this.pickerType === 'popup')) return [3 /*break*/, 3];
                        _a = this;
                        return [4 /*yield*/, this.mediaPickerFactoryClass(this.config.mediaClientConfig, this.pickerConfig)];
                    case 2:
                        picker = _a.picker = _b.sent();
                        _b.label = 3;
                    case 3:
                        if (!picker) {
                            return [2 /*return*/, this];
                        }
                        picker.on('upload-preview-update', this.handleUploadPreviewUpdate);
                        picker.on('upload-end', this.handleReady);
                        picker.on('upload-error', this.handleUploadError);
                        picker.on('mobile-upload-end', this.handleMobileUploadEnd);
                        return [2 /*return*/, this];
                }
            });
        });
    };
    Object.defineProperty(PickerFacade.prototype, "type", {
        get: function () {
            return this.pickerType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PickerFacade.prototype, "mediaPicker", {
        get: function () {
            return this.picker;
        },
        enumerable: true,
        configurable: true
    });
    PickerFacade.prototype.destroy = function () {
        var picker = this.picker;
        if (!picker) {
            return;
        }
        picker.removeAllListeners('upload-preview-update');
        picker.removeAllListeners('upload-end');
        picker.removeAllListeners('upload-error');
        this.onStartListeners = [];
        this.onDragListeners = [];
        try {
            if (this.pickerType === 'popup') {
                picker.teardown();
            }
        }
        catch (ex) {
            this.errorReporter.captureException(ex);
        }
    };
    PickerFacade.prototype.setUploadParams = function (params) {
        if (this.picker) {
            this.picker.setUploadParams(params);
        }
    };
    PickerFacade.prototype.onClose = function (cb) {
        var picker = this.picker;
        if (this.pickerType === 'popup') {
            var popupPicker_1 = picker;
            popupPicker_1.on('closed', cb);
            return function () { return popupPicker_1.off('closed', cb); };
        }
        return function () { };
    };
    PickerFacade.prototype.show = function () {
        if (this.pickerType === 'popup') {
            try {
                this.picker.show();
            }
            catch (ex) {
                this.errorReporter.captureException(ex);
            }
        }
    };
    PickerFacade.prototype.hide = function () {
        if (this.pickerType === 'popup') {
            this.picker.hide();
        }
    };
    PickerFacade.prototype.onNewMedia = function (cb) {
        this.onStartListeners.push(cb);
    };
    PickerFacade.prototype.onDrag = function (cb) {
        this.onDragListeners.push(cb);
    };
    return PickerFacade;
}());
export default PickerFacade;
//# sourceMappingURL=picker-facade.js.map
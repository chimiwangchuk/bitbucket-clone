import { __extends, __makeTemplateObject } from "tslib";
import React from 'react';
import styled from 'styled-components';
import { colors } from '@atlaskit/theme';
import ChevronLeftLargeIcon from '@atlaskit/icon/glyph/chevron-left-large';
import CrossCircleIcon from '@atlaskit/icon/glyph/cross-circle';
import { messages } from '../messages';
import { injectIntl } from 'react-intl';
import Button from '../../../../floating-toolbar/ui/Button';
import PanelTextInput from '../../../../../ui/PanelTextInput';
import * as keymaps from '../../../../../keymaps';
import { closeMediaAltTextMenu, updateAltText } from '../commands';
import { withAnalyticsEvents, } from '@atlaskit/analytics-next';
import { ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE, fireAnalyticsEvent, ACTION, } from '../../../../analytics';
import { RECENT_SEARCH_WIDTH_IN_PX } from '../../../../../ui/RecentSearch/ToolbarComponents';
import { ErrorMessage } from '@atlaskit/editor-common';
export var CONTAINER_WIDTH_IN_PX = RECENT_SEARCH_WIDTH_IN_PX;
export var MAX_ALT_TEXT_LENGTH = 510; // double tweet length
var SupportText = styled.p(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  color: ", ";\n  font-size: 12px;\n  padding: 12px 40px;\n  line-height: 20px;\n  border-top: 1px solid ", ";\n  margin: 0;\n"], ["\n  color: ", ";\n  font-size: 12px;\n  padding: 12px 40px;\n  line-height: 20px;\n  border-top: 1px solid ", ";\n  margin: 0;\n"])), colors.N100, colors.N30);
var Container = styled.div(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  width: ", "px;\n  display: flex;\n  flex-direction: column;\n  overflow: auto;\n  line-height: 2;\n"], ["\n  width: ", "px;\n  display: flex;\n  flex-direction: column;\n  overflow: auto;\n  line-height: 2;\n"])), CONTAINER_WIDTH_IN_PX);
var InputWrapper = styled.section(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n  display: flex;\n  line-height: 0;\n  padding: 5px 0;\n  align-items: center;\n"], ["\n  display: flex;\n  line-height: 0;\n  padding: 5px 0;\n  align-items: center;\n"])));
var ValidationWrapper = styled.section(templateObject_4 || (templateObject_4 = __makeTemplateObject(["\n  display: flex;\n  line-height: 0;\n  padding: 12px 24px 12px 0;\n  margin: 0 12px 0 40px;\n  border-top: 1px solid ", ";\n  align-items: start;\n  display: flex;\n  flex-direction: column;\n"], ["\n  display: flex;\n  line-height: 0;\n  padding: 12px 24px 12px 0;\n  margin: 0 12px 0 40px;\n  border-top: 1px solid ", ";\n  align-items: start;\n  display: flex;\n  flex-direction: column;\n"])), colors.R400);
var ButtonWrapper = styled.div(templateObject_5 || (templateObject_5 = __makeTemplateObject(["\n  display: flex;\n  padding: 4px 8px;\n"], ["\n  display: flex;\n  padding: 4px 8px;\n"])));
var ClearText = styled.span(templateObject_6 || (templateObject_6 = __makeTemplateObject(["\n  color: ", ";\n"], ["\n  color: ", ";\n"])), colors.N80);
var AltTextEditComponent = /** @class */ (function (_super) {
    __extends(AltTextEditComponent, _super);
    function AltTextEditComponent(props) {
        var _this = _super.call(this, props) || this;
        _this.state = {
            showClearTextButton: Boolean(_this.props.value),
            validationErrors: _this.props.value
                ? _this.getValidationErrors(_this.props.value)
                : [],
            lastValue: _this.props.value,
        };
        _this.closeMediaAltTextMenu = function () {
            var view = _this.props.view;
            closeMediaAltTextMenu(view.state, view.dispatch);
        };
        _this.dispatchCancelEvent = function (event) {
            var view = _this.props.view;
            // We need to pass down the ESCAPE keymap
            // because when we focus on the Toolbar, Prosemirror blur,
            // making all keyboard shortcuts not working
            view.someProp('handleKeyDown', function (fn) { return fn(view, event); });
        };
        _this.updateAltText = function (newAltText) {
            var view = _this.props.view;
            var newValue = newAltText.length === 0 ? null : newAltText;
            updateAltText(newValue)(view.state, view.dispatch);
        };
        _this.handleOnChange = function (newAltText) {
            var validationErrors = _this.getValidationErrors(newAltText);
            _this.setState({
                showClearTextButton: Boolean(newAltText),
                validationErrors: validationErrors,
                lastValue: newAltText,
            }, function () {
                if (!validationErrors || !validationErrors.length) {
                    _this.updateAltText(newAltText);
                }
            });
        };
        _this.handleOnBlur = function () {
            // Handling the trimming onBlur() because PanelTextInput doesn't sync
            // defaultValue properly during unmount
            var value = _this.props.value;
            var newValue = (_this.state.lastValue || value || '').trim();
            _this.handleOnChange(newValue);
        };
        _this.handleClearText = function () {
            _this.handleOnChange('');
        };
        var createAnalyticsEvent = props.createAnalyticsEvent;
        _this.fireCustomAnalytics = fireAnalyticsEvent(createAnalyticsEvent);
        return _this;
    }
    AltTextEditComponent.prototype.componentDidMount = function () {
        this.prevValue = this.props.value;
    };
    AltTextEditComponent.prototype.componentWillUnmount = function () {
        this.fireAnalytics(ACTION.CLOSED);
        if (!this.prevValue && this.props.value) {
            this.fireAnalytics(ACTION.ADDED);
        }
        if (this.prevValue && !this.props.value) {
            this.fireAnalytics(ACTION.CLEARED);
        }
        if (this.prevValue && this.prevValue !== this.props.value) {
            this.fireAnalytics(ACTION.EDITED);
        }
    };
    AltTextEditComponent.prototype.getValidationErrors = function (value) {
        var altTextValidator = this.props.altTextValidator;
        if (value && typeof altTextValidator === 'function') {
            return altTextValidator(value) || [];
        }
        return [];
    };
    AltTextEditComponent.prototype.render = function () {
        var formatMessage = this.props.intl.formatMessage;
        var showClearTextButton = this.state.showClearTextButton;
        var backButtonMessage = formatMessage(messages.back);
        var backButtonMessageComponent = keymaps.renderTooltipContent(backButtonMessage, keymaps.escape, 'Esc');
        var errorsList = (this.state.validationErrors || []).map(function (error, index) {
            return React.createElement(ErrorMessage, { key: index }, error);
        });
        return (React.createElement(Container, null,
            React.createElement(InputWrapper, null,
                React.createElement(ButtonWrapper, null,
                    React.createElement(Button, { title: formatMessage(messages.back), icon: React.createElement(ChevronLeftLargeIcon, { label: formatMessage(messages.back) }), tooltipContent: backButtonMessageComponent, onClick: this.closeMediaAltTextMenu })),
                React.createElement(PanelTextInput, { testId: "alt-text-input", placeholder: formatMessage(messages.placeholder), defaultValue: this.state.lastValue, onCancel: this.dispatchCancelEvent, onChange: this.handleOnChange, onBlur: this.handleOnBlur, onSubmit: this.closeMediaAltTextMenu, maxLength: MAX_ALT_TEXT_LENGTH, autoFocus: true }),
                showClearTextButton && (React.createElement(ButtonWrapper, null,
                    React.createElement(Button, { testId: "alt-text-clear-button", title: formatMessage(messages.clear), icon: React.createElement(ClearText, null,
                            React.createElement(CrossCircleIcon, { label: formatMessage(messages.clear) })), tooltipContent: formatMessage(messages.clear), onClick: this.handleClearText })))),
            !!errorsList.length && (React.createElement(ValidationWrapper, null, errorsList)),
            React.createElement(SupportText, null, formatMessage(messages.supportText))));
    };
    AltTextEditComponent.prototype.fireAnalytics = function (actionType) {
        var createAnalyticsEvent = this.props.createAnalyticsEvent;
        if (createAnalyticsEvent && this.fireCustomAnalytics) {
            this.fireCustomAnalytics({
                payload: {
                    action: actionType,
                    actionSubject: ACTION_SUBJECT.MEDIA,
                    actionSubjectId: ACTION_SUBJECT_ID.ALT_TEXT,
                    eventType: EVENT_TYPE.TRACK,
                },
            });
        }
    };
    return AltTextEditComponent;
}(React.Component));
export { AltTextEditComponent };
export default withAnalyticsEvents()(injectIntl(AltTextEditComponent));
var templateObject_1, templateObject_2, templateObject_3, templateObject_4, templateObject_5, templateObject_6;
//# sourceMappingURL=AltTextEdit.js.map
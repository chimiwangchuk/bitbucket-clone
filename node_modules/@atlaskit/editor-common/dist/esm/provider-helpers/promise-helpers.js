export var ResultStatus;
(function (ResultStatus) {
    ResultStatus["FULFILLED"] = "fulfilled";
    ResultStatus["FAILED"] = "failed";
})(ResultStatus || (ResultStatus = {}));
var isFullfilled = function (result) { return result.status === ResultStatus.FULFILLED; };
var markFullfilled = function (value) { return ({
    status: ResultStatus.FULFILLED,
    value: value,
}); };
var markRejected = function (error) { return ({
    status: ResultStatus.FAILED,
    reason: error,
}); };
/**
 * Will wait for all promises to resolve or reject, wrapping their real results in
 * object containing the status so it's easy to filter it later. Loosely inspired by
 * [Promise.allSettled](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled)
 * which can replace this implementation once it makes to the browsers.
 * @param promises
 */
export var waitForAllPromises = function (promises) {
    return Promise.all(promises.map(function (result) {
        return result.then(markFullfilled).catch(markRejected);
    }));
};
/**
 * Will resolve on the first fulfilled promise and disregard the remaining ones. Similar to `Promise.race` but won't
 * care about rejected promises.
 * @param promises
 */
export var waitForFirstFulfilledPromise = function (promises) {
    var rejectReasons = [];
    return new Promise(function (resolve, reject) {
        promises.forEach(function (promise) {
            return promise
                .then(function (value) {
                if (typeof value === 'undefined' || value === null) {
                    throw new Error("Result was not found but the method didn't reject/throw. Please ensure that it doesn't return null or undefined.");
                }
                resolve(value);
            })
                .catch(function (reason) {
                rejectReasons.push(reason);
                if (rejectReasons.length === promises.length) {
                    reject(reason);
                }
            });
        });
    });
};
/**
 * Find all fullfilled promises and return their values
 * @param results
 */
export var getOnlyFulfilled = function (results) { return results.filter(isFullfilled).map(function (result) { return result.value; }); };
//# sourceMappingURL=promise-helpers.js.map
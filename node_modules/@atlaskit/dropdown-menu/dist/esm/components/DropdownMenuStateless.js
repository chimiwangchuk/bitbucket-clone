import { __assign, __extends } from "tslib";
/* eslint-disable react/no-array-index-key */
import React, { Component, Fragment } from 'react';
import { findDOMNode } from 'react-dom';
import { uid } from 'react-uid';
import { withAnalyticsContext, withAnalyticsEvents, createAndFireEvent, } from '@atlaskit/analytics-next';
import Button from '@atlaskit/button';
import Droplist, { Item, Group } from '@atlaskit/droplist';
import ExpandIcon from '@atlaskit/icon/glyph/chevron-down';
import { name as packageName, version as packageVersion, } from '../version.json';
import DropdownItemFocusManager from './context/DropdownItemFocusManager';
import DropdownItemClickManager from './context/DropdownItemClickManager';
import DropdownItemSelectionCache from './context/DropdownItemSelectionCache';
import WidthConstrainer from '../styled/WidthConstrainer';
import { KEY_DOWN, KEY_SPACE, KEY_ENTER } from '../util/keys';
var DropdownMenuStateless = /** @class */ (function (_super) {
    __extends(DropdownMenuStateless, _super);
    function DropdownMenuStateless() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.dropdownListPositioned = false;
        _this.state = {
            id: uid({ id: _this.constructor.name }),
            autoFocusDropdownItems: false,
        };
        _this.componentDidMount = function () {
            if (_this.isUsingDeprecatedAPI()) {
                if (process.env.NODE_ENV !== 'test' &&
                    process.env.NODE_ENV !== 'production' &&
                    !process.env.CI) {
                    // eslint-disable-next-line no-console
                    console.log('DropdownMenu.items is deprecated. Please switch to the declarative API.');
                }
                if (_this.domItemsList) {
                    _this.focusFirstItem();
                }
            }
        };
        _this.componentDidUpdate = function (prevProp) {
            if (_this.isUsingDeprecatedAPI() && _this.props.isOpen && !prevProp.isOpen) {
                _this.focusFirstItem();
            }
        };
        _this.getNextFocusable = function (indexItem, available) {
            if (!_this.domItemsList) {
                return null;
            }
            var currentItem = typeof indexItem !== 'number' ? -1 : indexItem;
            var latestAvailable = typeof available !== 'number' ? currentItem : available;
            if (currentItem < _this.domItemsList.length - 1) {
                currentItem++;
                if (_this.domItemsList[currentItem].getAttribute('aria-hidden') !== 'true') {
                    return currentItem;
                }
                return _this.getNextFocusable(currentItem, latestAvailable);
            }
            return latestAvailable;
        };
        _this.getPrevFocusable = function (indexItem, available) {
            if (!_this.domItemsList) {
                return null;
            }
            var currentItem = typeof indexItem !== 'number' ? -1 : indexItem;
            var latestAvailable = typeof available !== 'number' ? currentItem : available;
            if (currentItem && currentItem > 0) {
                currentItem--;
                if (_this.domItemsList[currentItem].getAttribute('aria-hidden') !== 'true') {
                    return currentItem;
                }
                return _this.getPrevFocusable(currentItem, latestAvailable);
            }
            return latestAvailable || currentItem;
        };
        _this.focusFirstItem = function () {
            if (_this.sourceOfIsOpen === 'keydown') {
                _this.focusItem(_this.getNextFocusable());
            }
        };
        _this.focusNextItem = function () {
            _this.focusItem(_this.getNextFocusable(_this.focusedItem));
        };
        _this.focusPreviousItem = function () {
            _this.focusItem(_this.getPrevFocusable(_this.focusedItem));
        };
        _this.focusItem = function (index) {
            if (!_this.domItemsList || !index) {
                return;
            }
            _this.focusedItem = index;
            _this.domItemsList[_this.focusedItem].focus();
        };
        _this.isTargetChildItem = function (target) {
            if (!target)
                return false;
            var isDroplistItem = target.getAttribute('data-role') === 'droplistItem';
            // eslint-disable-next-line react/no-find-dom-node
            var thisDom = findDOMNode(_this);
            return isDroplistItem && thisDom ? thisDom.contains(target) : false;
        };
        _this.handleKeyboardInteractionForClosed = function (event) {
            if (_this.props.isOpen) {
                return;
            }
            switch (event.key) {
                case KEY_DOWN:
                case KEY_SPACE:
                case KEY_ENTER:
                    event.preventDefault();
                    _this.open({ event: event, source: 'keydown' });
                    break;
                default:
                    break;
            }
        };
        _this.handleKeyboardInteractionsDeprecated = function (event) {
            if (_this.props.isOpen) {
                if (_this.isTargetChildItem(event.target)) {
                    switch (event.key) {
                        case 'ArrowUp':
                            event.preventDefault();
                            _this.focusPreviousItem();
                            break;
                        case 'ArrowDown':
                            event.preventDefault();
                            _this.focusNextItem();
                            break;
                        case 'Tab':
                            event.preventDefault();
                            _this.close({ event: event });
                            break;
                        default:
                            break;
                    }
                }
                else if (event.key === 'ArrowDown') {
                    _this.sourceOfIsOpen = 'keydown';
                    _this.focusFirstItem();
                }
                else if (event.key === 'Tab') {
                    _this.close({ event: event });
                }
            }
            else {
                switch (event.key) {
                    case KEY_DOWN:
                    case KEY_SPACE:
                    case KEY_ENTER:
                        event.preventDefault();
                        _this.open({ event: event, source: 'keydown' });
                        break;
                    default:
                        break;
                }
            }
        };
        _this.domMenuContainer = null;
        _this.isUsingDeprecatedAPI = function () { return Boolean(_this.props.items.length); };
        _this.triggerContent = function () {
            var _a = _this.props, children = _a.children, trigger = _a.trigger, isOpen = _a.isOpen, triggerButtonProps = _a.triggerButtonProps, triggerType = _a.triggerType, testId = _a.testId;
            var insideTriggerContent = _this.isUsingDeprecatedAPI()
                ? children
                : trigger;
            if (triggerType !== 'button') {
                return insideTriggerContent;
            }
            // we probably don't need to object copying
            // ts doesn't like destructuring copy - so converting to object.assign
            var triggerProps = Object.assign({}, triggerButtonProps);
            var defaultButtonProps = {
                'aria-controls': _this.state.id,
                'aria-expanded': isOpen,
                'aria-haspopup': true,
                isSelected: isOpen,
            };
            if (!triggerProps.iconAfter && !triggerProps.iconBefore) {
                triggerProps.iconAfter = React.createElement(ExpandIcon, { size: "medium", label: "" });
            }
            return (React.createElement(Button, __assign({}, defaultButtonProps, triggerProps, { testId: testId && testId + "--trigger" }), insideTriggerContent));
        };
        _this.open = function (attrs) {
            _this.sourceOfIsOpen = attrs.source;
            _this.props.onOpenChange({ isOpen: true, event: attrs.event });
            // Dropdown opened via keyboard gets auto focussed
            _this.setState({
                autoFocusDropdownItems: _this.sourceOfIsOpen === 'keydown',
            });
        };
        _this.close = function (attrs) {
            _this.sourceOfIsOpen = null;
            _this.props.onOpenChange({ isOpen: false, event: attrs.event });
        };
        _this.toggle = function (attrs) {
            if (attrs.source === 'keydown')
                return;
            if (_this.props.isOpen) {
                _this.close(attrs);
            }
            else {
                _this.open(attrs);
            }
        };
        _this.renderTrigger = function () {
            var triggerContent = _this.triggerContent();
            return _this.isUsingDeprecatedAPI() ? (triggerContent) : (React.createElement("div", { ref: function (ref) {
                    _this.triggerContainer = ref;
                } }, triggerContent));
        };
        _this.renderItems = function (items) {
            return items.map(function (item, itemIndex) { return (React.createElement(Item, __assign({}, item, { key: itemIndex, onActivate: function (_a) {
                    var event = _a.event;
                    _this.props.onItemActivated({ item: item, event: event });
                } }), item.content)); });
        };
        _this.renderGroups = function (groups) {
            return groups.map(function (group, groupIndex) { return (React.createElement(Group, { heading: group.heading, elemAfter: group.elemAfter, key: groupIndex }, _this.renderItems(group.items))); });
        };
        _this.renderDeprecated = function () {
            var _a = _this.props, items = _a.items, shouldFitContainer = _a.shouldFitContainer;
            var id = _this.state.id;
            return (React.createElement("div", { id: id, ref: function (ref) {
                    _this.domMenuContainer = ref;
                    _this.domItemsList = ref
                        ? ref.querySelectorAll('[data-role="droplistItem"]')
                        : null;
                }, role: "menu", style: shouldFitContainer ? undefined : { maxWidth: 300 } }, _this.renderGroups(items)));
        };
        /** Ensure droplist is positioned before focussing to avoid container scrolling to top */
        _this.onDroplistPositioned = function () {
            _this.dropdownListPositioned = true;
            // Trigger render so item focus manager can auto focus for keyboard trigger
            _this.setState({
                autoFocusDropdownItems: _this.sourceOfIsOpen === 'keydown',
            });
            if (_this.props.onPositioned)
                _this.props.onPositioned();
        };
        /** Render focusManager only after droplist has been positioned when trigger via keyboard */
        _this.renderDropdownItems = function () {
            if (_this.sourceOfIsOpen === 'keydown' && _this.dropdownListPositioned) {
                return (React.createElement(DropdownItemFocusManager, { autoFocus: _this.state.autoFocusDropdownItems, close: _this.close }, _this.props.children));
            }
            return React.createElement(Fragment, null, _this.props.children);
        };
        return _this;
    }
    DropdownMenuStateless.prototype.handleClickDeprecated = function (event) {
        var menuContainer = this.domMenuContainer;
        if (!menuContainer ||
            (menuContainer && !menuContainer.contains(event.target))) {
            this.toggle({ source: 'click', event: event });
        }
    };
    DropdownMenuStateless.prototype.handleClick = function (event) {
        // For any clicks we don't want autofocus
        this.setState({ autoFocusDropdownItems: false });
        if (this.isUsingDeprecatedAPI()) {
            this.handleClickDeprecated(event);
            return;
        }
        if (this.triggerContainer &&
            this.triggerContainer.contains(event.target) &&
            event.target.disabled !== true) {
            var isOpen = this.props.isOpen;
            this.sourceOfIsOpen = 'mouse';
            this.props.onOpenChange({ isOpen: !isOpen, event: event });
        }
    };
    DropdownMenuStateless.prototype.render = function () {
        var _this = this;
        var _a = this.props, appearance = _a.appearance, boundariesElement = _a.boundariesElement, isLoading = _a.isLoading, isOpen = _a.isOpen, onOpenChange = _a.onOpenChange, position = _a.position, isMenuFixed = _a.isMenuFixed, shouldAllowMultilineItems = _a.shouldAllowMultilineItems, shouldFitContainer = _a.shouldFitContainer, shouldFlip = _a.shouldFlip, testId = _a.testId;
        var id = this.state.id;
        var isDeprecated = this.isUsingDeprecatedAPI();
        var deprecatedProps = isDeprecated
            ? {
                onKeyDown: this.handleKeyboardInteractionsDeprecated,
                shouldAllowMultilineItems: shouldAllowMultilineItems,
            }
            : {
                onKeyDown: this.handleKeyboardInteractionForClosed,
            };
        return (React.createElement(DropdownItemSelectionCache, null,
            React.createElement(Droplist, __assign({ appearance: appearance, boundariesElement: boundariesElement, isLoading: isLoading, isOpen: isOpen, onClick: function (e) { return _this.handleClick(e); }, onOpenChange: onOpenChange, position: position, isMenuFixed: isMenuFixed, shouldFitContainer: shouldFitContainer, shouldFlip: shouldFlip, trigger: this.renderTrigger(), onPositioned: this.onDroplistPositioned }, deprecatedProps, { analyticsContext: {
                    componentName: 'dropdownMenu',
                    packageName: packageName,
                    packageVersion: packageVersion,
                }, testId: testId }), isDeprecated ? (this.renderDeprecated()) : (React.createElement(WidthConstrainer, { id: id, role: "menu", shouldFitContainer: shouldFitContainer },
                React.createElement(DropdownItemClickManager, { onItemClicked: function (event) {
                        return onOpenChange({ isOpen: false, event: event });
                    } }, this.renderDropdownItems()))))));
    };
    DropdownMenuStateless.defaultProps = {
        appearance: 'default',
        boundariesElement: 'viewport',
        isLoading: false,
        isOpen: false,
        items: [],
        onItemActivated: function () { },
        onOpenChange: function () { },
        position: 'bottom left',
        isMenuFixed: false,
        shouldAllowMultilineItems: false,
        shouldFitContainer: false,
        shouldFlip: true,
        triggerType: 'default',
        onPositioned: function () { },
    };
    return DropdownMenuStateless;
}(Component));
export { DropdownMenuStateless };
export { DropdownMenuStateless as DropdownMenuStatelessWithoutAnalytics };
var createAndFireEventOnAtlaskit = createAndFireEvent('atlaskit');
export default withAnalyticsContext({
    componentName: 'dropdownMenu',
    packageName: packageName,
    packageVersion: packageVersion,
})(withAnalyticsEvents({
    onOpenChange: createAndFireEventOnAtlaskit({
        action: 'toggled',
        actionSubject: 'dropdownMenu',
        attributes: {
            componentName: 'dropdownMenu',
            packageName: packageName,
            packageVersion: packageVersion,
        },
    }),
})(DropdownMenuStateless));
//# sourceMappingURL=DropdownMenuStateless.js.map
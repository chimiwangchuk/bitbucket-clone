import { __assign, __read } from "tslib";
import React, { useContext, useEffect, useMemo, useRef, useState, } from 'react';
import { uid } from 'react-uid';
import invariant from 'tiny-invariant';
import { FormContext, IsDisabledContext } from './Form';
import FieldWrapper, { Label, RequiredIndicator } from './styled/Field';
function isEvent(event) {
    return Boolean(event && event.target);
}
function isFunction(x) {
    return typeof x === 'function';
}
// Provides the id of the field to message components.
// This links the message with the field for screen-readers.
export var FieldId = React.createContext(undefined);
function usePreviousRef(current) {
    var ref = useRef(current);
    // will be updated on the next render
    useEffect(function () {
        ref.current = current;
    });
    // return the existing current (pre render)
    return ref;
}
function isShallowEqual(previousValue, currentValue) {
    if (previousValue === currentValue) {
        return true;
    }
    // not checking functions
    if (typeof previousValue === 'function' &&
        typeof currentValue === 'function') {
        return true;
    }
    if (Array.isArray(previousValue) && Array.isArray(currentValue)) {
        return JSON.stringify(previousValue) === JSON.stringify(currentValue);
    }
    if (typeof previousValue === 'object' && typeof currentValue === 'object') {
        return JSON.stringify(previousValue) === JSON.stringify(currentValue);
    }
    return false;
}
function Field(props) {
    var registerField = useContext(FormContext);
    var isDisabled = useContext(IsDisabledContext) || props.isDisabled;
    var defaultValue = isFunction(props.defaultValue)
        ? props.defaultValue()
        : props.defaultValue;
    var _a = __read(useState({
        fieldProps: {
            onChange: function () { },
            onBlur: function () { },
            onFocus: function () { },
            value: defaultValue,
        },
        error: undefined,
        valid: false,
        meta: {
            dirty: false,
            dirtySinceLastSubmit: false,
            touched: false,
            valid: false,
            submitting: false,
            submitFailed: false,
            error: undefined,
            submitError: undefined,
        },
    }), 2), state = _a[0], setState = _a[1];
    var latestPropsRef = usePreviousRef(props);
    var latestStateRef = usePreviousRef(state);
    /**
     * HACK: defaultValue can potentially be an array or object which cannot be
     * passed directly into a `useEffect` dependency array, since it will trigger
     * the hook every time.
     */
    var hasDefaultValueChanged = isShallowEqual(latestPropsRef.current.defaultValue, props.defaultValue);
    useEffect(function () {
        if (process.env.NODE_ENV !== 'production' && !process.env.CI) {
            invariant(latestPropsRef.current.name, '@atlaskit/form: Field components have a required name prop');
        }
        function fieldStateToMeta(value) {
            if (value === void 0) { value = {}; }
            return {
                dirty: value.dirty || false,
                dirtySinceLastSubmit: value.dirtySinceLastSubmit || false,
                touched: value.touched || false,
                valid: value.valid || false,
                submitting: value.submitting || false,
                submitFailed: value.submitFailed || false,
                error: value.error,
                submitError: value.submitError,
            };
        }
        var unregister = registerField(latestPropsRef.current.name, latestPropsRef.current.defaultValue, function (fieldState) {
            /** Do not update dirtySinceLastSubmit until submission has finished. */
            var modifiedDirtySinceLastSubmit = fieldState.submitting
                ? latestStateRef.current.meta.dirtySinceLastSubmit
                : fieldState.dirtySinceLastSubmit;
            /** Do not update submitFailed until submission has finished. */
            var modifiedSubmitFailed = fieldState.submitting
                ? latestStateRef.current.meta.submitFailed
                : fieldState.submitFailed;
            /** Do not use submitError if the value has changed. */
            var modifiedSubmitError = modifiedDirtySinceLastSubmit && latestPropsRef.current.validate
                ? undefined
                : fieldState.submitError;
            var modifiedError = modifiedSubmitError ||
                ((fieldState.touched || fieldState.dirty) && fieldState.error);
            /**
             * If there has been a submit error, then use logic in modifiedError to determine validity,
             * so we can determine when there is a submit error which we do not want to display
             * because the value has been changed.
             */
            var modifiedValid = modifiedSubmitFailed
                ? modifiedError === undefined
                : fieldState.valid;
            function getTransform(eventOrValue, currentValue) {
                if (latestPropsRef.current.transform) {
                    return latestPropsRef.current.transform(eventOrValue, currentValue);
                }
                if (isEvent(eventOrValue)) {
                    var currentTarget = eventOrValue.currentTarget;
                    if (currentTarget.type === 'checkbox') {
                        if (currentTarget.checked) {
                            return currentTarget.value || true;
                        }
                        return currentTarget.value ? undefined : false;
                    }
                    else if (currentTarget) {
                        return currentTarget.value;
                    }
                }
                else {
                    return eventOrValue;
                }
            }
            setState({
                fieldProps: {
                    onChange: function (e) {
                        fieldState.change(getTransform(e, fieldState.value));
                    },
                    onBlur: fieldState.blur,
                    onFocus: fieldState.focus,
                    value: fieldState.value,
                },
                error: modifiedError,
                /**
                 * The following parameters are optionally typed in final-form to indicate that not all parameters need
                 * to be subscribed to. We cast them as booleans (using || false), since this is what they are semantically.
                 */
                valid: modifiedValid || false,
                meta: fieldStateToMeta(fieldState),
            });
        }, {
            dirty: true,
            dirtySinceLastSubmit: true,
            touched: true,
            valid: true,
            submitting: true,
            submitFailed: true,
            value: true,
            error: true,
            submitError: true,
        }, {
            getValidator: function () {
                return function validate(value, formState, fieldState) {
                    var supplied = latestPropsRef.current.validate;
                    if (supplied && fieldState) {
                        return supplied(value, formState, fieldStateToMeta(fieldState));
                    }
                };
            },
        });
        return unregister;
    }, [
        latestPropsRef,
        latestStateRef,
        registerField,
        props.name,
        hasDefaultValueChanged,
    ]);
    var fieldId = useMemo(function () { return (props.id ? props.id : props.name + "-" + uid({ id: props.name })); }, [props.id, props.name]);
    var extendedFieldProps = __assign(__assign({}, state.fieldProps), { name: props.name, isDisabled: isDisabled, isInvalid: Boolean(state.error), isRequired: Boolean(props.isRequired), 'aria-invalid': (state.error ? 'true' : 'false'), 'aria-labelledby': fieldId + "-label " + fieldId + "-helper " + fieldId + "-valid " + fieldId + "-error", id: fieldId });
    return (React.createElement(FieldWrapper, null,
        props.label && (React.createElement(Label, { id: fieldId + "-label", htmlFor: fieldId },
            props.label,
            props.isRequired && (React.createElement(RequiredIndicator, { "aria-hidden": "true" }, "*")))),
        React.createElement(FieldId.Provider, { value: fieldId }, props.children({
            fieldProps: extendedFieldProps,
            error: state.error,
            valid: state.valid,
            meta: state.meta,
        }))));
}
Field.defaultProps = {
    defaultValue: undefined,
    isDisabled: false,
};
export default Field;
//# sourceMappingURL=Field.js.map
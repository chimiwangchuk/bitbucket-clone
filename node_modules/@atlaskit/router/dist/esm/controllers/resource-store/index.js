import { __assign, __awaiter, __generator, __rest } from "tslib";
import { createContainer, createHook, createStore, createSubscriber, defaultRegistry, } from 'react-sweet-state';
import { getResourceStoreContext, getSliceForResource } from './selectors';
import { deserializeError, getExpiresAt, isFromSsr, serializeError, setExpiresAt, shouldUseCache, transformData, } from './utils';
export var actions = {
    /**
     * Set the state of a resource in the cache.
     *
     */
    setResourceState: function (type, key, state) { return function (_a) {
        var _b, _c;
        var setState = _a.setState, getState = _a.getState;
        var data = getState().data;
        setState({
            data: __assign(__assign({}, data), (_b = {}, _b[type] = __assign(__assign({}, (data[type] || {})), (_c = {}, _c[key] = state, _c)), _b)),
        });
    }; },
    /**
     * Update the data property for a resource in the cache.
     *
     * Also resets the expiresAt based on maxAge
     */
    updateResourceState: function (type, key, maxAge, getNewSliceData) { return function (_a) {
        var getState = _a.getState, dispatch = _a.dispatch;
        var data = getState().data;
        var slice = getSliceForResource({ data: data }, { type: type, key: key });
        dispatch(actions.setResourceState(type, key, __assign(__assign({}, slice), { data: getNewSliceData(slice.data), expiresAt: getExpiresAt(maxAge) })));
    }; },
    /**
     * Get a single resource, either from the cache if it exists and has not expired, or
     * the remote if it has expired.
     */
    getResource: function (resource, routerStoreContext) { return function (_a) {
        var getState = _a.getState, dispatch = _a.dispatch;
        return __awaiter(void 0, void 0, void 0, function () {
            var type, getKey, maxAge, getResourceFromRemote, setResourceState, _b, resourceStoreData, context, key, cached, withExpiresAt;
            return __generator(this, function (_c) {
                type = resource.type, getKey = resource.getKey, maxAge = resource.maxAge;
                getResourceFromRemote = actions.getResourceFromRemote, setResourceState = actions.setResourceState;
                _b = getState(), resourceStoreData = _b.data, context = _b.context;
                key = getKey(routerStoreContext, context);
                cached = getSliceForResource({ data: resourceStoreData }, { type: type, key: key });
                if (shouldUseCache(cached)) {
                    if (isFromSsr(cached)) {
                        withExpiresAt = setExpiresAt(cached, maxAge);
                        dispatch(setResourceState(type, key, withExpiresAt));
                        return [2 /*return*/, withExpiresAt];
                    }
                    return [2 /*return*/, cached];
                }
                return [2 /*return*/, dispatch(getResourceFromRemote(resource, routerStoreContext))];
            });
        });
    }; },
    /**
     * Request a single resource and update the resource cache.
     */
    getResourceFromRemote: function (resource, routerStoreContext) { return function (_a) {
        var getState = _a.getState, dispatch = _a.dispatch;
        return __awaiter(void 0, void 0, void 0, function () {
            var type, getKey, getData, maxAge, setResourceState, _b, resourceStoreData, context, key, slice, pending, response, _c, e_1;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        type = resource.type, getKey = resource.getKey, getData = resource.getData, maxAge = resource.maxAge;
                        setResourceState = actions.setResourceState;
                        _b = getState(), resourceStoreData = _b.data, context = _b.context;
                        key = getKey(routerStoreContext, context);
                        slice = getSliceForResource({ data: resourceStoreData }, { type: type, key: key });
                        if (slice.loading) {
                            return [2 /*return*/, slice];
                        }
                        pending = __assign(__assign({}, slice), { data: maxAge === 0 ? null : slice.data, error: maxAge === 0 ? null : slice.error, loading: true, promise: getData(routerStoreContext, context) });
                        dispatch(setResourceState(type, key, pending));
                        response = __assign({}, pending);
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 3, , 4]);
                        _c = response;
                        return [4 /*yield*/, pending.promise];
                    case 2:
                        _c.data = _d.sent();
                        response.error = null;
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _d.sent();
                        response.error = e_1;
                        return [3 /*break*/, 4];
                    case 4:
                        response.loading = false;
                        response.expiresAt = getExpiresAt(maxAge);
                        dispatch(setResourceState(type, key, response));
                        return [2 /*return*/, response];
                }
            });
        });
    }; },
    /**
     * Request all resources.
     *
     */
    requestAllResources: function (routerStoreContext) { return function (_a) {
        var dispatch = _a.dispatch;
        var route = (routerStoreContext || {}).route;
        if (!route || !route.resources) {
            return Promise.all([]);
        }
        return Promise.all(dispatch(actions.requestResources(route.resources, routerStoreContext)));
    }; },
    /**
     * Cleans expired resources and resets them back to their initial state.
     * We need to do this when transitioning into a route.
     */
    cleanExpiredResources: function (resources, routerStoreContext) { return function (_a) {
        var getState = _a.getState, dispatch = _a.dispatch;
        var _b = getState(), data = _b.data, resourceContext = _b.context;
        resources.forEach(function (resource) {
            var type = resource.type, getKey = resource.getKey;
            var key = getKey(routerStoreContext, resourceContext);
            var slice = getSliceForResource({ data: data }, { type: type, key: key });
            if (!slice.expiresAt || slice.expiresAt < Date.now()) {
                dispatch(actions.setResourceState(type, key, __assign(__assign({}, slice), { data: null, error: null, expiresAt: getExpiresAt(0) })));
            }
        });
    }; },
    /**
     * Requests a specific set of resources.
     */
    requestResources: function (resources, routerStoreContext) { return function (_a) {
        var dispatch = _a.dispatch;
        return resources.map(function (resource) {
            return dispatch(actions.getResource(resource, routerStoreContext));
        });
    }; },
    /**
     * Hydrates the store with state.
     * Will not override pre-hydrated state.
     *
     */
    hydrate: function (_a) {
        var resourceData = _a.resourceData, resourceContext = _a.resourceContext;
        return function (_a) {
            var getState = _a.getState, setState = _a.setState;
            var _b = getState(), data = _b.data, context = _b.context;
            function getNextStateValue(prev, next) {
                if (!Object.keys(prev).length && next && Object.keys(next).length) {
                    return next;
                }
                return prev;
            }
            var hydratedData = transformData(getNextStateValue(data, resourceData), function (_a) {
                var error = _a.error, rest = __rest(_a, ["error"]);
                return (__assign(__assign({}, rest), { error: !error ? null : deserializeError(error) }));
            });
            setState({
                data: hydratedData,
                context: getNextStateValue(context, resourceContext),
            });
        };
    },
    /**
     * Gets the store's context
     *
     */
    getContext: function () { return function (_a) {
        var getState = _a.getState;
        return getState().context;
    }; },
    /**
     * Returns safe, portable and reydratable data.
     *
     */
    getSafeData: function () { return function (_a) {
        var getState = _a.getState;
        return transformData(getState().data, function (_a) {
            var data = _a.data, error = _a.error;
            return ({
                data: data,
                promise: null,
                expiresAt: null,
                error: !error
                    ? null
                    : serializeError(error instanceof Error ? error : new Error(JSON.stringify(error))),
                loading: false,
            });
        });
    }; },
};
export var ResourceStore = createStore({
    initialState: {
        data: {},
        context: {},
    },
    actions: actions,
    name: 'router-resources',
});
export var ResourceContainer = createContainer(ResourceStore, {
    displayName: 'ResourceContainer',
});
export var ResourceActions = createSubscriber(ResourceStore, {
    selector: null,
});
export var ResourceSubscriber = createSubscriber(ResourceStore, {
    displayName: 'ResourceSelectorSubscriber',
    selector: function (state, props) {
        return getSliceForResource(state, {
            type: props.resourceType,
            key: props.resourceKey,
        });
    },
});
export var getResourceStore = function () {
    // @ts-ignore not providing a scopeId param
    return defaultRegistry.getStore(ResourceStore);
};
export var useResourceStore = createHook(ResourceStore, {
    selector: getSliceForResource,
});
export var useResourceStoreContext = createHook(ResourceStore, {
    selector: getResourceStoreContext,
});
export var useResourceActions = createHook(ResourceStore, {
    selector: null,
});
//# sourceMappingURL=index.js.map
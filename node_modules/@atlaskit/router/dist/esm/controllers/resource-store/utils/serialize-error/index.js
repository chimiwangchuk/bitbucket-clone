// NOTE! This has been copy pasted from https://github.com/sindresorhus/serialize-error/blob/master/index.js
// When the router moves to its own package, this must become a dependency
// For now, we have put it here so that we don't need to get it included in Jira's vendor bundle
import { __extends, __read, __values } from "tslib";
var NonError = /** @class */ (function (_super) {
    __extends(NonError, _super);
    function NonError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = 'NonError';
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NonError);
        }
        return _this;
    }
    return NonError;
}(Error));
var commonProperties = ['name', 'message', 'stack', 'code'];
var destroyCircular = function (from, seen, to_) {
    var e_1, _a, e_2, _b;
    var to = to_ || (Array.isArray(from) ? [] : {});
    seen.push(from);
    try {
        for (var _c = __values(Object.entries(from)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var _e = __read(_d.value, 2), key = _e[0], value = _e[1];
            if (typeof value === 'function') {
                continue;
            }
            if (!value || typeof value !== 'object') {
                to[key] = value;
                continue;
            }
            if (!seen.includes(from[key])) {
                to[key] = destroyCircular(from[key], seen.slice());
                continue;
            }
            to[key] = '[Circular]';
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    try {
        for (var commonProperties_1 = __values(commonProperties), commonProperties_1_1 = commonProperties_1.next(); !commonProperties_1_1.done; commonProperties_1_1 = commonProperties_1.next()) {
            var property = commonProperties_1_1.value;
            if (typeof from[property] === 'string') {
                to[property] = from[property];
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (commonProperties_1_1 && !commonProperties_1_1.done && (_b = commonProperties_1.return)) _b.call(commonProperties_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return to;
};
// const serializeError = <ErrorType = any>(value: ErrorType) => {
export var serializeError = function (value) {
    if (typeof value === 'object' && value !== null) {
        return destroyCircular(value, []);
    }
    // People sometimes throw things besides Error objectsâ€¦
    if (typeof value === 'function') {
        // `JSON.stringify()` discards functions. We do too, unless a function is thrown directly.
        return "[Function: " + (value.name || 'anonymous') + "]";
    }
    return value;
};
export var deserializeError = function (value) {
    if (value instanceof Error) {
        return value;
    }
    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        var newError = new Error();
        destroyCircular(value, [], newError);
        return newError;
    }
    return new NonError(value);
};
//# sourceMappingURL=index.js.map
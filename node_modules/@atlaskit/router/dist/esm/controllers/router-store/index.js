import { __assign, __awaiter, __generator, __rest } from "tslib";
import { createPath } from 'history';
import { unstable_batchedUpdates } from 'react-dom';
import { createContainer, createHook, createStore, createSubscriber, defaultRegistry, } from 'react-sweet-state';
import { DEFAULT_ACTION, DEFAULT_HISTORY, DEFAULT_MATCH, DEFAULT_ROUTE, } from '../../common/constants';
import { getRouteContext } from '../../common/utils/get-route-context';
import { getResourceStore } from '../resource-store';
import { getResourcesForNextLocation } from '../resource-store/utils';
import { getRelativePath, isExternalAbsolutePath } from './utils';
export var INITIAL_STATE = {
    history: DEFAULT_HISTORY,
    location: DEFAULT_HISTORY.location,
    query: {},
    routes: [],
    route: DEFAULT_ROUTE,
    match: DEFAULT_MATCH,
    action: DEFAULT_ACTION,
    unlisten: null,
    isStatic: false,
    transitionBlocker: function () { return __awaiter(void 0, void 0, void 0, function () { return __generator(this, function (_a) {
        return [2 /*return*/, true];
    }); }); },
    shouldUseSuspense: false,
};
var actions = {
    /**
     * Bootstraps the store with initial data.
     *
     */
    bootstrapStore: function (props) { return function (_a) {
        var setState = _a.setState, dispatch = _a.dispatch;
        var resourceContext = props.resourceContext, resourceData = props.resourceData, initialProps = __rest(props, ["resourceContext", "resourceData"]);
        var history = initialProps.history, routes = initialProps.routes, isStatic = initialProps.isStatic;
        var routeContext = getRouteContext(history.location, routes);
        setState(__assign(__assign(__assign({}, initialProps), routeContext), { route: routeContext.route || DEFAULT_ROUTE, match: routeContext.match || DEFAULT_MATCH }));
        getResourceStore().actions.hydrate({ resourceContext: resourceContext, resourceData: resourceData });
        if (!isStatic) {
            dispatch(actions.listen());
        }
    }; },
    /**
     * Uses the resource store to request resources for the route.
     * Must be dispatched after setting state with the new route context.
     *
     */
    requestRouteResources: function () { return function (_a) {
        var getState = _a.getState;
        var _b = getState(), route = _b.route, match = _b.match, query = _b.query, location = _b.location;
        return getResourceStore().actions.requestAllResources({
            route: route,
            match: match,
            query: query,
            location: location,
        });
    }; },
    /**
     * Starts listening to browser history and sets the unlisten function in state.
     * Will request route resources on route change.
     *
     */
    listen: function () { return function (_a) {
        var getState = _a.getState, setState = _a.setState;
        var _b = getState(), history = _b.history, routes = _b.routes, unlisten = _b.unlisten;
        if (unlisten) {
            return;
        }
        var stopListening = history.listen(function (location, action) { return __awaiter(void 0, void 0, void 0, function () {
            var nextContext, _a, currentMatch, currentRoute, currentQuery, currentLocation, transitionBlocker, canDo, _b, cleanExpiredResources_1, requestResources_1, getResourceStoreContext, nextLocationContext_1, nextResources_1;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        nextContext = getRouteContext(location, routes);
                        _a = getState(), currentMatch = _a.match, currentRoute = _a.route, currentQuery = _a.query, currentLocation = _a.location, transitionBlocker = _a.transitionBlocker;
                        return [4 /*yield*/, transitionBlocker(currentMatch && currentRoute
                                ? {
                                    match: currentMatch,
                                    route: currentRoute,
                                }
                                : null, nextContext.match && nextContext.route
                                ? {
                                    match: nextContext.match,
                                    route: nextContext.route,
                                }
                                : null, action)];
                    case 1:
                        canDo = _c.sent();
                        if (canDo) {
                            _b = getResourceStore().actions, cleanExpiredResources_1 = _b.cleanExpiredResources, requestResources_1 = _b.requestResources, getResourceStoreContext = _b.getContext;
                            nextLocationContext_1 = {
                                route: nextContext.route || DEFAULT_ROUTE,
                                match: nextContext.match || DEFAULT_MATCH,
                                query: nextContext.query,
                                location: location,
                            };
                            nextResources_1 = getResourcesForNextLocation({
                                route: currentRoute,
                                match: currentMatch,
                                query: currentQuery,
                                location: currentLocation,
                            }, nextLocationContext_1, getResourceStoreContext());
                            /* Explicitly batch update
                             * as we need resources cleaned + route changed + resource fetch started together
                             * If we do not batch, React might be re-render when route changes but resource
                             * fetching has not started yet, making the app render with data null */
                            unstable_batchedUpdates(function () {
                                cleanExpiredResources_1(nextResources_1, nextLocationContext_1);
                                setState(__assign(__assign({}, nextContext), { route: nextContext.route || DEFAULT_ROUTE, match: nextContext.match || DEFAULT_MATCH, action: action }));
                                requestResources_1(nextResources_1, nextLocationContext_1);
                            });
                        }
                        else {
                            // because history stack already updated, in order not to mess up it up, we can only replace the route
                            // using assign will push a new entry to the history stack.
                            window.location.replace(createPath(location));
                        }
                        return [2 /*return*/];
                }
            });
        }); });
        setState({
            unlisten: stopListening,
        });
    }; },
    push: function (path) { return function (_a) {
        var getState = _a.getState;
        var history = getState().history;
        if (isExternalAbsolutePath(path)) {
            window.location.assign(path);
        }
        else {
            history.push(getRelativePath(path));
        }
    }; },
    replace: function (path) { return function (_a) {
        var getState = _a.getState;
        var history = getState().history;
        if (isExternalAbsolutePath(path)) {
            window.location.replace(path);
        }
        else {
            history.replace(getRelativePath(path));
        }
    }; },
    goBack: function () { return function (_a) {
        var getState = _a.getState;
        var history = getState().history;
        history.goBack();
    }; },
    goForward: function () { return function (_a) {
        var getState = _a.getState;
        var history = getState().history;
        history.goForward();
    }; },
    registerBlock: function (blocker) { return function (_a) {
        var getState = _a.getState;
        var history = getState().history;
        return history.block(blocker);
    }; },
};
export var RouterStore = createStore({
    initialState: INITIAL_STATE,
    actions: actions,
    name: 'router',
});
export var RouterContainer = createContainer(RouterStore, {
    displayName: 'RouterContainer',
    onInit: function () { return function (_a, props) {
        var dispatch = _a.dispatch;
        dispatch(actions.bootstrapStore(props));
        !props.isStatic && dispatch(actions.requestRouteResources());
    }; },
});
export var RouterSubscriber = createSubscriber(RouterStore, {
    displayName: 'RouterSubscriber',
});
export var RouterActionsSubscriber = createSubscriber(RouterStore, {
    displayName: 'RouterActionsSubscriber',
    selector: null,
});
export var RouteResourceEnabledSubscriber = createSubscriber(RouterStore, {
    selector: function (state) { return Boolean(state.route && state.route.resources); },
});
export var useRouterStore = createHook(RouterStore);
export var useRouterStoreStatic = createHook(RouterStore, {
    selector: null,
});
export var getRouterStore = function () {
    // @ts-ignore calling `getStore` without providing a scopeId
    return defaultRegistry.getStore(RouterStore);
};
// @ts-ignore accessing private store property
export var getRouterState = function () { return getRouterStore().storeState.getState(); };
//# sourceMappingURL=index.js.map
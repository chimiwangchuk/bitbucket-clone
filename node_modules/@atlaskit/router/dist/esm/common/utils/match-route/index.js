import { __assign, __read } from "tslib";
import queryString from 'query-string';
import matchPath from './matchPath';
// import type { Match, Route, MatchedRoute } from '../../types';
/* This should match what react-router does to compute a root match. */
var computeRootMatch = function (pathname) { return ({
    path: '/',
    url: '/',
    params: {},
    isExact: pathname === '/',
    query: {},
}); };
/**
 * Matches `queryStr` against config stored in `queryConfig`.
 *
 * Returns `pathMatch` with an additional query prop with query params if the match succeeds,
 * otherwise returns null.
 *
 * TODO we are using `ReactRouterMatch` here until we migrate `matchPath` to be our own module.
 */
var matchQuery = function (queryConfig, queryParams, pathMatch) {
    var queryMatch = {};
    var isMatchingQuery = queryConfig.every(function (query) {
        // eslint-disable-next-line prefer-const
        var _a = __read(query.split('='), 2), names = _a[0], value = _a[1];
        var negation = false;
        /* Check if negative matching query param (eg 'foo!=1') */
        if (query.includes('!=')) {
            names = names.substring(0, names.length - 1);
            negation = true;
        }
        /* Allow alternate query params presence (eg 'foo|bar') */
        var matched = names.split('|').map(function (name) {
            var isOptional = false;
            /* Check if optional query param (eg 'foo?') */
            if (name.includes('?')) {
                // eslint-disable-next-line no-param-reassign
                name = name.substring(0, name.length - 1);
                isOptional = true;
            }
            /* First check if queryParams contains the relevant param */
            var match = Object.prototype.hasOwnProperty.call(queryParams, name);
            /* Save actual value so we expose it as part of match object */
            if (match) {
                queryMatch[name] = queryParams[name] || '';
            }
            /* If no value matching required or it is optional and the param is missing */
            if (!value || (isOptional && !match)) {
                return isOptional || match;
            }
            if (value.startsWith('(')) {
                /* Handle value being a regexp eg 's=(\\d+)' */
                match = new RegExp("^" + value + "$").test(queryParams[name] || '');
            }
            else {
                /* Handle value exact matching eg 's=123' */
                match = queryParams[name] === value;
            }
            return negation ? !match : match;
        });
        /* If at least one of alternate query params matches then it is a match */
        return matched.includes(true);
    });
    return isMatchingQuery ? __assign(__assign({}, pathMatch), { query: queryMatch }) : null;
};
/**
 * Does the given `pathname` and `queryStr` match a route in `routes`.
 *
 * Heavily based on https://github.com/ReactTraining/react-router/blob/master/packages/react-router-config/modules/matchRoute.js
 *
 * Note: This does not support nested routes at this stage.
 */
export default (function (routes, pathname, queryParams) {
    var queryParamObject = typeof queryParams === 'string'
        ? queryString.parse(queryParams)
        : queryParams;
    var matchedRoute = null;
    routes.some(function (route) {
        var pathMatch = route.path
            ? matchPath(pathname, route)
            : computeRootMatch(pathname);
        var match = pathMatch;
        if (pathMatch && route.query) {
            match = matchQuery(route.query, queryParamObject, pathMatch);
        }
        else if (pathMatch) {
            match = __assign(__assign({}, pathMatch), { query: {} });
        }
        if (match) {
            matchedRoute = { match: match, route: route };
        }
        return match;
    });
    return matchedRoute;
});
//# sourceMappingURL=index.js.map
import { __assign } from "tslib";
import { createPath } from 'history';
import debounce from 'lodash.debounce';
import noop from 'lodash.noop';
var hasWindow = function () { return typeof window !== 'undefined'; };
var methodsPlaceholders = {
    push: noop,
    replace: noop,
    goBack: noop,
    goForward: noop,
    listen: function () { return noop; },
    block: function () { return noop; },
};
var getLocation = function () {
    // todo - don't force non-optional search and hash
    var _a = (hasWindow() && window.location) || {}, _b = _a.pathname, pathname = _b === void 0 ? '' : _b, _c = _a.search, search = _c === void 0 ? '' : _c, _d = _a.hash, hash = _d === void 0 ? '' : _d;
    return { pathname: pathname, search: search, hash: hash };
};
var createLegacyListener = function (updateExposedLocation) {
    var node = document.querySelector('#content');
    var prevHref = window.location.href;
    var listeners = [];
    var historyStack = [prevHref];
    // note: window.history.length is capped at 50 entries
    var prevHistoryLength = window.history.length;
    var historyIndex = 0;
    var getAction = function () {
        var currentHref = window.location.href;
        if (prevHistoryLength === window.history.length) {
            if (historyStack[historyIndex - 1] === currentHref) {
                historyIndex -= 1;
                return 'POP';
            }
            if (historyStack[historyIndex + 1] === currentHref) {
                historyIndex += 1;
                return 'POP';
            }
            historyStack[historyStack.length - 1] = currentHref;
            return 'REPLACE';
        }
        historyStack.push(currentHref);
        historyIndex += 1;
        prevHistoryLength = window.history.length;
        return 'PUSH';
    };
    var onNodeChanges = debounce(function () {
        if (prevHref !== window.location.href) {
            var newLocation_1 = getLocation();
            updateExposedLocation(newLocation_1);
            var action_1 = getAction();
            listeners.forEach(function (listener) { return listener(newLocation_1, action_1); });
            prevHref = window.location.href;
        }
    }, 50);
    if (node) {
        var observer = new window.MutationObserver(onNodeChanges);
        observer.observe(node, {
            childList: true,
            subtree: true,
            attributes: true,
            characterData: true,
        });
    }
    return function (listener) {
        listeners = listeners.concat(listener);
        return function () {
            listeners = listeners.filter(function (lst) { return lst !== listener; });
        };
    };
};
export var createLegacyHistory = function () {
    var currentLocation = getLocation();
    var updateExposedLocation = function (v) {
        currentLocation = v;
    };
    return __assign({ get location() {
            return currentLocation;
        },
        get length() {
            return hasWindow() ? window.history.length : 1; // default length is 1
        } }, (hasWindow()
        ? {
            push: function (path) { return window.location.assign(path); },
            replace: function (path) {
                return window.history.replaceState({}, document.title, path);
            },
            goBack: function () { return window.history.back(); },
            goForward: function () { return window.history.forward(); },
            listen: createLegacyListener(updateExposedLocation),
            block: function () { return noop; },
            createHref: function (location) { return createPath(location); },
        }
        : methodsPlaceholders));
};
//# sourceMappingURL=index.js.map
/* eslint-disable react/require-default-props */
import { __assign, __extends } from "tslib";
import React from 'react';
import NodeResolver from 'react-node-resolver';
import flushable from 'flushable';
import { Popper } from '@atlaskit/popper';
import Portal from '@atlaskit/portal';
import { layers } from '@atlaskit/theme/constants';
import { withAnalyticsEvents, withAnalyticsContext, createAndFireEvent, } from '@atlaskit/analytics-next';
import { name as packageName, version as packageVersion, } from '../version.json';
import { Tooltip as StyledTooltip } from '../styled';
import Animation from './Animation';
import { hoveredPayload, unhoveredPayload } from './utils/analytics-payloads';
var SCROLL_OPTIONS = { capture: true, passive: true };
function getMousePosition(mouseCoordinates) {
    var safeMouse = mouseCoordinates || { top: 0, left: 0 };
    var getBoundingClientRect = function () {
        return {
            top: safeMouse.top,
            left: safeMouse.left,
            bottom: safeMouse.top,
            right: safeMouse.left,
            width: 0,
            height: 0,
        };
    };
    return {
        getBoundingClientRect: getBoundingClientRect,
        clientWidth: 0,
        clientHeight: 0,
    };
}
var pendingHide;
var showTooltip = function (fn, defaultDelay) {
    var isHidePending = pendingHide && pendingHide.pending();
    if (isHidePending) {
        pendingHide.flush();
    }
    var pendingShow = flushable(function () { return fn(isHidePending); }, isHidePending ? 0 : defaultDelay);
    return pendingShow.cancel;
};
var hideTooltip = function (fn, defaultDelay) {
    pendingHide = flushable(function (flushed) { return fn(flushed); }, defaultDelay);
    return pendingHide.cancel;
};
var Tooltip = /** @class */ (function (_super) {
    __extends(Tooltip, _super);
    function Tooltip() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.wrapperRef = null;
        _this.targetRef = null;
        _this.cancelPendingSetState = function () { };
        _this.userInteraction = 'mouse';
        _this.state = {
            immediatelyHide: false,
            immediatelyShow: false,
            isVisible: false,
            renderTooltip: false,
        };
        _this.handleWindowScroll = function () {
            if (_this.state.isVisible) {
                _this.cancelPendingSetState();
                _this.setState({ isVisible: false, immediatelyHide: true });
            }
        };
        _this.handleMouseClick = function () {
            if (_this.props.hideTooltipOnClick) {
                _this.cancelPendingSetState();
                _this.setState({ isVisible: false, immediatelyHide: true });
            }
        };
        _this.handleMouseDown = function () {
            if (_this.props.hideTooltipOnMouseDown) {
                _this.cancelPendingSetState();
                _this.setState({ isVisible: false, immediatelyHide: true });
            }
        };
        _this.handleMouseOver = function (e) {
            if (e.target === _this.wrapperRef) {
                return;
            }
            _this.userInteraction = 'mouse';
            // In the case where a tooltip is newly rendered but immediately becomes hovered,
            // we need to set the coordinates in the mouseOver event.
            if (!_this.fakeMouseElement) {
                _this.fakeMouseElement = getMousePosition({
                    left: e.clientX,
                    top: e.clientY,
                });
            }
            _this.handleShowTooltip();
        };
        _this.handleFocus = function () {
            _this.userInteraction = 'keyboard';
            // We need to fake the mouse dimensions even on focus because the code path currently assumes
            // fake mouse element needs to exist before showing the tooltip.
            if (!_this.fakeMouseElement) {
                _this.fakeMouseElement = getMousePosition({
                    left: 0,
                    top: 0,
                });
            }
            _this.handleShowTooltip();
        };
        _this.handleShowTooltip = function () {
            _this.cancelPendingSetState();
            if (Boolean(_this.props.content) && !_this.state.isVisible) {
                _this.cancelPendingSetState = showTooltip(function (immediatelyShow) {
                    _this.setState({
                        isVisible: true,
                        renderTooltip: true,
                        immediatelyShow: immediatelyShow,
                    });
                }, _this.props.delay || 0);
            }
        };
        _this.handleHideTooltip = function (e) {
            if (e.target === _this.wrapperRef) {
                return;
            }
            _this.cancelPendingSetState();
            if (_this.state.isVisible) {
                _this.cancelPendingSetState = hideTooltip(function (immediatelyHide) {
                    _this.setState({ isVisible: false, immediatelyHide: immediatelyHide });
                }, _this.props.delay || 0);
            }
        };
        // Update mouse coordinates, used when position is 'mouse'.
        // We are not debouncing/throttling this function because we aren't causing any
        // re-renders or performaing any intensive calculations, we're just updating a value.
        // React also doesn't play nice debounced DOM event handlers because they pool their
        // SyntheticEvent objects. Need to use event.persist as a workaround - https://stackoverflow.com/a/24679479/893630
        _this.handleMouseMove = function (event) {
            if (!_this.state.renderTooltip) {
                _this.fakeMouseElement = getMousePosition({
                    left: event.clientX,
                    top: event.clientY,
                });
            }
        };
        return _this;
    }
    Tooltip.prototype.componentWillUnmount = function () {
        this.cancelPendingSetState();
        this.removeScrollListener();
    };
    Tooltip.prototype.componentDidUpdate = function (_prevProps, prevState) {
        if (!prevState.isVisible && this.state.isVisible) {
            if (this.props.onShow)
                this.props.onShow();
            window.addEventListener('scroll', this.handleWindowScroll, SCROLL_OPTIONS);
        }
        else if (prevState.isVisible && !this.state.isVisible) {
            if (this.props.onHide)
                this.props.onHide();
            this.removeScrollListener();
        }
    };
    Tooltip.prototype.removeScrollListener = function () {
        window.removeEventListener('scroll', this.handleWindowScroll, SCROLL_OPTIONS);
    };
    Tooltip.prototype.shouldPositionTooltipNearMouse = function () {
        var position = this.props.position;
        return position === 'mouse' && this.userInteraction === 'mouse';
    };
    Tooltip.prototype.render = function () {
        var _this = this;
        var _a = this.props, children = _a.children, position = _a.position, mousePosition = _a.mousePosition, content = _a.content, truncate = _a.truncate, TooltipContainer = _a.component, TargetContainer = _a.tag, testId = _a.testId;
        var _b = this.state, isVisible = _b.isVisible, renderTooltip = _b.renderTooltip, immediatelyShow = _b.immediatelyShow, immediatelyHide = _b.immediatelyHide;
        var tooltipPosition = position === 'mouse' ? mousePosition : position;
        return (
        /* eslint-disable jsx-a11y/mouse-events-have-key-events */
        React.createElement(React.Fragment, null,
            TargetContainer && (React.createElement(TargetContainer, { onClick: this.handleMouseClick, onMouseOver: this.handleMouseOver, onMouseOut: this.handleHideTooltip, onMouseMove: this.handleMouseMove, onMouseDown: this.handleMouseDown, onFocus: this.handleFocus, onBlur: this.handleHideTooltip, ref: function (wrapperRef) {
                    _this.wrapperRef = wrapperRef;
                } },
                React.createElement(NodeResolver, { innerRef: function (ref) {
                        _this.targetRef = ref;
                    } }, React.Children.only(children)))),
            renderTooltip && this.targetRef && this.fakeMouseElement ? (React.createElement(Portal, { zIndex: layers.tooltip() },
                React.createElement(Popper, { placement: tooltipPosition, referenceElement: 
                    // https://github.com/FezVrasta/react-popper#usage-without-a-reference-htmlelement
                    // We are using a popper technique to pass in a faked element when we use mouse.
                    (this.shouldPositionTooltipNearMouse()
                        ? this.fakeMouseElement
                        : this.targetRef) }, function (_a) {
                    var ref = _a.ref, style = _a.style;
                    return TooltipContainer && (React.createElement(Animation, { immediatelyShow: immediatelyShow, immediatelyHide: immediatelyHide, onExited: function () { return _this.setState({ renderTooltip: false }); }, in: isVisible }, function (getAnimationStyles) { return (React.createElement(TooltipContainer
                    // innerRef can't be null so shortcircuit to undefined if it is.
                    , { 
                        // innerRef can't be null so shortcircuit to undefined if it is.
                        innerRef: ref || undefined, className: "Tooltip", style: __assign(__assign({}, getAnimationStyles()), style), truncate: truncate || false, "data-placement": tooltipPosition, "data-testid": testId }, content)); }));
                }))) : null)
        /* eslint-enable */
        );
    };
    Tooltip.defaultProps = {
        component: StyledTooltip,
        delay: 300,
        mousePosition: 'bottom',
        position: 'bottom',
        tag: 'div',
    };
    return Tooltip;
}(React.Component));
export { Tooltip as TooltipWithoutAnalytics };
var createAndFireEventOnAtlaskit = createAndFireEvent('atlaskit');
export default withAnalyticsContext({
    componentName: 'tooltip',
    packageName: packageName,
    packageVersion: packageVersion,
})(withAnalyticsEvents({
    onHide: unhoveredPayload,
    onShow: createAndFireEventOnAtlaskit(__assign({}, hoveredPayload)),
})(Tooltip));
//# sourceMappingURL=Tooltip.js.map
import { __extends, __makeTemplateObject } from "tslib";
import React from 'react';
import { Component } from 'react';
import styled from 'styled-components';
import { MediaSingle as UIMediaSingle, WidthConsumer, akEditorFullPageMaxWidth, mapBreakpointToLayoutMaxWidth, akEditorFullWidthLayoutWidth, } from '@atlaskit/editor-common';
import { FullPagePadding } from '../../ui/Renderer/style';
var DEFAULT_WIDTH = 250;
var DEFAULT_HEIGHT = 200;
var ExtendedUIMediaSingle = styled(UIMediaSingle)(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  ", " transition: all 0.1s linear;\n"], ["\n  ",
    " transition: all 0.1s linear;\n"])), function (_a) {
    var layout = _a.layout;
    return layout === 'full-width' || layout === 'wide'
        ? "\n  margin-left: 50%;\n  transform: translateX(-50%);\n  "
        : "";
});
var MediaSingle = /** @class */ (function (_super) {
    __extends(MediaSingle, _super);
    function MediaSingle(props) {
        var _this = _super.call(this, props) || this;
        _this.onExternalImageLoaded = function (_a) {
            var width = _a.width, height = _a.height;
            _this.setState({
                width: width,
                height: height,
            });
        };
        _this.state = {}; // Need to initialize with empty state.
        return _this;
    }
    MediaSingle.prototype.render = function () {
        var _this = this;
        var props = this.props;
        var child = React.Children.only(React.Children.toArray(props.children)[0]);
        var _a = child.props, _b = _a.width, width = _b === void 0 ? DEFAULT_WIDTH : _b, _c = _a.height, height = _c === void 0 ? DEFAULT_HEIGHT : _c, type = _a.type;
        if (type === 'external') {
            var _d = this.state, stateWidth = _d.width, stateHeight = _d.height;
            if (width === null) {
                width = stateWidth || DEFAULT_WIDTH;
            }
            if (height === null) {
                height = stateHeight || DEFAULT_HEIGHT;
            }
        }
        if (width === null) {
            width = DEFAULT_WIDTH;
            height = DEFAULT_HEIGHT;
        }
        // TODO: put appearance-based padding into theme instead
        var rendererAppearance = this.props.rendererAppearance;
        var padding = rendererAppearance === 'full-page' ? FullPagePadding * 2 : 0;
        return (React.createElement(WidthConsumer, null, function (_a) {
            var containerWidth = _a.width, breakpoint = _a.breakpoint;
            var _b = _this.props, isInsideOfBlockNode = _b.isInsideOfBlockNode, allowDynamicTextSizing = _b.allowDynamicTextSizing;
            var cardWidth = containerWidth;
            var cardHeight = (height / width) * cardWidth;
            var cardDimensions = {
                width: cardWidth + "px",
                height: cardHeight + "px",
            };
            var isFullWidth = rendererAppearance === 'full-width';
            var nonFullWidthSize = containerWidth;
            if (!isInsideOfBlockNode && rendererAppearance !== 'comment') {
                var isContainerSizeGreaterThanMaxFullPageWidth = containerWidth - padding >= akEditorFullPageMaxWidth;
                if (isContainerSizeGreaterThanMaxFullPageWidth &&
                    allowDynamicTextSizing) {
                    nonFullWidthSize = mapBreakpointToLayoutMaxWidth(breakpoint);
                }
                else if (isContainerSizeGreaterThanMaxFullPageWidth) {
                    nonFullWidthSize = akEditorFullPageMaxWidth;
                }
                else {
                    nonFullWidthSize = containerWidth - padding;
                }
            }
            var lineLength = isFullWidth
                ? Math.min(akEditorFullWidthLayoutWidth, containerWidth - padding)
                : nonFullWidthSize;
            var originalDimensions = {
                height: height,
                width: width,
            };
            return (React.createElement(ExtendedUIMediaSingle, { layout: props.layout, width: width, height: height, lineLength: isInsideOfBlockNode ? containerWidth : lineLength, containerWidth: containerWidth, pctWidth: props.width, fullWidthMode: isFullWidth }, React.cloneElement(child, {
                resizeMode: 'stretchy-fit',
                cardDimensions: cardDimensions,
                originalDimensions: originalDimensions,
                onExternalImageLoaded: _this.onExternalImageLoaded,
                disableOverlay: true,
            })));
        }));
    };
    return MediaSingle;
}(Component));
export default MediaSingle;
var templateObject_1;
//# sourceMappingURL=mediaSingle.js.map
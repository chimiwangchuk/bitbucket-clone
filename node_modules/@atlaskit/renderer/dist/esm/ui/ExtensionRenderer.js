import { __extends } from "tslib";
import React from 'react';
import { getExtensionRenderer, WithProviders, getNodeRenderer, } from '@atlaskit/editor-common';
var ExtensionRenderer = /** @class */ (function (_super) {
    __extends(ExtensionRenderer, _super);
    function ExtensionRenderer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            extensionProvider: null,
        };
        _this.mounted = false;
        _this.handleProvider = function (name, providerPromise) {
            providerPromise &&
                providerPromise.then(function (provider) {
                    var _a;
                    if (_this.mounted) {
                        _this.setState((_a = {}, _a[name] = provider, _a));
                    }
                });
        };
        _this.renderExtensionNode = function (extensionProvider) {
            var _a = _this.props, extensionHandlers = _a.extensionHandlers, rendererContext = _a.rendererContext, extensionType = _a.extensionType, extensionKey = _a.extensionKey, parameters = _a.parameters, content = _a.content, text = _a.text, type = _a.type;
            var extensionParams = {
                type: type,
                extensionKey: extensionKey,
                extensionType: extensionType,
                parameters: parameters,
                content: content || text,
            };
            var result = null;
            try {
                if (extensionHandlers && extensionHandlers[extensionType]) {
                    var render = getExtensionRenderer(extensionHandlers[extensionType]);
                    result = render(extensionParams, rendererContext.adDoc);
                }
                if (!result && extensionProvider) {
                    var NodeRenderer = getNodeRenderer(extensionProvider, extensionType, extensionKey);
                    result = React.createElement(NodeRenderer, { extensionParams: extensionParams });
                }
            }
            catch (e) {
                /** We don't want this error to block renderer */
                /** We keep rendering the default content */
            }
            return _this.props.children({ result: result });
        };
        _this.setupAndRenderExtensionNode = function (providers) {
            var extensionProvider = _this.state.extensionProvider;
            if (!extensionProvider && providers.extensionProvider) {
                _this.handleProvider('extensionProvider', providers.extensionProvider);
            }
            return _this.renderExtensionNode(extensionProvider);
        };
        return _this;
    }
    ExtensionRenderer.prototype.UNSAFE_componentWillMount = function () {
        this.mounted = true;
    };
    ExtensionRenderer.prototype.componentWillUnmount = function () {
        this.mounted = false;
    };
    ExtensionRenderer.prototype.render = function () {
        var providers = this.props.providers;
        if (!providers) {
            return this.setupAndRenderExtensionNode({});
        }
        return (React.createElement(WithProviders, { providers: ['extensionProvider'], providerFactory: providers, renderNode: this.setupAndRenderExtensionNode }));
    };
    return ExtensionRenderer;
}(React.Component));
export default ExtensionRenderer;
//# sourceMappingURL=ExtensionRenderer.js.map
import { __assign, __extends, __rest } from "tslib";
import React, { PureComponent } from 'react';
import { createPortal } from 'react-dom';
import Select from 'react-select';
import createFocusTrap from 'focus-trap';
import { Manager, Reference, Popper } from 'react-popper';
import NodeResolver from 'react-node-resolver';
import shallowEqualObjects from 'shallow-equal/objects';
import { N80 } from '@atlaskit/theme/colors';
import { MenuDialog, DummyControl, defaultComponents } from './components';
/** Are we rendering on the client or server? */
var canUseDOM = function () {
    return Boolean(typeof window !== 'undefined' &&
        window.document &&
        window.document.createElement);
};
// ==============================
// Class
// ==============================
var defaultStyles = {
    groupHeading: function (provided) { return (__assign(__assign({}, provided), { color: N80 })); },
};
var defaultPopperProps = {
    modifiers: { offset: { offset: "0, 8" } },
    placement: 'bottom-start',
};
var isEmpty = function (obj) { return Object.keys(obj).length === 0; };
var PopupSelect = /** @class */ (function (_super) {
    __extends(PopupSelect, _super);
    function PopupSelect() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.focusTrap = null;
        _this.menuRef = null;
        _this.selectRef = null;
        _this.targetRef = null;
        _this.state = {
            isOpen: false,
            mergedComponents: defaultComponents,
            mergedPopperProps: defaultPopperProps,
        };
        // Event Handlers
        // ==============================
        _this.handleKeyDown = function (event) {
            switch (event.key) {
                case 'Escape':
                case 'Esc':
                    _this.close();
                    break;
                default:
            }
            if (_this.props.handleKeyDown) {
                _this.props.handleKeyDown(event);
            }
        };
        _this.handleClick = function (_a) {
            var target = _a.target;
            var isOpen = _this.state.isOpen;
            // appease flow
            if (!(target instanceof Element))
                return;
            // NOTE: Why not use the <Blanket /> component to close?
            // We don't want to interupt the user's flow. Taking this approach allows
            // user to click "through" to other elements and close the popout.
            if (isOpen && _this.menuRef && !_this.menuRef.contains(target)) {
                _this.close();
            }
            // open on target click -- we can't trust consumers to spread the onClick
            // property to the target
            if (!isOpen && _this.targetRef && _this.targetRef.contains(target)) {
                _this.open();
            }
        };
        _this.handleSelectChange = function (value, actionMeta) {
            var _a = _this.props, closeMenuOnSelect = _a.closeMenuOnSelect, onChange = _a.onChange;
            if (closeMenuOnSelect && actionMeta.action !== 'clear')
                _this.close();
            if (onChange)
                onChange(value, actionMeta);
        };
        // Internal Lifecycle
        // ==============================
        _this.open = function () {
            var onOpen = _this.props.onOpen;
            if (onOpen)
                onOpen();
            _this.setState({ isOpen: true }, _this.initialiseFocusTrap);
            if (_this.selectRef) {
                _this.selectRef.select.openMenu('first'); // HACK
            }
            if (typeof window === 'undefined')
                return;
            window.addEventListener('keydown', _this.handleKeyDown);
        };
        _this.initialiseFocusTrap = function () {
            if (!_this.menuRef)
                return;
            var trapConfig = {
                clickOutsideDeactivates: true,
                escapeDeactivates: true,
                fallbackFocus: _this.menuRef,
                returnFocusOnDeactivate: true,
            };
            _this.focusTrap = createFocusTrap(_this.menuRef, trapConfig);
            // allow time for the HTMLElement to render
            setTimeout(function () { return _this.focusTrap.activate(); }, 1);
        };
        _this.close = function () {
            var onClose = _this.props.onClose;
            if (onClose)
                onClose();
            _this.setState({ isOpen: false });
            if (_this.focusTrap) {
                _this.focusTrap.deactivate();
            }
            if (typeof window === 'undefined')
                return;
            window.removeEventListener('keydown', _this.handleKeyDown);
        };
        // Refs
        // ==============================
        _this.resolveTargetRef = function (popperRef) { return function (ref) {
            // avoid thrashing fn calls
            if (!_this.targetRef && popperRef && ref) {
                _this.targetRef = ref;
                if (typeof popperRef === 'function') {
                    popperRef(ref);
                }
                else {
                    popperRef.current = ref;
                }
            }
        }; };
        _this.resolveMenuRef = function (popperRef) { return function (ref) {
            _this.menuRef = ref;
            if (typeof popperRef === 'function') {
                popperRef(ref);
            }
            else {
                popperRef.current = ref;
            }
        }; };
        _this.getSelectRef = function (ref) {
            _this.selectRef = ref;
        };
        // Utils
        // ==============================
        // account for groups when counting options
        // this may need to be recursive, right now it just counts one level
        _this.getItemCount = function () {
            var options = _this.props.options;
            var count = 0;
            options.forEach(function (groupOrOption) {
                if (groupOrOption.options) {
                    groupOrOption.options.forEach(function () { return count++; });
                }
                else {
                    count++;
                }
            });
            return count;
        };
        _this.getMaxHeight = function () {
            var maxMenuHeight = _this.props.maxMenuHeight;
            if (!_this.selectRef)
                return maxMenuHeight;
            // subtract the control height to maintain consistency
            var showSearchControl = _this.showSearchControl();
            var controlRef = _this.selectRef.select.controlRef;
            // @ts-ignore React-select provides incomplete types for controlRef
            var offsetHeight = showSearchControl ? controlRef.offsetHeight : 0;
            var maxHeight = maxMenuHeight - offsetHeight;
            return maxHeight;
        };
        // if the threshold is exceeded display the search control
        _this.showSearchControl = function () {
            var searchThreshold = _this.props.searchThreshold;
            return _this.getItemCount() > searchThreshold;
        };
        // Renderers
        // ==============================
        _this.renderSelect = function () {
            var _a = _this.props, footer = _a.footer, maxMenuWidth = _a.maxMenuWidth, minMenuWidth = _a.minMenuWidth, target = _a.target, props = __rest(_a, ["footer", "maxMenuWidth", "minMenuWidth", "target"]);
            var _b = _this.state, isOpen = _b.isOpen, mergedComponents = _b.mergedComponents, mergedPopperProps = _b.mergedPopperProps;
            var showSearchControl = _this.showSearchControl();
            var portalDestination = canUseDOM() ? document.body : null;
            var components = __assign(__assign({}, mergedComponents), { Control: showSearchControl ? mergedComponents.Control : DummyControl });
            if (!portalDestination || !isOpen)
                return null;
            var popper = (React.createElement(Popper, __assign({}, mergedPopperProps), function (_a) {
                var placement = _a.placement, ref = _a.ref, style = _a.style;
                return (React.createElement(NodeResolver, { innerRef: _this.resolveMenuRef(ref) },
                    React.createElement(MenuDialog, { style: style, "data-placement": placement, minWidth: minMenuWidth, maxWidth: maxMenuWidth },
                        React.createElement(Select, __assign({ backspaceRemovesValue: false, controlShouldRenderValue: false, isClearable: false, tabSelectsValue: false, menuIsOpen: true, ref: _this.getSelectRef }, props, { isSearchable: showSearchControl, styles: __assign(__assign({}, defaultStyles), props.styles), maxMenuHeight: _this.getMaxHeight(), components: components, onChange: _this.handleSelectChange })),
                        footer)));
            }));
            return mergedPopperProps.positionFixed
                ? popper
                : createPortal(popper, portalDestination);
        };
        return _this;
    }
    PopupSelect.getDerivedStateFromProps = function (props, state) {
        var newState = {};
        // Merge consumer and default popper props
        var mergedPopperProps = __assign(__assign({}, defaultPopperProps), props.popperProps);
        if (!shallowEqualObjects(mergedPopperProps, state.mergedPopperProps)) {
            newState.mergedPopperProps = mergedPopperProps;
        }
        // Merge consumer and default components
        var mergedComponents = __assign(__assign({}, defaultComponents), props.components);
        if (!shallowEqualObjects(mergedComponents, state.mergedComponents)) {
            newState.mergedComponents = mergedComponents;
        }
        if (!isEmpty(newState))
            return newState;
        return null;
    };
    PopupSelect.prototype.componentDidMount = function () {
        if (typeof window === 'undefined')
            return;
        window.addEventListener('click', this.handleClick);
    };
    PopupSelect.prototype.componentWillUnmount = function () {
        if (typeof window === 'undefined')
            return;
        window.removeEventListener('click', this.handleClick);
        window.removeEventListener('keydown', this.handleKeyDown);
    };
    PopupSelect.prototype.render = function () {
        var _this = this;
        var target = this.props.target;
        var isOpen = this.state.isOpen;
        return (React.createElement(Manager, null,
            React.createElement(Reference, null, function (_a) {
                var ref = _a.ref;
                return target && target({ ref: _this.resolveTargetRef(ref), isOpen: isOpen });
            }),
            this.renderSelect()));
    };
    PopupSelect.defaultProps = {
        closeMenuOnSelect: true,
        components: {},
        maxMenuHeight: 300,
        maxMenuWidth: 440,
        minMenuWidth: 220,
        popperProps: {},
        searchThreshold: 5,
        styles: {},
        options: [],
    };
    return PopupSelect;
}(PureComponent));
export default PopupSelect;
//# sourceMappingURL=PopupSelect.js.map
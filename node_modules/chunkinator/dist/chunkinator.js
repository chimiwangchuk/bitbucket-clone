"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tap_1 = require("rxjs/operators/tap");
var concatMap_1 = require("rxjs/operators/concatMap");
var fromPromise_1 = require("rxjs/observable/fromPromise");
var Subject_1 = require("rxjs/Subject");
var slicenator_1 = require("./slicenator");
var hashinator_1 = require("./hashinator");
var probinator_1 = require("./probinator");
var uploadinator_1 = require("./uploadinator");
var processinator_1 = require("./processinator");
var utils_1 = require("./utils");
exports.getObservableFromFile = function (file, options, callbacks) {
    return fromPromise_1.fromPromise(utils_1.fetchBlob(file)).pipe(concatMap_1.concatMap(function (blob) {
        var chunkSize = options.chunkSize;
        var onProgress = callbacks.onProgress;
        var totalChunks = Math.ceil(blob.size / chunkSize);
        var slicenatedBlobs = slicenator_1.slicenator(blob, { size: chunkSize });
        var hashinatedBlobs = hashinator_1.hashinator(slicenatedBlobs, {
            concurrency: options.hashingConcurrency,
            hasher: options.hashingFunction
        });
        var probinatedBlobs = probinator_1.probinator(hashinatedBlobs, {
            batchSize: options.probingBatchSize,
            prober: options.probingFunction
        });
        var uploadedChunks = 0;
        var uploadedBlobs = uploadinator_1.uploadinator(probinatedBlobs, {
            concurrency: options.uploadingConcurrency,
            uploader: options.uploadingFunction
        });
        if (onProgress) {
            uploadedBlobs = uploadedBlobs.pipe(tap_1.tap(function () {
                uploadedChunks += 1;
                onProgress(uploadedChunks / totalChunks);
            }));
        }
        return processinator_1.processinator(uploadedBlobs, {
            batchSize: options.processingBatchSize,
            processor: options.processingFunction
        });
    }));
};
exports.chunkinator = function (file, options, callbacks) {
    return toCancelablePromise(exports.getObservableFromFile(file, options, callbacks));
};
function toCancelablePromise(observable) {
    var subject = new Subject_1.Subject();
    var subscription = observable.subscribe(subject);
    return {
        response: subject.toPromise(),
        cancel: function () {
            subscription.unsubscribe();
            subject.error("canceled");
        }
    };
}
exports.toCancelablePromise = toCancelablePromise;
//# sourceMappingURL=chunkinator.js.map